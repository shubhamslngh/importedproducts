{
  "resolvedId": "/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/core/ObservableQuery.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { cloneDeep, compact, getOperationDefinition, Observable, iterateObserversSafely, fixObservableSubclass, getQueryDefinition, } from \"../utilities/index.js\";\nimport { equalByQuery } from \"./equalByQuery.js\";\nvar assign = Object.assign, hasOwnProperty = Object.hasOwnProperty;\nvar ObservableQuery = /** @class */ (function (_super) {\n    __extends(ObservableQuery, _super);\n    function ObservableQuery(_a) {\n        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;\n        var _this = _super.call(this, function (observer) {\n            // Zen Observable has its own error function, so in order to log correctly\n            // we need to provide a custom error callback.\n            try {\n                var subObserver = observer._subscription._observer;\n                if (subObserver && !subObserver.error) {\n                    subObserver.error = defaultSubscriptionObserverErrorCallback;\n                }\n            }\n            catch (_a) { }\n            var first = !_this.observers.size;\n            _this.observers.add(observer);\n            // Deliver most recent error or result.\n            var last = _this.last;\n            if (last && last.error) {\n                observer.error && observer.error(last.error);\n            }\n            else if (last && last.result) {\n                observer.next && observer.next(last.result);\n            }\n            // Initiate observation of this query if it hasn't been reported to\n            // the QueryManager yet.\n            if (first) {\n                // Blindly catching here prevents unhandled promise rejections,\n                // and is safe because the ObservableQuery handles this error with\n                // this.observer.error, so we're not just swallowing the error by\n                // ignoring it here.\n                _this.reobserve().catch(function () { });\n            }\n            return function () {\n                if (_this.observers.delete(observer) && !_this.observers.size) {\n                    _this.tearDownQuery();\n                }\n            };\n        }) || this;\n        _this.observers = new Set();\n        _this.subscriptions = new Set();\n        // related classes\n        _this.queryInfo = queryInfo;\n        _this.queryManager = queryManager;\n        // active state\n        _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n        _this.isTornDown = false;\n        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? \"cache-first\" : _d;\n        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, \n        // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        _f = options.initialFetchPolicy, \n        // Make sure we don't store \"standby\" as the initialFetchPolicy.\n        initialFetchPolicy = _f === void 0 ? fetchPolicy === \"standby\" ? defaultFetchPolicy : (fetchPolicy) : _f;\n        _this.options = __assign(__assign({}, options), { \n            // Remember the initial options.fetchPolicy so we can revert back to this\n            // policy when variables change. This information can also be specified\n            // (or overridden) by providing options.initialFetchPolicy explicitly.\n            initialFetchPolicy: initialFetchPolicy, \n            // This ensures this.options.fetchPolicy always has a string value, in\n            // case options.fetchPolicy was not provided.\n            fetchPolicy: fetchPolicy });\n        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n        var opDef = getOperationDefinition(_this.query);\n        _this.queryName = opDef && opDef.name && opDef.name.value;\n        return _this;\n    }\n    Object.defineProperty(ObservableQuery.prototype, \"query\", {\n        // The `query` computed property will always reflect the document transformed\n        // by the last run query. `this.options.query` will always reflect the raw\n        // untransformed query to ensure document transforms with runtime conditionals\n        // are run on the original document.\n        get: function () {\n            return this.lastQuery || this.options.query;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ObservableQuery.prototype, \"variables\", {\n        // Computed shorthand for this.options.variables, preserved for\n        // backwards compatibility.\n        /**\n         * An object containing the variables that were provided for the query.\n         */\n        get: function () {\n            return this.options.variables;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ObservableQuery.prototype.result = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // TODO: this code doesnâ€™t actually make sense insofar as the observer\n            // will never exist in this.observers due how zen-observable wraps observables.\n            // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\n            var observer = {\n                next: function (result) {\n                    resolve(result);\n                    // Stop the query within the QueryManager if we can before\n                    // this function returns.\n                    //\n                    // We do this in order to prevent observers piling up within\n                    // the QueryManager. Notice that we only fully unsubscribe\n                    // from the subscription in a setTimeout(..., 0)  call. This call can\n                    // actually be handled by the browser at a much later time. If queries\n                    // are fired in the meantime, observers that should have been removed\n                    // from the QueryManager will continue to fire, causing an unnecessary\n                    // performance hit.\n                    _this.observers.delete(observer);\n                    if (!_this.observers.size) {\n                        _this.queryManager.removeQuery(_this.queryId);\n                    }\n                    setTimeout(function () {\n                        subscription.unsubscribe();\n                    }, 0);\n                },\n                error: reject,\n            };\n            var subscription = _this.subscribe(observer);\n        });\n    };\n    /** @internal */\n    ObservableQuery.prototype.resetDiff = function () {\n        this.queryInfo.resetDiff();\n    };\n    ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {\n        if (saveAsLastResult === void 0) { saveAsLastResult = true; }\n        // Use the last result as long as the variables match this.variables.\n        var lastResult = this.getLastResult(true);\n        var networkStatus = this.queryInfo.networkStatus ||\n            (lastResult && lastResult.networkStatus) ||\n            NetworkStatus.ready;\n        var result = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus });\n        var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a;\n        if (\n        // These fetch policies should never deliver data from the cache, unless\n        // redelivering a previously delivered result.\n        skipCacheDataFor(fetchPolicy) ||\n            // If this.options.query has @client(always: true) fields, we cannot\n            // trust diff.result, since it was read from the cache without running\n            // local resolvers (and it's too late to run resolvers now, since we must\n            // return a result synchronously).\n            this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) {\n            // Fall through.\n        }\n        else if (this.waitForOwnResult) {\n            // This would usually be a part of `QueryInfo.getDiff()`.\n            // which we skip in the waitForOwnResult case since we are not\n            // interested in the diff.\n            this.queryInfo[\"updateWatch\"]();\n        }\n        else {\n            var diff = this.queryInfo.getDiff();\n            if (diff.complete || this.options.returnPartialData) {\n                result.data = diff.result;\n            }\n            if (equal(result.data, {})) {\n                result.data = void 0;\n            }\n            if (diff.complete) {\n                // Similar to setting result.partial to false, but taking advantage of the\n                // falsiness of missing fields.\n                delete result.partial;\n                // If the diff is complete, and we're using a FetchPolicy that\n                // terminates after a complete cache read, we can assume the next result\n                // we receive will have NetworkStatus.ready and !loading.\n                if (diff.complete &&\n                    result.networkStatus === NetworkStatus.loading &&\n                    (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")) {\n                    result.networkStatus = NetworkStatus.ready;\n                    result.loading = false;\n                }\n            }\n            else {\n                result.partial = true;\n            }\n            if (globalThis.__DEV__ !== false &&\n                !diff.complete &&\n                !this.options.partialRefetch &&\n                !result.loading &&\n                !result.data &&\n                !result.error) {\n                logMissingFieldErrors(diff.missing);\n            }\n        }\n        if (saveAsLastResult) {\n            this.updateLastResult(result);\n        }\n        return result;\n    };\n    // Compares newResult to the snapshot we took of this.lastResult when it was\n    // first received.\n    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult, variables) {\n        if (!this.last) {\n            return true;\n        }\n        var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ?\n            !equalByQuery(this.query, this.last.result, newResult, this.variables)\n            : !equal(this.last.result, newResult);\n        return (resultIsDifferent || (variables && !equal(this.last.variables, variables)));\n    };\n    ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {\n        var last = this.last;\n        if (last &&\n            last[key] &&\n            (!variablesMustMatch || equal(last.variables, this.variables))) {\n            return last[key];\n        }\n    };\n    ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {\n        return this.getLast(\"result\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.getLastError = function (variablesMustMatch) {\n        return this.getLast(\"error\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.resetLastResults = function () {\n        delete this.last;\n        this.isTornDown = false;\n    };\n    ObservableQuery.prototype.resetQueryStoreErrors = function () {\n        this.queryManager.resetErrors(this.queryId);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results.\n     * This method should be preferred over `setVariables` in most use cases.\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    ObservableQuery.prototype.refetch = function (variables) {\n        var _a;\n        var reobserveOptions = {\n            // Always disable polling for refetches.\n            pollInterval: 0,\n        };\n        // Unless the provided fetchPolicy always consults the network\n        // (no-cache, network-only, or cache-and-network), override it with\n        // network-only to force the refetch for this fetchQuery call.\n        var fetchPolicy = this.options.fetchPolicy;\n        if (fetchPolicy === \"cache-and-network\") {\n            reobserveOptions.fetchPolicy = fetchPolicy;\n        }\n        else if (fetchPolicy === \"no-cache\") {\n            reobserveOptions.fetchPolicy = \"no-cache\";\n        }\n        else {\n            reobserveOptions.fetchPolicy = \"network-only\";\n        }\n        if (globalThis.__DEV__ !== false && variables && hasOwnProperty.call(variables, \"variables\")) {\n            var queryDef = getQueryDefinition(this.query);\n            var vars = queryDef.variableDefinitions;\n            if (!vars || !vars.some(function (v) { return v.variable.name.value === \"variables\"; })) {\n                globalThis.__DEV__ !== false && invariant.warn(\n                    20,\n                    variables,\n                    ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef\n                );\n            }\n        }\n        if (variables && !equal(this.options.variables, variables)) {\n            // Update the existing options with new variables\n            reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);\n        }\n        this.queryInfo.resetLastWrite();\n        return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n    };\n    /**\n     * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\n     */\n    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\n        var _this = this;\n        var combinedOptions = __assign(__assign({}, (fetchMoreOptions.query ? fetchMoreOptions : (__assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })))), { \n            // The fetchMore request goes immediately to the network and does\n            // not automatically write its result to the cache (hence no-cache\n            // instead of network-only), because we allow the caller of\n            // fetchMore to provide an updateQuery callback that determines how\n            // the data gets written to the cache.\n            fetchPolicy: \"no-cache\" });\n        combinedOptions.query = this.transformDocument(combinedOptions.query);\n        var qid = this.queryManager.generateQueryId();\n        // If a temporary query is passed to `fetchMore`, we don't want to store\n        // it as the last query result since it may be an optimized query for\n        // pagination. We will however run the transforms on the original document\n        // as well as the document passed in `fetchMoreOptions` to ensure the cache\n        // uses the most up-to-date document which may rely on runtime conditionals.\n        this.lastQuery =\n            fetchMoreOptions.query ?\n                this.transformDocument(this.options.query)\n                : combinedOptions.query;\n        // Simulate a loading result for the original query with\n        // result.networkStatus === NetworkStatus.fetchMore.\n        var queryInfo = this.queryInfo;\n        var originalNetworkStatus = queryInfo.networkStatus;\n        queryInfo.networkStatus = NetworkStatus.fetchMore;\n        if (combinedOptions.notifyOnNetworkStatusChange) {\n            this.observe();\n        }\n        var updatedQuerySet = new Set();\n        return this.queryManager\n            .fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore)\n            .then(function (fetchMoreResult) {\n            _this.queryManager.removeQuery(qid);\n            if (queryInfo.networkStatus === NetworkStatus.fetchMore) {\n                queryInfo.networkStatus = originalNetworkStatus;\n            }\n            // Performing this cache update inside a cache.batch transaction ensures\n            // any affected cache.watch watchers are notified at most once about any\n            // updates. Most watchers will be using the QueryInfo class, which\n            // responds to notifications by calling reobserveCacheFirst to deliver\n            // fetchMore cache results back to this ObservableQuery.\n            _this.queryManager.cache.batch({\n                update: function (cache) {\n                    var updateQuery = fetchMoreOptions.updateQuery;\n                    if (updateQuery) {\n                        cache.updateQuery({\n                            query: _this.query,\n                            variables: _this.variables,\n                            returnPartialData: true,\n                            optimistic: false,\n                        }, function (previous) {\n                            return updateQuery(previous, {\n                                fetchMoreResult: fetchMoreResult.data,\n                                variables: combinedOptions.variables,\n                            });\n                        });\n                    }\n                    else {\n                        // If we're using a field policy instead of updateQuery, the only\n                        // thing we need to do is write the new data to the cache using\n                        // combinedOptions.variables (instead of this.variables, which is\n                        // what this.updateQuery uses, because it works by abusing the\n                        // original field value, keyed by the original variables).\n                        cache.writeQuery({\n                            query: combinedOptions.query,\n                            variables: combinedOptions.variables,\n                            data: fetchMoreResult.data,\n                        });\n                    }\n                },\n                onWatchUpdated: function (watch) {\n                    // Record the DocumentNode associated with any watched query whose\n                    // data were updated by the cache writes above.\n                    updatedQuerySet.add(watch.query);\n                },\n            });\n            return fetchMoreResult;\n        })\n            .finally(function () {\n            // In case the cache writes above did not generate a broadcast\n            // notification (which would have been intercepted by onWatchUpdated),\n            // likely because the written data were the same as what was already in\n            // the cache, we still want fetchMore to deliver its final loading:false\n            // result with the unchanged data.\n            if (!updatedQuerySet.has(_this.query)) {\n                reobserveCacheFirst(_this);\n            }\n        });\n    };\n    // XXX the subscription variables are separate from the query variables.\n    // if you want to update subscription variables, right now you have to do that separately,\n    // and you can only do it by stopping the subscription and then subscribing again with new variables.\n    /**\n     * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\n     *\n     * This function returns _another_ function that you can call to terminate the subscription.\n     */\n    ObservableQuery.prototype.subscribeToMore = function (options) {\n        var _this = this;\n        var subscription = this.queryManager\n            .startGraphQLSubscription({\n            query: options.document,\n            variables: options.variables,\n            context: options.context,\n        })\n            .subscribe({\n            next: function (subscriptionData) {\n                var updateQuery = options.updateQuery;\n                if (updateQuery) {\n                    _this.updateQuery(function (previous, _a) {\n                        var variables = _a.variables;\n                        return updateQuery(previous, {\n                            subscriptionData: subscriptionData,\n                            variables: variables,\n                        });\n                    });\n                }\n            },\n            error: function (err) {\n                if (options.onError) {\n                    options.onError(err);\n                    return;\n                }\n                globalThis.__DEV__ !== false && invariant.error(21, err);\n            },\n        });\n        this.subscriptions.add(subscription);\n        return function () {\n            if (_this.subscriptions.delete(subscription)) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n    ObservableQuery.prototype.setOptions = function (newOptions) {\n        return this.reobserve(newOptions);\n    };\n    ObservableQuery.prototype.silentSetOptions = function (newOptions) {\n        var mergedOptions = compact(this.options, newOptions || {});\n        assign(this.options, mergedOptions);\n    };\n    /**\n     * Update the variables of this observable query, and fetch the new results\n     * if they've changed. Most users should prefer `refetch` instead of\n     * `setVariables` in order to to be properly notified of results even when\n     * they come from the cache.\n     *\n     * Note: the `next` callback will *not* fire if the variables have not changed\n     * or if the result is coming from cache.\n     *\n     * Note: the promise will return the old results immediately if the variables\n     * have not changed.\n     *\n     * Note: the promise will return null immediately if the query is not active\n     * (there are no subscribers).\n     *\n     * @param variables - The new set of variables. If there are missing variables,\n     * the previous values of those variables will be used.\n     */\n    ObservableQuery.prototype.setVariables = function (variables) {\n        if (equal(this.variables, variables)) {\n            // If we have no observers, then we don't actually want to make a network\n            // request. As soon as someone observes the query, the request will kick\n            // off. For now, we just store any changes. (See #1077)\n            return this.observers.size ? this.result() : Promise.resolve();\n        }\n        this.options.variables = variables;\n        // See comment above\n        if (!this.observers.size) {\n            return Promise.resolve();\n        }\n        return this.reobserve({\n            // Reset options.fetchPolicy to its original value.\n            fetchPolicy: this.options.initialFetchPolicy,\n            variables: variables,\n        }, NetworkStatus.setVariables);\n    };\n    /**\n     * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\n     *\n     * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\n     */\n    ObservableQuery.prototype.updateQuery = function (mapFn) {\n        var queryManager = this.queryManager;\n        var result = queryManager.cache.diff({\n            query: this.options.query,\n            variables: this.variables,\n            returnPartialData: true,\n            optimistic: false,\n        }).result;\n        var newResult = mapFn(result, {\n            variables: this.variables,\n        });\n        if (newResult) {\n            queryManager.cache.writeQuery({\n                query: this.options.query,\n                data: newResult,\n                variables: this.variables,\n            });\n            queryManager.broadcastQueries();\n        }\n    };\n    /**\n     * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\n     */\n    ObservableQuery.prototype.startPolling = function (pollInterval) {\n        this.options.pollInterval = pollInterval;\n        this.updatePolling();\n    };\n    /**\n     * A function that instructs the query to stop polling after a previous call to `startPolling`.\n     */\n    ObservableQuery.prototype.stopPolling = function () {\n        this.options.pollInterval = 0;\n        this.updatePolling();\n    };\n    // Update options.fetchPolicy according to options.nextFetchPolicy.\n    ObservableQuery.prototype.applyNextFetchPolicy = function (reason, \n    // It's possible to use this method to apply options.nextFetchPolicy to\n    // options.fetchPolicy even if options !== this.options, though that happens\n    // most often when the options are temporary, used for only one request and\n    // then thrown away, so nextFetchPolicy may not end up mattering.\n    options) {\n        if (options.nextFetchPolicy) {\n            var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;\n            if (fetchPolicy === \"standby\") {\n                // Do nothing, leaving options.fetchPolicy unchanged.\n            }\n            else if (typeof options.nextFetchPolicy === \"function\") {\n                // When someone chooses \"cache-and-network\" or \"network-only\" as their\n                // initial FetchPolicy, they often do not want future cache updates to\n                // trigger unconditional network requests, which is what repeatedly\n                // applying the \"cache-and-network\" or \"network-only\" policies would\n                // seem to imply. Instead, when the cache reports an update after the\n                // initial network request, it may be desirable for subsequent network\n                // requests to be triggered only if the cache result is incomplete. To\n                // that end, the options.nextFetchPolicy option provides an easy way to\n                // update options.fetchPolicy after the initial network request, without\n                // having to call observableQuery.setOptions.\n                options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n                    reason: reason,\n                    options: options,\n                    observable: this,\n                    initialFetchPolicy: initialFetchPolicy,\n                });\n            }\n            else if (reason === \"variables-changed\") {\n                options.fetchPolicy = initialFetchPolicy;\n            }\n            else {\n                options.fetchPolicy = options.nextFetchPolicy;\n            }\n        }\n        return options.fetchPolicy;\n    };\n    ObservableQuery.prototype.fetch = function (options, newNetworkStatus, query) {\n        // TODO Make sure we update the networkStatus (and infer fetchVariables)\n        // before actually committing to the fetch.\n        this.queryManager.setObservableQuery(this);\n        return this.queryManager[\"fetchConcastWithInfo\"](this.queryId, options, newNetworkStatus, query);\n    };\n    // Turns polling on or off based on this.options.pollInterval.\n    ObservableQuery.prototype.updatePolling = function () {\n        var _this = this;\n        // Avoid polling in SSR mode\n        if (this.queryManager.ssrMode) {\n            return;\n        }\n        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;\n        if (!pollInterval) {\n            if (pollingInfo) {\n                clearTimeout(pollingInfo.timeout);\n                delete this.pollingInfo;\n            }\n            return;\n        }\n        if (pollingInfo && pollingInfo.interval === pollInterval) {\n            return;\n        }\n        invariant(pollInterval, 22);\n        var info = pollingInfo || (this.pollingInfo = {});\n        info.interval = pollInterval;\n        var maybeFetch = function () {\n            var _a, _b;\n            if (_this.pollingInfo) {\n                if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) &&\n                    !((_b = (_a = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n                    _this.reobserve({\n                        // Most fetchPolicy options don't make sense to use in a polling context, as\n                        // users wouldn't want to be polling the cache directly. However, network-only and\n                        // no-cache are both useful for when the user wants to control whether or not the\n                        // polled results are written to the cache.\n                        fetchPolicy: _this.options.initialFetchPolicy === \"no-cache\" ?\n                            \"no-cache\"\n                            : \"network-only\",\n                    }, NetworkStatus.poll).then(poll, poll);\n                }\n                else {\n                    poll();\n                }\n            }\n        };\n        var poll = function () {\n            var info = _this.pollingInfo;\n            if (info) {\n                clearTimeout(info.timeout);\n                info.timeout = setTimeout(maybeFetch, info.interval);\n            }\n        };\n        poll();\n    };\n    ObservableQuery.prototype.updateLastResult = function (newResult, variables) {\n        if (variables === void 0) { variables = this.variables; }\n        var error = this.getLastError();\n        // Preserve this.last.error unless the variables have changed.\n        if (error && this.last && !equal(variables, this.last.variables)) {\n            error = void 0;\n        }\n        return (this.last = __assign({ result: this.queryManager.assumeImmutableResults ?\n                newResult\n                : cloneDeep(newResult), variables: variables }, (error ? { error: error } : null)));\n    };\n    ObservableQuery.prototype.reobserveAsConcast = function (newOptions, newNetworkStatus) {\n        var _this = this;\n        this.isTornDown = false;\n        var useDisposableConcast = \n        // Refetching uses a disposable Concast to allow refetches using different\n        // options/variables, without permanently altering the options of the\n        // original ObservableQuery.\n        newNetworkStatus === NetworkStatus.refetch ||\n            // The fetchMore method does not actually call the reobserve method, but,\n            // if it did, it would definitely use a disposable Concast.\n            newNetworkStatus === NetworkStatus.fetchMore ||\n            // Polling uses a disposable Concast so the polling options (which force\n            // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n            newNetworkStatus === NetworkStatus.poll;\n        // Save the old variables, since Object.assign may modify them below.\n        var oldVariables = this.options.variables;\n        var oldFetchPolicy = this.options.fetchPolicy;\n        var mergedOptions = compact(this.options, newOptions || {});\n        var options = useDisposableConcast ?\n            // Disposable Concast fetches receive a shallow copy of this.options\n            // (merged with newOptions), leaving this.options unmodified.\n            mergedOptions\n            : assign(this.options, mergedOptions);\n        // Don't update options.query with the transformed query to avoid\n        // overwriting this.options.query when we aren't using a disposable concast.\n        // We want to ensure we can re-run the custom document transforms the next\n        // time a request is made against the original query.\n        var query = this.transformDocument(options.query);\n        this.lastQuery = query;\n        if (!useDisposableConcast) {\n            // We can skip calling updatePolling if we're not changing this.options.\n            this.updatePolling();\n            // Reset options.fetchPolicy to its original value when variables change,\n            // unless a new fetchPolicy was provided by newOptions.\n            if (newOptions &&\n                newOptions.variables &&\n                !equal(newOptions.variables, oldVariables) &&\n                // Don't mess with the fetchPolicy if it's currently \"standby\".\n                options.fetchPolicy !== \"standby\" &&\n                // If we're changing the fetchPolicy anyway, don't try to change it here\n                // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n                options.fetchPolicy === oldFetchPolicy) {\n                this.applyNextFetchPolicy(\"variables-changed\", options);\n                if (newNetworkStatus === void 0) {\n                    newNetworkStatus = NetworkStatus.setVariables;\n                }\n            }\n        }\n        this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));\n        var finishWaitingForOwnResult = function () {\n            if (_this.concast === concast) {\n                _this.waitForOwnResult = false;\n            }\n        };\n        var variables = options.variables && __assign({}, options.variables);\n        var _a = this.fetch(options, newNetworkStatus, query), concast = _a.concast, fromLink = _a.fromLink;\n        var observer = {\n            next: function (result) {\n                if (equal(_this.variables, variables)) {\n                    finishWaitingForOwnResult();\n                    _this.reportResult(result, variables);\n                }\n            },\n            error: function (error) {\n                if (equal(_this.variables, variables)) {\n                    finishWaitingForOwnResult();\n                    _this.reportError(error, variables);\n                }\n            },\n        };\n        if (!useDisposableConcast && (fromLink || !this.concast)) {\n            // We use the {add,remove}Observer methods directly to avoid wrapping\n            // observer with an unnecessary SubscriptionObserver object.\n            if (this.concast && this.observer) {\n                this.concast.removeObserver(this.observer);\n            }\n            this.concast = concast;\n            this.observer = observer;\n        }\n        concast.addObserver(observer);\n        return concast;\n    };\n    ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {\n        return this.reobserveAsConcast(newOptions, newNetworkStatus)\n            .promise;\n    };\n    ObservableQuery.prototype.resubscribeAfterError = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // If `lastError` is set in the current when the subscription is re-created,\n        // the subscription will immediately receive the error, which will\n        // cause it to terminate again. To avoid this, we first clear\n        // the last error/result from the `observableQuery` before re-starting\n        // the subscription, and restore the last value afterwards so that the\n        // subscription has a chance to stay open.\n        var last = this.last;\n        this.resetLastResults();\n        var subscription = this.subscribe.apply(this, args);\n        this.last = last;\n        return subscription;\n    };\n    // (Re)deliver the current result to this.observers without applying fetch\n    // policies or making network requests.\n    ObservableQuery.prototype.observe = function () {\n        this.reportResult(\n        // Passing false is important so that this.getCurrentResult doesn't\n        // save the fetchMore result as this.lastResult, causing it to be\n        // ignored due to the this.isDifferentFromLastResult check in\n        // this.reportResult.\n        this.getCurrentResult(false), this.variables);\n    };\n    ObservableQuery.prototype.reportResult = function (result, variables) {\n        var lastError = this.getLastError();\n        var isDifferent = this.isDifferentFromLastResult(result, variables);\n        // Update the last result even when isDifferentFromLastResult returns false,\n        // because the query may be using the @nonreactive directive, and we want to\n        // save the the latest version of any nonreactive subtrees (in case\n        // getCurrentResult is called), even though we skip broadcasting changes.\n        if (lastError || !result.partial || this.options.returnPartialData) {\n            this.updateLastResult(result, variables);\n        }\n        if (lastError || isDifferent) {\n            iterateObserversSafely(this.observers, \"next\", result);\n        }\n    };\n    ObservableQuery.prototype.reportError = function (error, variables) {\n        // Since we don't get the current result on errors, only the error, we\n        // must mirror the updates that occur in QueryStore.markQueryError here\n        var errorResult = __assign(__assign({}, this.getLastResult()), { error: error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });\n        this.updateLastResult(errorResult, variables);\n        iterateObserversSafely(this.observers, \"error\", (this.last.error = error));\n    };\n    ObservableQuery.prototype.hasObservers = function () {\n        return this.observers.size > 0;\n    };\n    ObservableQuery.prototype.tearDownQuery = function () {\n        if (this.isTornDown)\n            return;\n        if (this.concast && this.observer) {\n            this.concast.removeObserver(this.observer);\n            delete this.concast;\n            delete this.observer;\n        }\n        this.stopPolling();\n        // stop all active GraphQL subscriptions\n        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });\n        this.subscriptions.clear();\n        this.queryManager.stopQuery(this.queryId);\n        this.observers.clear();\n        this.isTornDown = true;\n    };\n    ObservableQuery.prototype.transformDocument = function (document) {\n        return this.queryManager.transform(document);\n    };\n    return ObservableQuery;\n}(Observable));\nexport { ObservableQuery };\n// Necessary because the ObservableQuery constructor has a different\n// signature than the Observable constructor.\nfixObservableSubclass(ObservableQuery);\n// Reobserve with fetchPolicy effectively set to \"cache-first\", triggering\n// delivery of any new data from the cache, possibly falling back to the network\n// if any cache data are missing. This allows _complete_ cache results to be\n// delivered without also kicking off unnecessary network requests when\n// this.options.fetchPolicy is \"cache-and-network\" or \"network-only\". When\n// this.options.fetchPolicy is any other policy (\"cache-first\", \"cache-only\",\n// \"standby\", or \"no-cache\"), we call this.reobserve() as usual.\nexport function reobserveCacheFirst(obsQuery) {\n    var _a = obsQuery.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;\n    if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n        return obsQuery.reobserve({\n            fetchPolicy: \"cache-first\",\n            // Use a temporary nextFetchPolicy function that replaces itself with the\n            // previous nextFetchPolicy value and returns the original fetchPolicy.\n            nextFetchPolicy: function (currentFetchPolicy, context) {\n                // Replace this nextFetchPolicy function in the options object with the\n                // original this.options.nextFetchPolicy value.\n                this.nextFetchPolicy = nextFetchPolicy;\n                // If the original nextFetchPolicy value was a function, give it a\n                // chance to decide what happens here.\n                if (typeof this.nextFetchPolicy === \"function\") {\n                    return this.nextFetchPolicy(currentFetchPolicy, context);\n                }\n                // Otherwise go back to the original this.options.fetchPolicy.\n                return fetchPolicy;\n            },\n        });\n    }\n    return obsQuery.reobserve();\n}\nfunction defaultSubscriptionObserverErrorCallback(error) {\n    globalThis.__DEV__ !== false && invariant.error(23, error.message, error.stack);\n}\nexport function logMissingFieldErrors(missing) {\n    if (globalThis.__DEV__ !== false && missing) {\n        globalThis.__DEV__ !== false && invariant.debug(24, missing);\n    }\n}\nfunction skipCacheDataFor(fetchPolicy /* `undefined` would mean `\"cache-first\"` */) {\n    return (fetchPolicy === \"network-only\" ||\n        fetchPolicy === \"no-cache\" ||\n        fetchPolicy === \"standby\");\n}\n//# sourceMappingURL=ObservableQuery.js.map",
      "start": 1713304786571,
      "end": 1713304786698,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "graphql",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713304786698,
      "end": 1713304786698,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1713304786698,
      "end": 1713304786699,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { __assign, __extends } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { cloneDeep, compact, getOperationDefinition, Observable, iterateObserversSafely, fixObservableSubclass, getQueryDefinition } from \"../utilities/index.js\";\nimport { equalByQuery } from \"./equalByQuery.js\";\nvar assign = Object.assign, hasOwnProperty = Object.hasOwnProperty;\nvar ObservableQuery = (\n  /** @class */\n  function(_super) {\n    __extends(ObservableQuery2, _super);\n    function ObservableQuery2(_a) {\n      var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;\n      var _this = _super.call(this, function(observer) {\n        try {\n          var subObserver = observer._subscription._observer;\n          if (subObserver && !subObserver.error) {\n            subObserver.error = defaultSubscriptionObserverErrorCallback;\n          }\n        } catch (_a2) {\n        }\n        var first = !_this.observers.size;\n        _this.observers.add(observer);\n        var last = _this.last;\n        if (last && last.error) {\n          observer.error && observer.error(last.error);\n        } else if (last && last.result) {\n          observer.next && observer.next(last.result);\n        }\n        if (first) {\n          _this.reobserve().catch(function() {\n          });\n        }\n        return function() {\n          if (_this.observers.delete(observer) && !_this.observers.size) {\n            _this.tearDownQuery();\n          }\n        };\n      }) || this;\n      _this.observers = /* @__PURE__ */ new Set();\n      _this.subscriptions = /* @__PURE__ */ new Set();\n      _this.queryInfo = queryInfo;\n      _this.queryManager = queryManager;\n      _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\n      _this.isTornDown = false;\n      var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? \"cache-first\" : _d;\n      var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === \"standby\" ? defaultFetchPolicy : fetchPolicy : _f;\n      _this.options = __assign(__assign({}, options), {\n        // Remember the initial options.fetchPolicy so we can revert back to this\n        // policy when variables change. This information can also be specified\n        // (or overridden) by providing options.initialFetchPolicy explicitly.\n        initialFetchPolicy,\n        // This ensures this.options.fetchPolicy always has a string value, in\n        // case options.fetchPolicy was not provided.\n        fetchPolicy\n      });\n      _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n      var opDef = getOperationDefinition(_this.query);\n      _this.queryName = opDef && opDef.name && opDef.name.value;\n      return _this;\n    }\n    Object.defineProperty(ObservableQuery2.prototype, \"query\", {\n      // The `query` computed property will always reflect the document transformed\n      // by the last run query. `this.options.query` will always reflect the raw\n      // untransformed query to ensure document transforms with runtime conditionals\n      // are run on the original document.\n      get: function() {\n        return this.lastQuery || this.options.query;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(ObservableQuery2.prototype, \"variables\", {\n      // Computed shorthand for this.options.variables, preserved for\n      // backwards compatibility.\n      /**\n       * An object containing the variables that were provided for the query.\n       */\n      get: function() {\n        return this.options.variables;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    ObservableQuery2.prototype.result = function() {\n      var _this = this;\n      return new Promise(function(resolve, reject) {\n        var observer = {\n          next: function(result) {\n            resolve(result);\n            _this.observers.delete(observer);\n            if (!_this.observers.size) {\n              _this.queryManager.removeQuery(_this.queryId);\n            }\n            setTimeout(function() {\n              subscription.unsubscribe();\n            }, 0);\n          },\n          error: reject\n        };\n        var subscription = _this.subscribe(observer);\n      });\n    };\n    ObservableQuery2.prototype.resetDiff = function() {\n      this.queryInfo.resetDiff();\n    };\n    ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {\n      if (saveAsLastResult === void 0) {\n        saveAsLastResult = true;\n      }\n      var lastResult = this.getLastResult(true);\n      var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;\n      var result = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });\n      var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a;\n      if (\n        // These fetch policies should never deliver data from the cache, unless\n        // redelivering a previously delivered result.\n        skipCacheDataFor(fetchPolicy) || // If this.options.query has @client(always: true) fields, we cannot\n        // trust diff.result, since it was read from the cache without running\n        // local resolvers (and it's too late to run resolvers now, since we must\n        // return a result synchronously).\n        this.queryManager.getDocumentInfo(this.query).hasForcedResolvers\n      ) {\n      } else if (this.waitForOwnResult) {\n        this.queryInfo[\"updateWatch\"]();\n      } else {\n        var diff = this.queryInfo.getDiff();\n        if (diff.complete || this.options.returnPartialData) {\n          result.data = diff.result;\n        }\n        if (equal(result.data, {})) {\n          result.data = void 0;\n        }\n        if (diff.complete) {\n          delete result.partial;\n          if (diff.complete && result.networkStatus === NetworkStatus.loading && (fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-only\")) {\n            result.networkStatus = NetworkStatus.ready;\n            result.loading = false;\n          }\n        } else {\n          result.partial = true;\n        }\n        if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {\n          logMissingFieldErrors(diff.missing);\n        }\n      }\n      if (saveAsLastResult) {\n        this.updateLastResult(result);\n      }\n      return result;\n    };\n    ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {\n      if (!this.last) {\n        return true;\n      }\n      var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !equalByQuery(this.query, this.last.result, newResult, this.variables) : !equal(this.last.result, newResult);\n      return resultIsDifferent || variables && !equal(this.last.variables, variables);\n    };\n    ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {\n      var last = this.last;\n      if (last && last[key] && (!variablesMustMatch || equal(last.variables, this.variables))) {\n        return last[key];\n      }\n    };\n    ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {\n      return this.getLast(\"result\", variablesMustMatch);\n    };\n    ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {\n      return this.getLast(\"error\", variablesMustMatch);\n    };\n    ObservableQuery2.prototype.resetLastResults = function() {\n      delete this.last;\n      this.isTornDown = false;\n    };\n    ObservableQuery2.prototype.resetQueryStoreErrors = function() {\n      this.queryManager.resetErrors(this.queryId);\n    };\n    ObservableQuery2.prototype.refetch = function(variables) {\n      var _a;\n      var reobserveOptions = {\n        // Always disable polling for refetches.\n        pollInterval: 0\n      };\n      var fetchPolicy = this.options.fetchPolicy;\n      if (fetchPolicy === \"cache-and-network\") {\n        reobserveOptions.fetchPolicy = fetchPolicy;\n      } else if (fetchPolicy === \"no-cache\") {\n        reobserveOptions.fetchPolicy = \"no-cache\";\n      } else {\n        reobserveOptions.fetchPolicy = \"network-only\";\n      }\n      if (globalThis.__DEV__ !== false && variables && hasOwnProperty.call(variables, \"variables\")) {\n        var queryDef = getQueryDefinition(this.query);\n        var vars = queryDef.variableDefinitions;\n        if (!vars || !vars.some(function(v) {\n          return v.variable.name.value === \"variables\";\n        })) {\n          globalThis.__DEV__ !== false && invariant.warn(\n            20,\n            variables,\n            ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef\n          );\n        }\n      }\n      if (variables && !equal(this.options.variables, variables)) {\n        reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);\n      }\n      this.queryInfo.resetLastWrite();\n      return this.reobserve(reobserveOptions, NetworkStatus.refetch);\n    };\n    ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {\n      var _this = this;\n      var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })), {\n        // The fetchMore request goes immediately to the network and does\n        // not automatically write its result to the cache (hence no-cache\n        // instead of network-only), because we allow the caller of\n        // fetchMore to provide an updateQuery callback that determines how\n        // the data gets written to the cache.\n        fetchPolicy: \"no-cache\"\n      });\n      combinedOptions.query = this.transformDocument(combinedOptions.query);\n      var qid = this.queryManager.generateQueryId();\n      this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;\n      var queryInfo = this.queryInfo;\n      var originalNetworkStatus = queryInfo.networkStatus;\n      queryInfo.networkStatus = NetworkStatus.fetchMore;\n      if (combinedOptions.notifyOnNetworkStatusChange) {\n        this.observe();\n      }\n      var updatedQuerySet = /* @__PURE__ */ new Set();\n      return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {\n        _this.queryManager.removeQuery(qid);\n        if (queryInfo.networkStatus === NetworkStatus.fetchMore) {\n          queryInfo.networkStatus = originalNetworkStatus;\n        }\n        _this.queryManager.cache.batch({\n          update: function(cache) {\n            var updateQuery = fetchMoreOptions.updateQuery;\n            if (updateQuery) {\n              cache.updateQuery({\n                query: _this.query,\n                variables: _this.variables,\n                returnPartialData: true,\n                optimistic: false\n              }, function(previous) {\n                return updateQuery(previous, {\n                  fetchMoreResult: fetchMoreResult.data,\n                  variables: combinedOptions.variables\n                });\n              });\n            } else {\n              cache.writeQuery({\n                query: combinedOptions.query,\n                variables: combinedOptions.variables,\n                data: fetchMoreResult.data\n              });\n            }\n          },\n          onWatchUpdated: function(watch) {\n            updatedQuerySet.add(watch.query);\n          }\n        });\n        return fetchMoreResult;\n      }).finally(function() {\n        if (!updatedQuerySet.has(_this.query)) {\n          reobserveCacheFirst(_this);\n        }\n      });\n    };\n    ObservableQuery2.prototype.subscribeToMore = function(options) {\n      var _this = this;\n      var subscription = this.queryManager.startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n        context: options.context\n      }).subscribe({\n        next: function(subscriptionData) {\n          var updateQuery = options.updateQuery;\n          if (updateQuery) {\n            _this.updateQuery(function(previous, _a) {\n              var variables = _a.variables;\n              return updateQuery(previous, {\n                subscriptionData,\n                variables\n              });\n            });\n          }\n        },\n        error: function(err) {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          globalThis.__DEV__ !== false && invariant.error(21, err);\n        }\n      });\n      this.subscriptions.add(subscription);\n      return function() {\n        if (_this.subscriptions.delete(subscription)) {\n          subscription.unsubscribe();\n        }\n      };\n    };\n    ObservableQuery2.prototype.setOptions = function(newOptions) {\n      return this.reobserve(newOptions);\n    };\n    ObservableQuery2.prototype.silentSetOptions = function(newOptions) {\n      var mergedOptions = compact(this.options, newOptions || {});\n      assign(this.options, mergedOptions);\n    };\n    ObservableQuery2.prototype.setVariables = function(variables) {\n      if (equal(this.variables, variables)) {\n        return this.observers.size ? this.result() : Promise.resolve();\n      }\n      this.options.variables = variables;\n      if (!this.observers.size) {\n        return Promise.resolve();\n      }\n      return this.reobserve({\n        // Reset options.fetchPolicy to its original value.\n        fetchPolicy: this.options.initialFetchPolicy,\n        variables\n      }, NetworkStatus.setVariables);\n    };\n    ObservableQuery2.prototype.updateQuery = function(mapFn) {\n      var queryManager = this.queryManager;\n      var result = queryManager.cache.diff({\n        query: this.options.query,\n        variables: this.variables,\n        returnPartialData: true,\n        optimistic: false\n      }).result;\n      var newResult = mapFn(result, {\n        variables: this.variables\n      });\n      if (newResult) {\n        queryManager.cache.writeQuery({\n          query: this.options.query,\n          data: newResult,\n          variables: this.variables\n        });\n        queryManager.broadcastQueries();\n      }\n    };\n    ObservableQuery2.prototype.startPolling = function(pollInterval) {\n      this.options.pollInterval = pollInterval;\n      this.updatePolling();\n    };\n    ObservableQuery2.prototype.stopPolling = function() {\n      this.options.pollInterval = 0;\n      this.updatePolling();\n    };\n    ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {\n      if (options.nextFetchPolicy) {\n        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;\n        if (fetchPolicy === \"standby\") {\n        } else if (typeof options.nextFetchPolicy === \"function\") {\n          options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n            reason,\n            options,\n            observable: this,\n            initialFetchPolicy\n          });\n        } else if (reason === \"variables-changed\") {\n          options.fetchPolicy = initialFetchPolicy;\n        } else {\n          options.fetchPolicy = options.nextFetchPolicy;\n        }\n      }\n      return options.fetchPolicy;\n    };\n    ObservableQuery2.prototype.fetch = function(options, newNetworkStatus, query) {\n      this.queryManager.setObservableQuery(this);\n      return this.queryManager[\"fetchConcastWithInfo\"](this.queryId, options, newNetworkStatus, query);\n    };\n    ObservableQuery2.prototype.updatePolling = function() {\n      var _this = this;\n      if (this.queryManager.ssrMode) {\n        return;\n      }\n      var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;\n      if (!pollInterval) {\n        if (pollingInfo) {\n          clearTimeout(pollingInfo.timeout);\n          delete this.pollingInfo;\n        }\n        return;\n      }\n      if (pollingInfo && pollingInfo.interval === pollInterval) {\n        return;\n      }\n      invariant(pollInterval, 22);\n      var info = pollingInfo || (this.pollingInfo = {});\n      info.interval = pollInterval;\n      var maybeFetch = function() {\n        var _a2, _b;\n        if (_this.pollingInfo) {\n          if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) && !((_b = (_a2 = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a2))) {\n            _this.reobserve({\n              // Most fetchPolicy options don't make sense to use in a polling context, as\n              // users wouldn't want to be polling the cache directly. However, network-only and\n              // no-cache are both useful for when the user wants to control whether or not the\n              // polled results are written to the cache.\n              fetchPolicy: _this.options.initialFetchPolicy === \"no-cache\" ? \"no-cache\" : \"network-only\"\n            }, NetworkStatus.poll).then(poll, poll);\n          } else {\n            poll();\n          }\n        }\n      };\n      var poll = function() {\n        var info2 = _this.pollingInfo;\n        if (info2) {\n          clearTimeout(info2.timeout);\n          info2.timeout = setTimeout(maybeFetch, info2.interval);\n        }\n      };\n      poll();\n    };\n    ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {\n      if (variables === void 0) {\n        variables = this.variables;\n      }\n      var error = this.getLastError();\n      if (error && this.last && !equal(variables, this.last.variables)) {\n        error = void 0;\n      }\n      return this.last = __assign({ result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult), variables }, error ? { error } : null);\n    };\n    ObservableQuery2.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {\n      var _this = this;\n      this.isTornDown = false;\n      var useDisposableConcast = (\n        // Refetching uses a disposable Concast to allow refetches using different\n        // options/variables, without permanently altering the options of the\n        // original ObservableQuery.\n        newNetworkStatus === NetworkStatus.refetch || // The fetchMore method does not actually call the reobserve method, but,\n        // if it did, it would definitely use a disposable Concast.\n        newNetworkStatus === NetworkStatus.fetchMore || // Polling uses a disposable Concast so the polling options (which force\n        // fetchPolicy to be \"network-only\" or \"no-cache\") won't override the original options.\n        newNetworkStatus === NetworkStatus.poll\n      );\n      var oldVariables = this.options.variables;\n      var oldFetchPolicy = this.options.fetchPolicy;\n      var mergedOptions = compact(this.options, newOptions || {});\n      var options = useDisposableConcast ? (\n        // Disposable Concast fetches receive a shallow copy of this.options\n        // (merged with newOptions), leaving this.options unmodified.\n        mergedOptions\n      ) : assign(this.options, mergedOptions);\n      var query = this.transformDocument(options.query);\n      this.lastQuery = query;\n      if (!useDisposableConcast) {\n        this.updatePolling();\n        if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) && // Don't mess with the fetchPolicy if it's currently \"standby\".\n        options.fetchPolicy !== \"standby\" && // If we're changing the fetchPolicy anyway, don't try to change it here\n        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\n        options.fetchPolicy === oldFetchPolicy) {\n          this.applyNextFetchPolicy(\"variables-changed\", options);\n          if (newNetworkStatus === void 0) {\n            newNetworkStatus = NetworkStatus.setVariables;\n          }\n        }\n      }\n      this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));\n      var finishWaitingForOwnResult = function() {\n        if (_this.concast === concast) {\n          _this.waitForOwnResult = false;\n        }\n      };\n      var variables = options.variables && __assign({}, options.variables);\n      var _a = this.fetch(options, newNetworkStatus, query), concast = _a.concast, fromLink = _a.fromLink;\n      var observer = {\n        next: function(result) {\n          if (equal(_this.variables, variables)) {\n            finishWaitingForOwnResult();\n            _this.reportResult(result, variables);\n          }\n        },\n        error: function(error) {\n          if (equal(_this.variables, variables)) {\n            finishWaitingForOwnResult();\n            _this.reportError(error, variables);\n          }\n        }\n      };\n      if (!useDisposableConcast && (fromLink || !this.concast)) {\n        if (this.concast && this.observer) {\n          this.concast.removeObserver(this.observer);\n        }\n        this.concast = concast;\n        this.observer = observer;\n      }\n      concast.addObserver(observer);\n      return concast;\n    };\n    ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {\n      return this.reobserveAsConcast(newOptions, newNetworkStatus).promise;\n    };\n    ObservableQuery2.prototype.resubscribeAfterError = function() {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var last = this.last;\n      this.resetLastResults();\n      var subscription = this.subscribe.apply(this, args);\n      this.last = last;\n      return subscription;\n    };\n    ObservableQuery2.prototype.observe = function() {\n      this.reportResult(\n        // Passing false is important so that this.getCurrentResult doesn't\n        // save the fetchMore result as this.lastResult, causing it to be\n        // ignored due to the this.isDifferentFromLastResult check in\n        // this.reportResult.\n        this.getCurrentResult(false),\n        this.variables\n      );\n    };\n    ObservableQuery2.prototype.reportResult = function(result, variables) {\n      var lastError = this.getLastError();\n      var isDifferent = this.isDifferentFromLastResult(result, variables);\n      if (lastError || !result.partial || this.options.returnPartialData) {\n        this.updateLastResult(result, variables);\n      }\n      if (lastError || isDifferent) {\n        iterateObserversSafely(this.observers, \"next\", result);\n      }\n    };\n    ObservableQuery2.prototype.reportError = function(error, variables) {\n      var errorResult = __assign(__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });\n      this.updateLastResult(errorResult, variables);\n      iterateObserversSafely(this.observers, \"error\", this.last.error = error);\n    };\n    ObservableQuery2.prototype.hasObservers = function() {\n      return this.observers.size > 0;\n    };\n    ObservableQuery2.prototype.tearDownQuery = function() {\n      if (this.isTornDown)\n        return;\n      if (this.concast && this.observer) {\n        this.concast.removeObserver(this.observer);\n        delete this.concast;\n        delete this.observer;\n      }\n      this.stopPolling();\n      this.subscriptions.forEach(function(sub) {\n        return sub.unsubscribe();\n      });\n      this.subscriptions.clear();\n      this.queryManager.stopQuery(this.queryId);\n      this.observers.clear();\n      this.isTornDown = true;\n    };\n    ObservableQuery2.prototype.transformDocument = function(document) {\n      return this.queryManager.transform(document);\n    };\n    return ObservableQuery2;\n  }(Observable)\n);\nexport { ObservableQuery };\nfixObservableSubclass(ObservableQuery);\nexport function reobserveCacheFirst(obsQuery) {\n  var _a = obsQuery.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;\n  if (fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\") {\n    return obsQuery.reobserve({\n      fetchPolicy: \"cache-first\",\n      // Use a temporary nextFetchPolicy function that replaces itself with the\n      // previous nextFetchPolicy value and returns the original fetchPolicy.\n      nextFetchPolicy: function(currentFetchPolicy, context) {\n        this.nextFetchPolicy = nextFetchPolicy;\n        if (typeof this.nextFetchPolicy === \"function\") {\n          return this.nextFetchPolicy(currentFetchPolicy, context);\n        }\n        return fetchPolicy;\n      }\n    });\n  }\n  return obsQuery.reobserve();\n}\nfunction defaultSubscriptionObserverErrorCallback(error) {\n  globalThis.__DEV__ !== false && invariant.error(23, error.message, error.stack);\n}\nexport function logMissingFieldErrors(missing) {\n  if (globalThis.__DEV__ !== false && missing) {\n    globalThis.__DEV__ !== false && invariant.debug(24, missing);\n  }\n}\nfunction skipCacheDataFor(fetchPolicy) {\n  return fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\" || fetchPolicy === \"standby\";\n}\n",
      "start": 1713304786699,
      "end": 1713304787096,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/core/ObservableQuery.js\"],\n  \"sourcesContent\": [\"import { __assign, __extends } from \\\"tslib\\\";\\nimport { invariant } from \\\"../utilities/globals/index.js\\\";\\nimport { equal } from \\\"@wry/equality\\\";\\nimport { NetworkStatus, isNetworkRequestInFlight } from \\\"./networkStatus.js\\\";\\nimport { cloneDeep, compact, getOperationDefinition, Observable, iterateObserversSafely, fixObservableSubclass, getQueryDefinition, } from \\\"../utilities/index.js\\\";\\nimport { equalByQuery } from \\\"./equalByQuery.js\\\";\\nvar assign = Object.assign, hasOwnProperty = Object.hasOwnProperty;\\nvar ObservableQuery = /** @class */ (function (_super) {\\n    __extends(ObservableQuery, _super);\\n    function ObservableQuery(_a) {\\n        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;\\n        var _this = _super.call(this, function (observer) {\\n            // Zen Observable has its own error function, so in order to log correctly\\n            // we need to provide a custom error callback.\\n            try {\\n                var subObserver = observer._subscription._observer;\\n                if (subObserver && !subObserver.error) {\\n                    subObserver.error = defaultSubscriptionObserverErrorCallback;\\n                }\\n            }\\n            catch (_a) { }\\n            var first = !_this.observers.size;\\n            _this.observers.add(observer);\\n            // Deliver most recent error or result.\\n            var last = _this.last;\\n            if (last && last.error) {\\n                observer.error && observer.error(last.error);\\n            }\\n            else if (last && last.result) {\\n                observer.next && observer.next(last.result);\\n            }\\n            // Initiate observation of this query if it hasn't been reported to\\n            // the QueryManager yet.\\n            if (first) {\\n                // Blindly catching here prevents unhandled promise rejections,\\n                // and is safe because the ObservableQuery handles this error with\\n                // this.observer.error, so we're not just swallowing the error by\\n                // ignoring it here.\\n                _this.reobserve().catch(function () { });\\n            }\\n            return function () {\\n                if (_this.observers.delete(observer) && !_this.observers.size) {\\n                    _this.tearDownQuery();\\n                }\\n            };\\n        }) || this;\\n        _this.observers = new Set();\\n        _this.subscriptions = new Set();\\n        // related classes\\n        _this.queryInfo = queryInfo;\\n        _this.queryManager = queryManager;\\n        // active state\\n        _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);\\n        _this.isTornDown = false;\\n        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? \\\"cache-first\\\" : _d;\\n        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, \\n        // Make sure we don't store \\\"standby\\\" as the initialFetchPolicy.\\n        _f = options.initialFetchPolicy, \\n        // Make sure we don't store \\\"standby\\\" as the initialFetchPolicy.\\n        initialFetchPolicy = _f === void 0 ? fetchPolicy === \\\"standby\\\" ? defaultFetchPolicy : (fetchPolicy) : _f;\\n        _this.options = __assign(__assign({}, options), { \\n            // Remember the initial options.fetchPolicy so we can revert back to this\\n            // policy when variables change. This information can also be specified\\n            // (or overridden) by providing options.initialFetchPolicy explicitly.\\n            initialFetchPolicy: initialFetchPolicy, \\n            // This ensures this.options.fetchPolicy always has a string value, in\\n            // case options.fetchPolicy was not provided.\\n            fetchPolicy: fetchPolicy });\\n        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\\n        var opDef = getOperationDefinition(_this.query);\\n        _this.queryName = opDef && opDef.name && opDef.name.value;\\n        return _this;\\n    }\\n    Object.defineProperty(ObservableQuery.prototype, \\\"query\\\", {\\n        // The `query` computed property will always reflect the document transformed\\n        // by the last run query. `this.options.query` will always reflect the raw\\n        // untransformed query to ensure document transforms with runtime conditionals\\n        // are run on the original document.\\n        get: function () {\\n            return this.lastQuery || this.options.query;\\n        },\\n        enumerable: false,\\n        configurable: true\\n    });\\n    Object.defineProperty(ObservableQuery.prototype, \\\"variables\\\", {\\n        // Computed shorthand for this.options.variables, preserved for\\n        // backwards compatibility.\\n        /**\\n         * An object containing the variables that were provided for the query.\\n         */\\n        get: function () {\\n            return this.options.variables;\\n        },\\n        enumerable: false,\\n        configurable: true\\n    });\\n    ObservableQuery.prototype.result = function () {\\n        var _this = this;\\n        return new Promise(function (resolve, reject) {\\n            // TODO: this code doesnâ€™t actually make sense insofar as the observer\\n            // will never exist in this.observers due how zen-observable wraps observables.\\n            // https://github.com/zenparsing/zen-observable/blob/master/src/Observable.js#L169\\n            var observer = {\\n                next: function (result) {\\n                    resolve(result);\\n                    // Stop the query within the QueryManager if we can before\\n                    // this function returns.\\n                    //\\n                    // We do this in order to prevent observers piling up within\\n                    // the QueryManager. Notice that we only fully unsubscribe\\n                    // from the subscription in a setTimeout(..., 0)  call. This call can\\n                    // actually be handled by the browser at a much later time. If queries\\n                    // are fired in the meantime, observers that should have been removed\\n                    // from the QueryManager will continue to fire, causing an unnecessary\\n                    // performance hit.\\n                    _this.observers.delete(observer);\\n                    if (!_this.observers.size) {\\n                        _this.queryManager.removeQuery(_this.queryId);\\n                    }\\n                    setTimeout(function () {\\n                        subscription.unsubscribe();\\n                    }, 0);\\n                },\\n                error: reject,\\n            };\\n            var subscription = _this.subscribe(observer);\\n        });\\n    };\\n    /** @internal */\\n    ObservableQuery.prototype.resetDiff = function () {\\n        this.queryInfo.resetDiff();\\n    };\\n    ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {\\n        if (saveAsLastResult === void 0) { saveAsLastResult = true; }\\n        // Use the last result as long as the variables match this.variables.\\n        var lastResult = this.getLastResult(true);\\n        var networkStatus = this.queryInfo.networkStatus ||\\n            (lastResult && lastResult.networkStatus) ||\\n            NetworkStatus.ready;\\n        var result = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus });\\n        var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? \\\"cache-first\\\" : _a;\\n        if (\\n        // These fetch policies should never deliver data from the cache, unless\\n        // redelivering a previously delivered result.\\n        skipCacheDataFor(fetchPolicy) ||\\n            // If this.options.query has @client(always: true) fields, we cannot\\n            // trust diff.result, since it was read from the cache without running\\n            // local resolvers (and it's too late to run resolvers now, since we must\\n            // return a result synchronously).\\n            this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) {\\n            // Fall through.\\n        }\\n        else if (this.waitForOwnResult) {\\n            // This would usually be a part of `QueryInfo.getDiff()`.\\n            // which we skip in the waitForOwnResult case since we are not\\n            // interested in the diff.\\n            this.queryInfo[\\\"updateWatch\\\"]();\\n        }\\n        else {\\n            var diff = this.queryInfo.getDiff();\\n            if (diff.complete || this.options.returnPartialData) {\\n                result.data = diff.result;\\n            }\\n            if (equal(result.data, {})) {\\n                result.data = void 0;\\n            }\\n            if (diff.complete) {\\n                // Similar to setting result.partial to false, but taking advantage of the\\n                // falsiness of missing fields.\\n                delete result.partial;\\n                // If the diff is complete, and we're using a FetchPolicy that\\n                // terminates after a complete cache read, we can assume the next result\\n                // we receive will have NetworkStatus.ready and !loading.\\n                if (diff.complete &&\\n                    result.networkStatus === NetworkStatus.loading &&\\n                    (fetchPolicy === \\\"cache-first\\\" || fetchPolicy === \\\"cache-only\\\")) {\\n                    result.networkStatus = NetworkStatus.ready;\\n                    result.loading = false;\\n                }\\n            }\\n            else {\\n                result.partial = true;\\n            }\\n            if (globalThis.__DEV__ !== false &&\\n                !diff.complete &&\\n                !this.options.partialRefetch &&\\n                !result.loading &&\\n                !result.data &&\\n                !result.error) {\\n                logMissingFieldErrors(diff.missing);\\n            }\\n        }\\n        if (saveAsLastResult) {\\n            this.updateLastResult(result);\\n        }\\n        return result;\\n    };\\n    // Compares newResult to the snapshot we took of this.lastResult when it was\\n    // first received.\\n    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult, variables) {\\n        if (!this.last) {\\n            return true;\\n        }\\n        var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ?\\n            !equalByQuery(this.query, this.last.result, newResult, this.variables)\\n            : !equal(this.last.result, newResult);\\n        return (resultIsDifferent || (variables && !equal(this.last.variables, variables)));\\n    };\\n    ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {\\n        var last = this.last;\\n        if (last &&\\n            last[key] &&\\n            (!variablesMustMatch || equal(last.variables, this.variables))) {\\n            return last[key];\\n        }\\n    };\\n    ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {\\n        return this.getLast(\\\"result\\\", variablesMustMatch);\\n    };\\n    ObservableQuery.prototype.getLastError = function (variablesMustMatch) {\\n        return this.getLast(\\\"error\\\", variablesMustMatch);\\n    };\\n    ObservableQuery.prototype.resetLastResults = function () {\\n        delete this.last;\\n        this.isTornDown = false;\\n    };\\n    ObservableQuery.prototype.resetQueryStoreErrors = function () {\\n        this.queryManager.resetErrors(this.queryId);\\n    };\\n    /**\\n     * Update the variables of this observable query, and fetch the new results.\\n     * This method should be preferred over `setVariables` in most use cases.\\n     *\\n     * @param variables - The new set of variables. If there are missing variables,\\n     * the previous values of those variables will be used.\\n     */\\n    ObservableQuery.prototype.refetch = function (variables) {\\n        var _a;\\n        var reobserveOptions = {\\n            // Always disable polling for refetches.\\n            pollInterval: 0,\\n        };\\n        // Unless the provided fetchPolicy always consults the network\\n        // (no-cache, network-only, or cache-and-network), override it with\\n        // network-only to force the refetch for this fetchQuery call.\\n        var fetchPolicy = this.options.fetchPolicy;\\n        if (fetchPolicy === \\\"cache-and-network\\\") {\\n            reobserveOptions.fetchPolicy = fetchPolicy;\\n        }\\n        else if (fetchPolicy === \\\"no-cache\\\") {\\n            reobserveOptions.fetchPolicy = \\\"no-cache\\\";\\n        }\\n        else {\\n            reobserveOptions.fetchPolicy = \\\"network-only\\\";\\n        }\\n        if (globalThis.__DEV__ !== false && variables && hasOwnProperty.call(variables, \\\"variables\\\")) {\\n            var queryDef = getQueryDefinition(this.query);\\n            var vars = queryDef.variableDefinitions;\\n            if (!vars || !vars.some(function (v) { return v.variable.name.value === \\\"variables\\\"; })) {\\n                globalThis.__DEV__ !== false && invariant.warn(\\n                    20,\\n                    variables,\\n                    ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef\\n                );\\n            }\\n        }\\n        if (variables && !equal(this.options.variables, variables)) {\\n            // Update the existing options with new variables\\n            reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);\\n        }\\n        this.queryInfo.resetLastWrite();\\n        return this.reobserve(reobserveOptions, NetworkStatus.refetch);\\n    };\\n    /**\\n     * A function that helps you fetch the next set of results for a [paginated list field](https://www.apollographql.com/docs/react/pagination/core-api/).\\n     */\\n    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\\n        var _this = this;\\n        var combinedOptions = __assign(__assign({}, (fetchMoreOptions.query ? fetchMoreOptions : (__assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })))), { \\n            // The fetchMore request goes immediately to the network and does\\n            // not automatically write its result to the cache (hence no-cache\\n            // instead of network-only), because we allow the caller of\\n            // fetchMore to provide an updateQuery callback that determines how\\n            // the data gets written to the cache.\\n            fetchPolicy: \\\"no-cache\\\" });\\n        combinedOptions.query = this.transformDocument(combinedOptions.query);\\n        var qid = this.queryManager.generateQueryId();\\n        // If a temporary query is passed to `fetchMore`, we don't want to store\\n        // it as the last query result since it may be an optimized query for\\n        // pagination. We will however run the transforms on the original document\\n        // as well as the document passed in `fetchMoreOptions` to ensure the cache\\n        // uses the most up-to-date document which may rely on runtime conditionals.\\n        this.lastQuery =\\n            fetchMoreOptions.query ?\\n                this.transformDocument(this.options.query)\\n                : combinedOptions.query;\\n        // Simulate a loading result for the original query with\\n        // result.networkStatus === NetworkStatus.fetchMore.\\n        var queryInfo = this.queryInfo;\\n        var originalNetworkStatus = queryInfo.networkStatus;\\n        queryInfo.networkStatus = NetworkStatus.fetchMore;\\n        if (combinedOptions.notifyOnNetworkStatusChange) {\\n            this.observe();\\n        }\\n        var updatedQuerySet = new Set();\\n        return this.queryManager\\n            .fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore)\\n            .then(function (fetchMoreResult) {\\n            _this.queryManager.removeQuery(qid);\\n            if (queryInfo.networkStatus === NetworkStatus.fetchMore) {\\n                queryInfo.networkStatus = originalNetworkStatus;\\n            }\\n            // Performing this cache update inside a cache.batch transaction ensures\\n            // any affected cache.watch watchers are notified at most once about any\\n            // updates. Most watchers will be using the QueryInfo class, which\\n            // responds to notifications by calling reobserveCacheFirst to deliver\\n            // fetchMore cache results back to this ObservableQuery.\\n            _this.queryManager.cache.batch({\\n                update: function (cache) {\\n                    var updateQuery = fetchMoreOptions.updateQuery;\\n                    if (updateQuery) {\\n                        cache.updateQuery({\\n                            query: _this.query,\\n                            variables: _this.variables,\\n                            returnPartialData: true,\\n                            optimistic: false,\\n                        }, function (previous) {\\n                            return updateQuery(previous, {\\n                                fetchMoreResult: fetchMoreResult.data,\\n                                variables: combinedOptions.variables,\\n                            });\\n                        });\\n                    }\\n                    else {\\n                        // If we're using a field policy instead of updateQuery, the only\\n                        // thing we need to do is write the new data to the cache using\\n                        // combinedOptions.variables (instead of this.variables, which is\\n                        // what this.updateQuery uses, because it works by abusing the\\n                        // original field value, keyed by the original variables).\\n                        cache.writeQuery({\\n                            query: combinedOptions.query,\\n                            variables: combinedOptions.variables,\\n                            data: fetchMoreResult.data,\\n                        });\\n                    }\\n                },\\n                onWatchUpdated: function (watch) {\\n                    // Record the DocumentNode associated with any watched query whose\\n                    // data were updated by the cache writes above.\\n                    updatedQuerySet.add(watch.query);\\n                },\\n            });\\n            return fetchMoreResult;\\n        })\\n            .finally(function () {\\n            // In case the cache writes above did not generate a broadcast\\n            // notification (which would have been intercepted by onWatchUpdated),\\n            // likely because the written data were the same as what was already in\\n            // the cache, we still want fetchMore to deliver its final loading:false\\n            // result with the unchanged data.\\n            if (!updatedQuerySet.has(_this.query)) {\\n                reobserveCacheFirst(_this);\\n            }\\n        });\\n    };\\n    // XXX the subscription variables are separate from the query variables.\\n    // if you want to update subscription variables, right now you have to do that separately,\\n    // and you can only do it by stopping the subscription and then subscribing again with new variables.\\n    /**\\n     * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.\\n     *\\n     * This function returns _another_ function that you can call to terminate the subscription.\\n     */\\n    ObservableQuery.prototype.subscribeToMore = function (options) {\\n        var _this = this;\\n        var subscription = this.queryManager\\n            .startGraphQLSubscription({\\n            query: options.document,\\n            variables: options.variables,\\n            context: options.context,\\n        })\\n            .subscribe({\\n            next: function (subscriptionData) {\\n                var updateQuery = options.updateQuery;\\n                if (updateQuery) {\\n                    _this.updateQuery(function (previous, _a) {\\n                        var variables = _a.variables;\\n                        return updateQuery(previous, {\\n                            subscriptionData: subscriptionData,\\n                            variables: variables,\\n                        });\\n                    });\\n                }\\n            },\\n            error: function (err) {\\n                if (options.onError) {\\n                    options.onError(err);\\n                    return;\\n                }\\n                globalThis.__DEV__ !== false && invariant.error(21, err);\\n            },\\n        });\\n        this.subscriptions.add(subscription);\\n        return function () {\\n            if (_this.subscriptions.delete(subscription)) {\\n                subscription.unsubscribe();\\n            }\\n        };\\n    };\\n    ObservableQuery.prototype.setOptions = function (newOptions) {\\n        return this.reobserve(newOptions);\\n    };\\n    ObservableQuery.prototype.silentSetOptions = function (newOptions) {\\n        var mergedOptions = compact(this.options, newOptions || {});\\n        assign(this.options, mergedOptions);\\n    };\\n    /**\\n     * Update the variables of this observable query, and fetch the new results\\n     * if they've changed. Most users should prefer `refetch` instead of\\n     * `setVariables` in order to to be properly notified of results even when\\n     * they come from the cache.\\n     *\\n     * Note: the `next` callback will *not* fire if the variables have not changed\\n     * or if the result is coming from cache.\\n     *\\n     * Note: the promise will return the old results immediately if the variables\\n     * have not changed.\\n     *\\n     * Note: the promise will return null immediately if the query is not active\\n     * (there are no subscribers).\\n     *\\n     * @param variables - The new set of variables. If there are missing variables,\\n     * the previous values of those variables will be used.\\n     */\\n    ObservableQuery.prototype.setVariables = function (variables) {\\n        if (equal(this.variables, variables)) {\\n            // If we have no observers, then we don't actually want to make a network\\n            // request. As soon as someone observes the query, the request will kick\\n            // off. For now, we just store any changes. (See #1077)\\n            return this.observers.size ? this.result() : Promise.resolve();\\n        }\\n        this.options.variables = variables;\\n        // See comment above\\n        if (!this.observers.size) {\\n            return Promise.resolve();\\n        }\\n        return this.reobserve({\\n            // Reset options.fetchPolicy to its original value.\\n            fetchPolicy: this.options.initialFetchPolicy,\\n            variables: variables,\\n        }, NetworkStatus.setVariables);\\n    };\\n    /**\\n     * A function that enables you to update the query's cached result without executing a followup GraphQL operation.\\n     *\\n     * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.\\n     */\\n    ObservableQuery.prototype.updateQuery = function (mapFn) {\\n        var queryManager = this.queryManager;\\n        var result = queryManager.cache.diff({\\n            query: this.options.query,\\n            variables: this.variables,\\n            returnPartialData: true,\\n            optimistic: false,\\n        }).result;\\n        var newResult = mapFn(result, {\\n            variables: this.variables,\\n        });\\n        if (newResult) {\\n            queryManager.cache.writeQuery({\\n                query: this.options.query,\\n                data: newResult,\\n                variables: this.variables,\\n            });\\n            queryManager.broadcastQueries();\\n        }\\n    };\\n    /**\\n     * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).\\n     */\\n    ObservableQuery.prototype.startPolling = function (pollInterval) {\\n        this.options.pollInterval = pollInterval;\\n        this.updatePolling();\\n    };\\n    /**\\n     * A function that instructs the query to stop polling after a previous call to `startPolling`.\\n     */\\n    ObservableQuery.prototype.stopPolling = function () {\\n        this.options.pollInterval = 0;\\n        this.updatePolling();\\n    };\\n    // Update options.fetchPolicy according to options.nextFetchPolicy.\\n    ObservableQuery.prototype.applyNextFetchPolicy = function (reason, \\n    // It's possible to use this method to apply options.nextFetchPolicy to\\n    // options.fetchPolicy even if options !== this.options, though that happens\\n    // most often when the options are temporary, used for only one request and\\n    // then thrown away, so nextFetchPolicy may not end up mattering.\\n    options) {\\n        if (options.nextFetchPolicy) {\\n            var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? \\\"cache-first\\\" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;\\n            if (fetchPolicy === \\\"standby\\\") {\\n                // Do nothing, leaving options.fetchPolicy unchanged.\\n            }\\n            else if (typeof options.nextFetchPolicy === \\\"function\\\") {\\n                // When someone chooses \\\"cache-and-network\\\" or \\\"network-only\\\" as their\\n                // initial FetchPolicy, they often do not want future cache updates to\\n                // trigger unconditional network requests, which is what repeatedly\\n                // applying the \\\"cache-and-network\\\" or \\\"network-only\\\" policies would\\n                // seem to imply. Instead, when the cache reports an update after the\\n                // initial network request, it may be desirable for subsequent network\\n                // requests to be triggered only if the cache result is incomplete. To\\n                // that end, the options.nextFetchPolicy option provides an easy way to\\n                // update options.fetchPolicy after the initial network request, without\\n                // having to call observableQuery.setOptions.\\n                options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\\n                    reason: reason,\\n                    options: options,\\n                    observable: this,\\n                    initialFetchPolicy: initialFetchPolicy,\\n                });\\n            }\\n            else if (reason === \\\"variables-changed\\\") {\\n                options.fetchPolicy = initialFetchPolicy;\\n            }\\n            else {\\n                options.fetchPolicy = options.nextFetchPolicy;\\n            }\\n        }\\n        return options.fetchPolicy;\\n    };\\n    ObservableQuery.prototype.fetch = function (options, newNetworkStatus, query) {\\n        // TODO Make sure we update the networkStatus (and infer fetchVariables)\\n        // before actually committing to the fetch.\\n        this.queryManager.setObservableQuery(this);\\n        return this.queryManager[\\\"fetchConcastWithInfo\\\"](this.queryId, options, newNetworkStatus, query);\\n    };\\n    // Turns polling on or off based on this.options.pollInterval.\\n    ObservableQuery.prototype.updatePolling = function () {\\n        var _this = this;\\n        // Avoid polling in SSR mode\\n        if (this.queryManager.ssrMode) {\\n            return;\\n        }\\n        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;\\n        if (!pollInterval) {\\n            if (pollingInfo) {\\n                clearTimeout(pollingInfo.timeout);\\n                delete this.pollingInfo;\\n            }\\n            return;\\n        }\\n        if (pollingInfo && pollingInfo.interval === pollInterval) {\\n            return;\\n        }\\n        invariant(pollInterval, 22);\\n        var info = pollingInfo || (this.pollingInfo = {});\\n        info.interval = pollInterval;\\n        var maybeFetch = function () {\\n            var _a, _b;\\n            if (_this.pollingInfo) {\\n                if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) &&\\n                    !((_b = (_a = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a))) {\\n                    _this.reobserve({\\n                        // Most fetchPolicy options don't make sense to use in a polling context, as\\n                        // users wouldn't want to be polling the cache directly. However, network-only and\\n                        // no-cache are both useful for when the user wants to control whether or not the\\n                        // polled results are written to the cache.\\n                        fetchPolicy: _this.options.initialFetchPolicy === \\\"no-cache\\\" ?\\n                            \\\"no-cache\\\"\\n                            : \\\"network-only\\\",\\n                    }, NetworkStatus.poll).then(poll, poll);\\n                }\\n                else {\\n                    poll();\\n                }\\n            }\\n        };\\n        var poll = function () {\\n            var info = _this.pollingInfo;\\n            if (info) {\\n                clearTimeout(info.timeout);\\n                info.timeout = setTimeout(maybeFetch, info.interval);\\n            }\\n        };\\n        poll();\\n    };\\n    ObservableQuery.prototype.updateLastResult = function (newResult, variables) {\\n        if (variables === void 0) { variables = this.variables; }\\n        var error = this.getLastError();\\n        // Preserve this.last.error unless the variables have changed.\\n        if (error && this.last && !equal(variables, this.last.variables)) {\\n            error = void 0;\\n        }\\n        return (this.last = __assign({ result: this.queryManager.assumeImmutableResults ?\\n                newResult\\n                : cloneDeep(newResult), variables: variables }, (error ? { error: error } : null)));\\n    };\\n    ObservableQuery.prototype.reobserveAsConcast = function (newOptions, newNetworkStatus) {\\n        var _this = this;\\n        this.isTornDown = false;\\n        var useDisposableConcast = \\n        // Refetching uses a disposable Concast to allow refetches using different\\n        // options/variables, without permanently altering the options of the\\n        // original ObservableQuery.\\n        newNetworkStatus === NetworkStatus.refetch ||\\n            // The fetchMore method does not actually call the reobserve method, but,\\n            // if it did, it would definitely use a disposable Concast.\\n            newNetworkStatus === NetworkStatus.fetchMore ||\\n            // Polling uses a disposable Concast so the polling options (which force\\n            // fetchPolicy to be \\\"network-only\\\" or \\\"no-cache\\\") won't override the original options.\\n            newNetworkStatus === NetworkStatus.poll;\\n        // Save the old variables, since Object.assign may modify them below.\\n        var oldVariables = this.options.variables;\\n        var oldFetchPolicy = this.options.fetchPolicy;\\n        var mergedOptions = compact(this.options, newOptions || {});\\n        var options = useDisposableConcast ?\\n            // Disposable Concast fetches receive a shallow copy of this.options\\n            // (merged with newOptions), leaving this.options unmodified.\\n            mergedOptions\\n            : assign(this.options, mergedOptions);\\n        // Don't update options.query with the transformed query to avoid\\n        // overwriting this.options.query when we aren't using a disposable concast.\\n        // We want to ensure we can re-run the custom document transforms the next\\n        // time a request is made against the original query.\\n        var query = this.transformDocument(options.query);\\n        this.lastQuery = query;\\n        if (!useDisposableConcast) {\\n            // We can skip calling updatePolling if we're not changing this.options.\\n            this.updatePolling();\\n            // Reset options.fetchPolicy to its original value when variables change,\\n            // unless a new fetchPolicy was provided by newOptions.\\n            if (newOptions &&\\n                newOptions.variables &&\\n                !equal(newOptions.variables, oldVariables) &&\\n                // Don't mess with the fetchPolicy if it's currently \\\"standby\\\".\\n                options.fetchPolicy !== \\\"standby\\\" &&\\n                // If we're changing the fetchPolicy anyway, don't try to change it here\\n                // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.\\n                options.fetchPolicy === oldFetchPolicy) {\\n                this.applyNextFetchPolicy(\\\"variables-changed\\\", options);\\n                if (newNetworkStatus === void 0) {\\n                    newNetworkStatus = NetworkStatus.setVariables;\\n                }\\n            }\\n        }\\n        this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));\\n        var finishWaitingForOwnResult = function () {\\n            if (_this.concast === concast) {\\n                _this.waitForOwnResult = false;\\n            }\\n        };\\n        var variables = options.variables && __assign({}, options.variables);\\n        var _a = this.fetch(options, newNetworkStatus, query), concast = _a.concast, fromLink = _a.fromLink;\\n        var observer = {\\n            next: function (result) {\\n                if (equal(_this.variables, variables)) {\\n                    finishWaitingForOwnResult();\\n                    _this.reportResult(result, variables);\\n                }\\n            },\\n            error: function (error) {\\n                if (equal(_this.variables, variables)) {\\n                    finishWaitingForOwnResult();\\n                    _this.reportError(error, variables);\\n                }\\n            },\\n        };\\n        if (!useDisposableConcast && (fromLink || !this.concast)) {\\n            // We use the {add,remove}Observer methods directly to avoid wrapping\\n            // observer with an unnecessary SubscriptionObserver object.\\n            if (this.concast && this.observer) {\\n                this.concast.removeObserver(this.observer);\\n            }\\n            this.concast = concast;\\n            this.observer = observer;\\n        }\\n        concast.addObserver(observer);\\n        return concast;\\n    };\\n    ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {\\n        return this.reobserveAsConcast(newOptions, newNetworkStatus)\\n            .promise;\\n    };\\n    ObservableQuery.prototype.resubscribeAfterError = function () {\\n        var args = [];\\n        for (var _i = 0; _i < arguments.length; _i++) {\\n            args[_i] = arguments[_i];\\n        }\\n        // If `lastError` is set in the current when the subscription is re-created,\\n        // the subscription will immediately receive the error, which will\\n        // cause it to terminate again. To avoid this, we first clear\\n        // the last error/result from the `observableQuery` before re-starting\\n        // the subscription, and restore the last value afterwards so that the\\n        // subscription has a chance to stay open.\\n        var last = this.last;\\n        this.resetLastResults();\\n        var subscription = this.subscribe.apply(this, args);\\n        this.last = last;\\n        return subscription;\\n    };\\n    // (Re)deliver the current result to this.observers without applying fetch\\n    // policies or making network requests.\\n    ObservableQuery.prototype.observe = function () {\\n        this.reportResult(\\n        // Passing false is important so that this.getCurrentResult doesn't\\n        // save the fetchMore result as this.lastResult, causing it to be\\n        // ignored due to the this.isDifferentFromLastResult check in\\n        // this.reportResult.\\n        this.getCurrentResult(false), this.variables);\\n    };\\n    ObservableQuery.prototype.reportResult = function (result, variables) {\\n        var lastError = this.getLastError();\\n        var isDifferent = this.isDifferentFromLastResult(result, variables);\\n        // Update the last result even when isDifferentFromLastResult returns false,\\n        // because the query may be using the @nonreactive directive, and we want to\\n        // save the the latest version of any nonreactive subtrees (in case\\n        // getCurrentResult is called), even though we skip broadcasting changes.\\n        if (lastError || !result.partial || this.options.returnPartialData) {\\n            this.updateLastResult(result, variables);\\n        }\\n        if (lastError || isDifferent) {\\n            iterateObserversSafely(this.observers, \\\"next\\\", result);\\n        }\\n    };\\n    ObservableQuery.prototype.reportError = function (error, variables) {\\n        // Since we don't get the current result on errors, only the error, we\\n        // must mirror the updates that occur in QueryStore.markQueryError here\\n        var errorResult = __assign(__assign({}, this.getLastResult()), { error: error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });\\n        this.updateLastResult(errorResult, variables);\\n        iterateObserversSafely(this.observers, \\\"error\\\", (this.last.error = error));\\n    };\\n    ObservableQuery.prototype.hasObservers = function () {\\n        return this.observers.size > 0;\\n    };\\n    ObservableQuery.prototype.tearDownQuery = function () {\\n        if (this.isTornDown)\\n            return;\\n        if (this.concast && this.observer) {\\n            this.concast.removeObserver(this.observer);\\n            delete this.concast;\\n            delete this.observer;\\n        }\\n        this.stopPolling();\\n        // stop all active GraphQL subscriptions\\n        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });\\n        this.subscriptions.clear();\\n        this.queryManager.stopQuery(this.queryId);\\n        this.observers.clear();\\n        this.isTornDown = true;\\n    };\\n    ObservableQuery.prototype.transformDocument = function (document) {\\n        return this.queryManager.transform(document);\\n    };\\n    return ObservableQuery;\\n}(Observable));\\nexport { ObservableQuery };\\n// Necessary because the ObservableQuery constructor has a different\\n// signature than the Observable constructor.\\nfixObservableSubclass(ObservableQuery);\\n// Reobserve with fetchPolicy effectively set to \\\"cache-first\\\", triggering\\n// delivery of any new data from the cache, possibly falling back to the network\\n// if any cache data are missing. This allows _complete_ cache results to be\\n// delivered without also kicking off unnecessary network requests when\\n// this.options.fetchPolicy is \\\"cache-and-network\\\" or \\\"network-only\\\". When\\n// this.options.fetchPolicy is any other policy (\\\"cache-first\\\", \\\"cache-only\\\",\\n// \\\"standby\\\", or \\\"no-cache\\\"), we call this.reobserve() as usual.\\nexport function reobserveCacheFirst(obsQuery) {\\n    var _a = obsQuery.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;\\n    if (fetchPolicy === \\\"cache-and-network\\\" || fetchPolicy === \\\"network-only\\\") {\\n        return obsQuery.reobserve({\\n            fetchPolicy: \\\"cache-first\\\",\\n            // Use a temporary nextFetchPolicy function that replaces itself with the\\n            // previous nextFetchPolicy value and returns the original fetchPolicy.\\n            nextFetchPolicy: function (currentFetchPolicy, context) {\\n                // Replace this nextFetchPolicy function in the options object with the\\n                // original this.options.nextFetchPolicy value.\\n                this.nextFetchPolicy = nextFetchPolicy;\\n                // If the original nextFetchPolicy value was a function, give it a\\n                // chance to decide what happens here.\\n                if (typeof this.nextFetchPolicy === \\\"function\\\") {\\n                    return this.nextFetchPolicy(currentFetchPolicy, context);\\n                }\\n                // Otherwise go back to the original this.options.fetchPolicy.\\n                return fetchPolicy;\\n            },\\n        });\\n    }\\n    return obsQuery.reobserve();\\n}\\nfunction defaultSubscriptionObserverErrorCallback(error) {\\n    globalThis.__DEV__ !== false && invariant.error(23, error.message, error.stack);\\n}\\nexport function logMissingFieldErrors(missing) {\\n    if (globalThis.__DEV__ !== false && missing) {\\n        globalThis.__DEV__ !== false && invariant.debug(24, missing);\\n    }\\n}\\nfunction skipCacheDataFor(fetchPolicy /* `undefined` would mean `\\\"cache-first\\\"` */) {\\n    return (fetchPolicy === \\\"network-only\\\" ||\\n        fetchPolicy === \\\"no-cache\\\" ||\\n        fetchPolicy === \\\"standby\\\");\\n}\\n//# sourceMappingURL=ObservableQuery.js.map\"],\n  \"mappings\": \"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\",\n  \"names\": [\"ObservableQuery\", \"_a\", \"info\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1713304787096,
      "end": 1713304787096,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1713304787096,
      "end": 1713304787096,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1713304787096,
      "end": 1713304787096,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1713304787096,
      "end": 1713304787096,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1713304787096,
      "end": 1713304787097,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1713304787097,
      "end": 1713304787097,
      "order": "normal"
    }
  ]
}
