{
  "resolvedId": "/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/core/QueryManager.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { execute } from \"../link/core/index.js\";\nimport { hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, removeDirectivesFromDocument, } from \"../utilities/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform, } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors, } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { LocalState } from \"./LocalState.js\";\nimport { QueryInfo, shouldWriteResult, } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar IGNORE = Object.create(null);\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nvar QueryManager = /** @class */ (function () {\n    function QueryManager(_a) {\n        var cache = _a.cache, link = _a.link, defaultOptions = _a.defaultOptions, documentTransform = _a.documentTransform, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a.onBroadcast, _c = _a.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a.localState, _e = _a.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? !!cache.assumeImmutableResults : _e, defaultContext = _a.defaultContext;\n        var _this = this;\n        this.clientAwareness = {};\n        // All the queries that the QueryManager is currently managing (not\n        // including mutations and subscriptions).\n        this.queries = new Map();\n        // Maps from queryId strings to Promise rejection functions for\n        // currently active queries and fetches.\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.fetchCancelFns = new Map();\n        this.transformCache = new AutoCleanedWeakCache(cacheSizes[\"queryManager.getDocumentInfo\"] ||\n            2000 /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */);\n        this.queryIdCounter = 1;\n        this.requestIdCounter = 1;\n        this.mutationIdCounter = 1;\n        // Use protected instead of private field so\n        // @apollo/experimental-nextjs-app-support can access type info.\n        this.inFlightLinkObservables = new Trie(false);\n        var defaultDocumentTransform = new DocumentTransform(function (document) { return _this.cache.transformDocument(document); }, \n        // Allow the apollo cache to manage its own transform caches\n        { cache: false });\n        this.cache = cache;\n        this.link = link;\n        this.defaultOptions = defaultOptions || Object.create(null);\n        this.queryDeduplication = queryDeduplication;\n        this.clientAwareness = clientAwareness;\n        this.localState = localState || new LocalState({ cache: cache });\n        this.ssrMode = ssrMode;\n        this.assumeImmutableResults = assumeImmutableResults;\n        this.documentTransform =\n            documentTransform ?\n                defaultDocumentTransform\n                    .concat(documentTransform)\n                    // The custom document transform may add new fragment spreads or new\n                    // field selections, so we want to give the cache a chance to run\n                    // again. For example, the InMemoryCache adds __typename to field\n                    // selections and fragments from the fragment registry.\n                    .concat(defaultDocumentTransform)\n                : defaultDocumentTransform;\n        this.defaultContext = defaultContext || Object.create(null);\n        if ((this.onBroadcast = onBroadcast)) {\n            this.mutationStore = Object.create(null);\n        }\n    }\n    /**\n     * Call this method to terminate any active query processes, making it safe\n     * to dispose of this QueryManager instance.\n     */\n    QueryManager.prototype.stop = function () {\n        var _this = this;\n        this.queries.forEach(function (_info, queryId) {\n            _this.stopQueryNoBroadcast(queryId);\n        });\n        this.cancelPendingFetches(newInvariantError(25));\n    };\n    QueryManager.prototype.cancelPendingFetches = function (error) {\n        this.fetchCancelFns.forEach(function (cancel) { return cancel(error); });\n        this.fetchCancelFns.clear();\n    };\n    QueryManager.prototype.mutate = function (_a) {\n        var _b, _c;\n        var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueries = _a.updateQueries, _d = _a.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e = _a.awaitRefetchQueries, awaitRefetchQueries = _e === void 0 ? false : _e, updateWithProxyFn = _a.update, onQueryUpdated = _a.onQueryUpdated, _f = _a.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \"network-only\" : _f, _g = _a.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || \"none\" : _g, keepRootFields = _a.keepRootFields, context = _a.context;\n        return __awaiter(this, void 0, void 0, function () {\n            var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;\n            return __generator(this, function (_h) {\n                switch (_h.label) {\n                    case 0:\n                        invariant(mutation, 26);\n                        invariant(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 27);\n                        mutationId = this.generateMutationId();\n                        mutation = this.cache.transformForLink(this.transform(mutation));\n                        hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\n                        variables = this.getVariables(mutation, variables);\n                        if (!hasClientExports) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.localState.addExportedVariables(mutation, variables, context)];\n                    case 1:\n                        variables = (_h.sent());\n                        _h.label = 2;\n                    case 2:\n                        mutationStoreValue = this.mutationStore &&\n                            (this.mutationStore[mutationId] = {\n                                mutation: mutation,\n                                variables: variables,\n                                loading: true,\n                                error: null,\n                            });\n                        isOptimistic = optimisticResponse &&\n                            this.markMutationOptimistic(optimisticResponse, {\n                                mutationId: mutationId,\n                                document: mutation,\n                                variables: variables,\n                                fetchPolicy: fetchPolicy,\n                                errorPolicy: errorPolicy,\n                                context: context,\n                                updateQueries: updateQueries,\n                                update: updateWithProxyFn,\n                                keepRootFields: keepRootFields,\n                            });\n                        this.broadcastQueries();\n                        self = this;\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\n                                return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, false), function (result) {\n                                    if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n                                        throw new ApolloError({\n                                            graphQLErrors: getGraphQLErrorsFromResult(result),\n                                        });\n                                    }\n                                    if (mutationStoreValue) {\n                                        mutationStoreValue.loading = false;\n                                        mutationStoreValue.error = null;\n                                    }\n                                    var storeResult = __assign({}, result);\n                                    if (typeof refetchQueries === \"function\") {\n                                        refetchQueries = refetchQueries(storeResult);\n                                    }\n                                    if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n                                        delete storeResult.errors;\n                                    }\n                                    return self.markMutationResult({\n                                        mutationId: mutationId,\n                                        result: storeResult,\n                                        document: mutation,\n                                        variables: variables,\n                                        fetchPolicy: fetchPolicy,\n                                        errorPolicy: errorPolicy,\n                                        context: context,\n                                        update: updateWithProxyFn,\n                                        updateQueries: updateQueries,\n                                        awaitRefetchQueries: awaitRefetchQueries,\n                                        refetchQueries: refetchQueries,\n                                        removeOptimistic: isOptimistic ? mutationId : void 0,\n                                        onQueryUpdated: onQueryUpdated,\n                                        keepRootFields: keepRootFields,\n                                    });\n                                }).subscribe({\n                                    next: function (storeResult) {\n                                        self.broadcastQueries();\n                                        // Since mutations might receive multiple payloads from the\n                                        // ApolloLink chain (e.g. when used with @defer),\n                                        // we resolve with a SingleExecutionResult or after the final\n                                        // ExecutionPatchResult has arrived and we have assembled the\n                                        // multipart response into a single result.\n                                        if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                                            resolve(storeResult);\n                                        }\n                                    },\n                                    error: function (err) {\n                                        if (mutationStoreValue) {\n                                            mutationStoreValue.loading = false;\n                                            mutationStoreValue.error = err;\n                                        }\n                                        if (isOptimistic) {\n                                            self.cache.removeOptimistic(mutationId);\n                                        }\n                                        self.broadcastQueries();\n                                        reject(err instanceof ApolloError ? err : (new ApolloError({\n                                            networkError: err,\n                                        })));\n                                    },\n                                });\n                            })];\n                }\n            });\n        });\n    };\n    QueryManager.prototype.markMutationResult = function (mutation, cache) {\n        var _this = this;\n        if (cache === void 0) { cache = this.cache; }\n        var result = mutation.result;\n        var cacheWrites = [];\n        var skipCache = mutation.fetchPolicy === \"no-cache\";\n        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n            if (!isExecutionPatchIncrementalResult(result)) {\n                cacheWrites.push({\n                    result: result.data,\n                    dataId: \"ROOT_MUTATION\",\n                    query: mutation.document,\n                    variables: mutation.variables,\n                });\n            }\n            if (isExecutionPatchIncrementalResult(result) &&\n                isNonEmptyArray(result.incremental)) {\n                var diff = cache.diff({\n                    id: \"ROOT_MUTATION\",\n                    // The cache complains if passed a mutation where it expects a\n                    // query, so we transform mutations and subscriptions to queries\n                    // (only once, thanks to this.transformCache).\n                    query: this.getDocumentInfo(mutation.document).asQuery,\n                    variables: mutation.variables,\n                    optimistic: false,\n                    returnPartialData: true,\n                });\n                var mergedData = void 0;\n                if (diff.result) {\n                    mergedData = mergeIncrementalData(diff.result, result);\n                }\n                if (typeof mergedData !== \"undefined\") {\n                    // cast the ExecutionPatchResult to FetchResult here since\n                    // ExecutionPatchResult never has `data` when returned from the server\n                    result.data = mergedData;\n                    cacheWrites.push({\n                        result: mergedData,\n                        dataId: \"ROOT_MUTATION\",\n                        query: mutation.document,\n                        variables: mutation.variables,\n                    });\n                }\n            }\n            var updateQueries_1 = mutation.updateQueries;\n            if (updateQueries_1) {\n                this.queries.forEach(function (_a, queryId) {\n                    var observableQuery = _a.observableQuery;\n                    var queryName = observableQuery && observableQuery.queryName;\n                    if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n                        return;\n                    }\n                    var updater = updateQueries_1[queryName];\n                    var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;\n                    // Read the current query result from the store.\n                    var _c = cache.diff({\n                        query: document,\n                        variables: variables,\n                        returnPartialData: true,\n                        optimistic: false,\n                    }), currentQueryResult = _c.result, complete = _c.complete;\n                    if (complete && currentQueryResult) {\n                        // Run our reducer using the current query result and the mutation result.\n                        var nextQueryResult = updater(currentQueryResult, {\n                            mutationResult: result,\n                            queryName: (document && getOperationName(document)) || void 0,\n                            queryVariables: variables,\n                        });\n                        // Write the modified result back into the store if we got a new result.\n                        if (nextQueryResult) {\n                            cacheWrites.push({\n                                result: nextQueryResult,\n                                dataId: \"ROOT_QUERY\",\n                                query: document,\n                                variables: variables,\n                            });\n                        }\n                    }\n                });\n            }\n        }\n        if (cacheWrites.length > 0 ||\n            (mutation.refetchQueries || \"\").length > 0 ||\n            mutation.update ||\n            mutation.onQueryUpdated ||\n            mutation.removeOptimistic) {\n            var results_1 = [];\n            this.refetchQueries({\n                updateCache: function (cache) {\n                    if (!skipCache) {\n                        cacheWrites.forEach(function (write) { return cache.write(write); });\n                    }\n                    // If the mutation has some writes associated with it then we need to\n                    // apply those writes to the store by running this reducer again with\n                    // a write action.\n                    var update = mutation.update;\n                    // Determine whether result is a SingleExecutionResult,\n                    // or the final ExecutionPatchResult.\n                    var isFinalResult = !isExecutionPatchResult(result) ||\n                        (isExecutionPatchIncrementalResult(result) && !result.hasNext);\n                    if (update) {\n                        if (!skipCache) {\n                            // Re-read the ROOT_MUTATION data we just wrote into the cache\n                            // (the first cache.write call in the cacheWrites.forEach loop\n                            // above), so field read functions have a chance to run for\n                            // fields within mutation result objects.\n                            var diff = cache.diff({\n                                id: \"ROOT_MUTATION\",\n                                // The cache complains if passed a mutation where it expects a\n                                // query, so we transform mutations and subscriptions to queries\n                                // (only once, thanks to this.transformCache).\n                                query: _this.getDocumentInfo(mutation.document).asQuery,\n                                variables: mutation.variables,\n                                optimistic: false,\n                                returnPartialData: true,\n                            });\n                            if (diff.complete) {\n                                result = __assign(__assign({}, result), { data: diff.result });\n                                if (\"incremental\" in result) {\n                                    delete result.incremental;\n                                }\n                                if (\"hasNext\" in result) {\n                                    delete result.hasNext;\n                                }\n                            }\n                        }\n                        // If we've received the whole response,\n                        // either a SingleExecutionResult or the final ExecutionPatchResult,\n                        // call the update function.\n                        if (isFinalResult) {\n                            update(cache, result, {\n                                context: mutation.context,\n                                variables: mutation.variables,\n                            });\n                        }\n                    }\n                    // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\n                    // shallow to allow rolling back optimistic evictions.\n                    if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n                        cache.modify({\n                            id: \"ROOT_MUTATION\",\n                            fields: function (value, _a) {\n                                var fieldName = _a.fieldName, DELETE = _a.DELETE;\n                                return fieldName === \"__typename\" ? value : DELETE;\n                            },\n                        });\n                    }\n                },\n                include: mutation.refetchQueries,\n                // Write the final mutation.result to the root layer of the cache.\n                optimistic: false,\n                // Remove the corresponding optimistic layer at the same time as we\n                // write the final non-optimistic result.\n                removeOptimistic: mutation.removeOptimistic,\n                // Let the caller of client.mutate optionally determine the refetching\n                // behavior for watched queries after the mutation.update function runs.\n                // If no onQueryUpdated function was provided for this mutation, pass\n                // null instead of undefined to disable the default refetching behavior.\n                onQueryUpdated: mutation.onQueryUpdated || null,\n            }).forEach(function (result) { return results_1.push(result); });\n            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n                // Returning a promise here makes the mutation await that promise, so we\n                // include results in that promise's work if awaitRefetchQueries or an\n                // onQueryUpdated function was specified.\n                return Promise.all(results_1).then(function () { return result; });\n            }\n        }\n        return Promise.resolve(result);\n    };\n    QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n        var _this = this;\n        var data = typeof optimisticResponse === \"function\" ?\n            optimisticResponse(mutation.variables, { IGNORE: IGNORE })\n            : optimisticResponse;\n        if (data === IGNORE) {\n            return false;\n        }\n        this.cache.recordOptimisticTransaction(function (cache) {\n            try {\n                _this.markMutationResult(__assign(__assign({}, mutation), { result: { data: data } }), cache);\n            }\n            catch (error) {\n                globalThis.__DEV__ !== false && invariant.error(error);\n            }\n        }, mutation.mutationId);\n        return true;\n    };\n    QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n        return this.fetchConcastWithInfo(queryId, options, networkStatus).concast\n            .promise;\n    };\n    QueryManager.prototype.getQueryStore = function () {\n        var store = Object.create(null);\n        this.queries.forEach(function (info, queryId) {\n            store[queryId] = {\n                variables: info.variables,\n                networkStatus: info.networkStatus,\n                networkError: info.networkError,\n                graphQLErrors: info.graphQLErrors,\n            };\n        });\n        return store;\n    };\n    QueryManager.prototype.resetErrors = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo) {\n            queryInfo.networkError = undefined;\n            queryInfo.graphQLErrors = [];\n        }\n    };\n    QueryManager.prototype.transform = function (document) {\n        return this.documentTransform.transformDocument(document);\n    };\n    QueryManager.prototype.getDocumentInfo = function (document) {\n        var transformCache = this.transformCache;\n        if (!transformCache.has(document)) {\n            var cacheEntry = {\n                // TODO These three calls (hasClientExports, shouldForceResolvers, and\n                // usesNonreactiveDirective) are performing independent full traversals\n                // of the transformed document. We should consider merging these\n                // traversals into a single pass in the future, though the work is\n                // cached after the first time.\n                hasClientExports: hasClientExports(document),\n                hasForcedResolvers: this.localState.shouldForceResolvers(document),\n                hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n                clientQuery: this.localState.clientQuery(document),\n                serverQuery: removeDirectivesFromDocument([\n                    { name: \"client\", remove: true },\n                    { name: \"connection\" },\n                    { name: \"nonreactive\" },\n                ], document),\n                defaultVars: getDefaultValues(getOperationDefinition(document)),\n                // Transform any mutation or subscription operations to query operations\n                // so we can read/write them from/to the cache.\n                asQuery: __assign(__assign({}, document), { definitions: document.definitions.map(function (def) {\n                        if (def.kind === \"OperationDefinition\" &&\n                            def.operation !== \"query\") {\n                            return __assign(__assign({}, def), { operation: \"query\" });\n                        }\n                        return def;\n                    }) }),\n            };\n            transformCache.set(document, cacheEntry);\n        }\n        return transformCache.get(document);\n    };\n    QueryManager.prototype.getVariables = function (document, variables) {\n        return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n    };\n    QueryManager.prototype.watchQuery = function (options) {\n        var query = this.transform(options.query);\n        // assign variable default values if supplied\n        // NOTE: We don't modify options.query here with the transformed query to\n        // ensure observable.options.query is set to the raw untransformed query.\n        options = __assign(__assign({}, options), { variables: this.getVariables(query, options.variables) });\n        if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n            options.notifyOnNetworkStatusChange = false;\n        }\n        var queryInfo = new QueryInfo(this);\n        var observable = new ObservableQuery({\n            queryManager: this,\n            queryInfo: queryInfo,\n            options: options,\n        });\n        observable[\"lastQuery\"] = query;\n        this.queries.set(observable.queryId, queryInfo);\n        // We give queryInfo the transformed query to ensure the first cache diff\n        // uses the transformed query instead of the raw query\n        queryInfo.init({\n            document: query,\n            observableQuery: observable,\n            variables: observable.variables,\n        });\n        return observable;\n    };\n    QueryManager.prototype.query = function (options, queryId) {\n        var _this = this;\n        if (queryId === void 0) { queryId = this.generateQueryId(); }\n        invariant(options.query, 28);\n        invariant(options.query.kind === \"Document\", 29);\n        invariant(!options.returnPartialData, 30);\n        invariant(!options.pollInterval, 31);\n        return this.fetchQuery(queryId, __assign(__assign({}, options), { query: this.transform(options.query) })).finally(function () { return _this.stopQuery(queryId); });\n    };\n    QueryManager.prototype.generateQueryId = function () {\n        return String(this.queryIdCounter++);\n    };\n    QueryManager.prototype.generateRequestId = function () {\n        return this.requestIdCounter++;\n    };\n    QueryManager.prototype.generateMutationId = function () {\n        return String(this.mutationIdCounter++);\n    };\n    QueryManager.prototype.stopQueryInStore = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo)\n            queryInfo.stop();\n    };\n    QueryManager.prototype.clearStore = function (options) {\n        if (options === void 0) { options = {\n            discardWatches: true,\n        }; }\n        // Before we have sent the reset action to the store, we can no longer\n        // rely on the results returned by in-flight requests since these may\n        // depend on values that previously existed in the data portion of the\n        // store. So, we cancel the promises and observers that we have issued\n        // so far and not yet resolved (in the case of queries).\n        this.cancelPendingFetches(newInvariantError(32));\n        this.queries.forEach(function (queryInfo) {\n            if (queryInfo.observableQuery) {\n                // Set loading to true so listeners don't trigger unless they want\n                // results with partial data.\n                queryInfo.networkStatus = NetworkStatus.loading;\n            }\n            else {\n                queryInfo.stop();\n            }\n        });\n        if (this.mutationStore) {\n            this.mutationStore = Object.create(null);\n        }\n        // begin removing data from the store\n        return this.cache.reset(options);\n    };\n    QueryManager.prototype.getObservableQueries = function (include) {\n        var _this = this;\n        if (include === void 0) { include = \"active\"; }\n        var queries = new Map();\n        var queryNamesAndDocs = new Map();\n        var legacyQueryOptions = new Set();\n        if (Array.isArray(include)) {\n            include.forEach(function (desc) {\n                if (typeof desc === \"string\") {\n                    queryNamesAndDocs.set(desc, false);\n                }\n                else if (isDocumentNode(desc)) {\n                    queryNamesAndDocs.set(_this.transform(desc), false);\n                }\n                else if (isNonNullObject(desc) && desc.query) {\n                    legacyQueryOptions.add(desc);\n                }\n            });\n        }\n        this.queries.forEach(function (_a, queryId) {\n            var oq = _a.observableQuery, document = _a.document;\n            if (oq) {\n                if (include === \"all\") {\n                    queries.set(queryId, oq);\n                    return;\n                }\n                var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;\n                if (fetchPolicy === \"standby\" ||\n                    (include === \"active\" && !oq.hasObservers())) {\n                    return;\n                }\n                if (include === \"active\" ||\n                    (queryName && queryNamesAndDocs.has(queryName)) ||\n                    (document && queryNamesAndDocs.has(document))) {\n                    queries.set(queryId, oq);\n                    if (queryName)\n                        queryNamesAndDocs.set(queryName, true);\n                    if (document)\n                        queryNamesAndDocs.set(document, true);\n                }\n            }\n        });\n        if (legacyQueryOptions.size) {\n            legacyQueryOptions.forEach(function (options) {\n                // We will be issuing a fresh network request for this query, so we\n                // pre-allocate a new query ID here, using a special prefix to enable\n                // cleaning up these temporary queries later, after fetching.\n                var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n                var queryInfo = _this.getQuery(queryId).init({\n                    document: options.query,\n                    variables: options.variables,\n                });\n                var oq = new ObservableQuery({\n                    queryManager: _this,\n                    queryInfo: queryInfo,\n                    options: __assign(__assign({}, options), { fetchPolicy: \"network-only\" }),\n                });\n                invariant(oq.queryId === queryId);\n                queryInfo.setObservableQuery(oq);\n                queries.set(queryId, oq);\n            });\n        }\n        if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {\n            queryNamesAndDocs.forEach(function (included, nameOrDoc) {\n                if (!included) {\n                    globalThis.__DEV__ !== false && invariant.warn(typeof nameOrDoc === \"string\" ? 33 : 34, nameOrDoc);\n                }\n            });\n        }\n        return queries;\n    };\n    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n        var _this = this;\n        if (includeStandby === void 0) { includeStandby = false; }\n        var observableQueryPromises = [];\n        this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n            var fetchPolicy = observableQuery.options.fetchPolicy;\n            observableQuery.resetLastResults();\n            if (includeStandby ||\n                (fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\")) {\n                observableQueryPromises.push(observableQuery.refetch());\n            }\n            _this.getQuery(queryId).setDiff(null);\n        });\n        this.broadcastQueries();\n        return Promise.all(observableQueryPromises);\n    };\n    QueryManager.prototype.setObservableQuery = function (observableQuery) {\n        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n    };\n    QueryManager.prototype.startGraphQLSubscription = function (_a) {\n        var _this = this;\n        var query = _a.query, fetchPolicy = _a.fetchPolicy, _b = _a.errorPolicy, errorPolicy = _b === void 0 ? \"none\" : _b, variables = _a.variables, _c = _a.context, context = _c === void 0 ? {} : _c;\n        query = this.transform(query);\n        variables = this.getVariables(query, variables);\n        var makeObservable = function (variables) {\n            return _this.getObservableFromLink(query, context, variables).map(function (result) {\n                if (fetchPolicy !== \"no-cache\") {\n                    // the subscription interface should handle not sending us results we no longer subscribe to.\n                    // XXX I don't think we ever send in an object with errors, but we might in the future...\n                    if (shouldWriteResult(result, errorPolicy)) {\n                        _this.cache.write({\n                            query: query,\n                            result: result.data,\n                            dataId: \"ROOT_SUBSCRIPTION\",\n                            variables: variables,\n                        });\n                    }\n                    _this.broadcastQueries();\n                }\n                var hasErrors = graphQLResultHasError(result);\n                var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n                if (hasErrors || hasProtocolErrors) {\n                    var errors = {};\n                    if (hasErrors) {\n                        errors.graphQLErrors = result.errors;\n                    }\n                    if (hasProtocolErrors) {\n                        errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n                    }\n                    // `errorPolicy` is a mechanism for handling GraphQL errors, according\n                    // to our documentation, so we throw protocol errors regardless of the\n                    // set error policy.\n                    if (errorPolicy === \"none\" || hasProtocolErrors) {\n                        throw new ApolloError(errors);\n                    }\n                }\n                if (errorPolicy === \"ignore\") {\n                    delete result.errors;\n                }\n                return result;\n            });\n        };\n        if (this.getDocumentInfo(query).hasClientExports) {\n            var observablePromise_1 = this.localState\n                .addExportedVariables(query, variables, context)\n                .then(makeObservable);\n            return new Observable(function (observer) {\n                var sub = null;\n                observablePromise_1.then(function (observable) { return (sub = observable.subscribe(observer)); }, observer.error);\n                return function () { return sub && sub.unsubscribe(); };\n            });\n        }\n        return makeObservable(variables);\n    };\n    QueryManager.prototype.stopQuery = function (queryId) {\n        this.stopQueryNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.removeQuery(queryId);\n    };\n    QueryManager.prototype.removeQuery = function (queryId) {\n        // teardown all links\n        // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n        // that each add their reject functions to fetchCancelFns.\n        // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n        // The same queryId could have two rejection fns for two promises\n        this.fetchCancelFns.delete(queryId);\n        if (this.queries.has(queryId)) {\n            this.getQuery(queryId).stop();\n            this.queries.delete(queryId);\n        }\n    };\n    QueryManager.prototype.broadcastQueries = function () {\n        if (this.onBroadcast)\n            this.onBroadcast();\n        this.queries.forEach(function (info) { return info.notify(); });\n    };\n    QueryManager.prototype.getLocalState = function () {\n        return this.localState;\n    };\n    QueryManager.prototype.getObservableFromLink = function (query, context, variables, \n    // Prefer context.queryDeduplication if specified.\n    deduplication) {\n        var _this = this;\n        var _a;\n        if (deduplication === void 0) { deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication; }\n        var observable;\n        var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;\n        if (serverQuery) {\n            var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;\n            var operation = {\n                query: serverQuery,\n                variables: variables,\n                operationName: getOperationName(serverQuery) || void 0,\n                context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),\n            };\n            context = operation.context;\n            if (deduplication) {\n                var printedServerQuery_1 = print(serverQuery);\n                var varJson_1 = canonicalStringify(variables);\n                var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\n                observable = entry.observable;\n                if (!observable) {\n                    var concast = new Concast([\n                        execute(link, operation),\n                    ]);\n                    observable = entry.observable = concast;\n                    concast.beforeNext(function () {\n                        inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\n                    });\n                }\n            }\n            else {\n                observable = new Concast([\n                    execute(link, operation),\n                ]);\n            }\n        }\n        else {\n            observable = new Concast([Observable.of({ data: {} })]);\n            context = this.prepareContext(context);\n        }\n        if (clientQuery) {\n            observable = asyncMap(observable, function (result) {\n                return _this.localState.runResolvers({\n                    document: clientQuery,\n                    remoteResult: result,\n                    context: context,\n                    variables: variables,\n                });\n            });\n        }\n        return observable;\n    };\n    QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n        var requestId = (queryInfo.lastRequestId = this.generateRequestId());\n        // Performing transformForLink here gives this.cache a chance to fill in\n        // missing fragment definitions (for example) before sending this document\n        // through the link chain.\n        var linkDocument = this.cache.transformForLink(options.query);\n        return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n            var graphQLErrors = getGraphQLErrorsFromResult(result);\n            var hasErrors = graphQLErrors.length > 0;\n            // If we interrupted this request by calling getResultsFromLink again\n            // with the same QueryInfo object, we ignore the old results.\n            if (requestId >= queryInfo.lastRequestId) {\n                if (hasErrors && options.errorPolicy === \"none\") {\n                    // Throwing here effectively calls observer.error.\n                    throw queryInfo.markError(new ApolloError({\n                        graphQLErrors: graphQLErrors,\n                    }));\n                }\n                // Use linkDocument rather than queryInfo.document so the\n                // operation/fragments used to write the result are the same as the\n                // ones used to obtain it from the link.\n                queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n                queryInfo.markReady();\n            }\n            var aqr = {\n                data: result.data,\n                loading: false,\n                networkStatus: NetworkStatus.ready,\n            };\n            if (hasErrors && options.errorPolicy !== \"ignore\") {\n                aqr.errors = graphQLErrors;\n                aqr.networkStatus = NetworkStatus.error;\n            }\n            return aqr;\n        }, function (networkError) {\n            var error = isApolloError(networkError) ? networkError : (new ApolloError({ networkError: networkError }));\n            // Avoid storing errors from older interrupted queries.\n            if (requestId >= queryInfo.lastRequestId) {\n                queryInfo.markError(error);\n            }\n            throw error;\n        });\n    };\n    QueryManager.prototype.fetchConcastWithInfo = function (queryId, options, \n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus, query) {\n        var _this = this;\n        if (networkStatus === void 0) { networkStatus = NetworkStatus.loading; }\n        if (query === void 0) { query = options.query; }\n        var variables = this.getVariables(query, options.variables);\n        var queryInfo = this.getQuery(queryId);\n        var defaults = this.defaultOptions.watchQuery;\n        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? (defaults && defaults.fetchPolicy) || \"cache-first\" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? (defaults && defaults.errorPolicy) || \"none\" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;\n        var normalized = Object.assign({}, options, {\n            query: query,\n            variables: variables,\n            fetchPolicy: fetchPolicy,\n            errorPolicy: errorPolicy,\n            returnPartialData: returnPartialData,\n            notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n            context: context,\n        });\n        var fromVariables = function (variables) {\n            // Since normalized is always a fresh copy of options, it's safe to\n            // modify its properties here, rather than creating yet another new\n            // WatchQueryOptions object.\n            normalized.variables = variables;\n            var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n            if (\n            // If we're in standby, postpone advancing options.fetchPolicy using\n            // applyNextFetchPolicy.\n            normalized.fetchPolicy !== \"standby\" &&\n                // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n                // this is another way to detect when nothing was done/fetched.\n                sourcesWithInfo.sources.length > 0 &&\n                queryInfo.observableQuery) {\n                queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n            }\n            return sourcesWithInfo;\n        };\n        // This cancel function needs to be set before the concast is created,\n        // in case concast creation synchronously cancels the request.\n        var cleanupCancelFn = function () { return _this.fetchCancelFns.delete(queryId); };\n        this.fetchCancelFns.set(queryId, function (reason) {\n            cleanupCancelFn();\n            // This delay ensures the concast variable has been initialized.\n            setTimeout(function () { return concast.cancel(reason); });\n        });\n        var concast, containsDataFromLink;\n        // If the query has @export(as: ...) directives, then we need to\n        // process those directives asynchronously. When there are no\n        // @export directives (the common case), we deliberately avoid\n        // wrapping the result of this.fetchQueryByPolicy in a Promise,\n        // since the timing of result delivery is (unfortunately) important\n        // for backwards compatibility. TODO This code could be simpler if\n        // we deprecated and removed LocalState.\n        if (this.getDocumentInfo(normalized.query).hasClientExports) {\n            concast = new Concast(this.localState\n                .addExportedVariables(normalized.query, normalized.variables, normalized.context)\n                .then(fromVariables)\n                .then(function (sourcesWithInfo) { return sourcesWithInfo.sources; }));\n            // there is just no way we can synchronously get the *right* value here,\n            // so we will assume `true`, which is the behaviour before the bug fix in\n            // #10597. This means that bug is not fixed in that case, and is probably\n            // un-fixable with reasonable effort for the edge case of @export as\n            // directives.\n            containsDataFromLink = true;\n        }\n        else {\n            var sourcesWithInfo = fromVariables(normalized.variables);\n            containsDataFromLink = sourcesWithInfo.fromLink;\n            concast = new Concast(sourcesWithInfo.sources);\n        }\n        concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n        return {\n            concast: concast,\n            fromLink: containsDataFromLink,\n        };\n    };\n    QueryManager.prototype.refetchQueries = function (_a) {\n        var _this = this;\n        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;\n        var includedQueriesById = new Map();\n        if (include) {\n            this.getObservableQueries(include).forEach(function (oq, queryId) {\n                includedQueriesById.set(queryId, {\n                    oq: oq,\n                    lastDiff: _this.getQuery(queryId).getDiff(),\n                });\n            });\n        }\n        var results = new Map();\n        if (updateCache) {\n            this.cache.batch({\n                update: updateCache,\n                // Since you can perform any combination of cache reads and/or writes in\n                // the cache.batch update function, its optimistic option can be either\n                // a boolean or a string, representing three distinct modes of\n                // operation:\n                //\n                // * false: read/write only the root layer\n                // * true: read/write the topmost layer\n                // * string: read/write a fresh optimistic layer with that ID string\n                //\n                // When typeof optimistic === \"string\", a new optimistic layer will be\n                // temporarily created within cache.batch with that string as its ID. If\n                // we then pass that same string as the removeOptimistic option, we can\n                // make cache.batch immediately remove the optimistic layer after\n                // running the updateCache function, triggering only one broadcast.\n                //\n                // However, the refetchQueries method accepts only true or false for its\n                // optimistic option (not string). We interpret true to mean a temporary\n                // optimistic layer should be created, to allow efficiently rolling back\n                // the effect of the updateCache function, which involves passing a\n                // string instead of true as the optimistic option to cache.batch, when\n                // refetchQueries receives optimistic: true.\n                //\n                // In other words, we are deliberately not supporting the use case of\n                // writing to an *existing* optimistic layer (using the refetchQueries\n                // updateCache function), since that would potentially interfere with\n                // other optimistic updates in progress. Instead, you can read/write\n                // only the root layer by passing optimistic: false to refetchQueries,\n                // or you can read/write a brand new optimistic layer that will be\n                // automatically removed by passing optimistic: true.\n                optimistic: (optimistic && removeOptimistic) || false,\n                // The removeOptimistic option can also be provided by itself, even if\n                // optimistic === false, to remove some previously-added optimistic\n                // layer safely and efficiently, like we do in markMutationResult.\n                //\n                // If an explicit removeOptimistic string is provided with optimistic:\n                // true, the removeOptimistic string will determine the ID of the\n                // temporary optimistic layer, in case that ever matters.\n                removeOptimistic: removeOptimistic,\n                onWatchUpdated: function (watch, diff, lastDiff) {\n                    var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n                    if (oq) {\n                        if (onQueryUpdated) {\n                            // Since we're about to handle this query now, remove it from\n                            // includedQueriesById, in case it was added earlier because of\n                            // options.include.\n                            includedQueriesById.delete(oq.queryId);\n                            var result = onQueryUpdated(oq, diff, lastDiff);\n                            if (result === true) {\n                                // The onQueryUpdated function requested the default refetching\n                                // behavior by returning true.\n                                result = oq.refetch();\n                            }\n                            // Record the result in the results Map, as long as onQueryUpdated\n                            // did not return false to skip/ignore this result.\n                            if (result !== false) {\n                                results.set(oq, result);\n                            }\n                            // Allow the default cache broadcast to happen, except when\n                            // onQueryUpdated returns false.\n                            return result;\n                        }\n                        if (onQueryUpdated !== null) {\n                            // If we don't have an onQueryUpdated function, and onQueryUpdated\n                            // was not disabled by passing null, make sure this query is\n                            // \"included\" like any other options.include-specified query.\n                            includedQueriesById.set(oq.queryId, { oq: oq, lastDiff: lastDiff, diff: diff });\n                        }\n                    }\n                },\n            });\n        }\n        if (includedQueriesById.size) {\n            includedQueriesById.forEach(function (_a, queryId) {\n                var oq = _a.oq, lastDiff = _a.lastDiff, diff = _a.diff;\n                var result;\n                // If onQueryUpdated is provided, we want to use it for all included\n                // queries, even the QueryOptions ones.\n                if (onQueryUpdated) {\n                    if (!diff) {\n                        var info = oq[\"queryInfo\"];\n                        info.reset(); // Force info.getDiff() to read from cache.\n                        diff = info.getDiff();\n                    }\n                    result = onQueryUpdated(oq, diff, lastDiff);\n                }\n                // Otherwise, we fall back to refetching.\n                if (!onQueryUpdated || result === true) {\n                    result = oq.refetch();\n                }\n                if (result !== false) {\n                    results.set(oq, result);\n                }\n                if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n                    _this.stopQueryNoBroadcast(queryId);\n                }\n            });\n        }\n        if (removeOptimistic) {\n            // In case no updateCache callback was provided (so cache.batch was not\n            // called above, and thus did not already remove the optimistic layer),\n            // remove it here. Since this is a no-op when the layer has already been\n            // removed, we do it even if we called cache.batch above, since it's\n            // possible this.cache is an instance of some ApolloCache subclass other\n            // than InMemoryCache, and does not fully support the removeOptimistic\n            // option for cache.batch.\n            this.cache.removeOptimistic(removeOptimistic);\n        }\n        return results;\n    };\n    QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, \n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus) {\n        var _this = this;\n        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n        var oldNetworkStatus = queryInfo.networkStatus;\n        queryInfo.init({\n            document: query,\n            variables: variables,\n            networkStatus: networkStatus,\n        });\n        var readCache = function () { return queryInfo.getDiff(); };\n        var resultsFromCache = function (diff, networkStatus) {\n            if (networkStatus === void 0) { networkStatus = queryInfo.networkStatus || NetworkStatus.loading; }\n            var data = diff.result;\n            if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n                logMissingFieldErrors(diff.missing);\n            }\n            var fromData = function (data) {\n                return Observable.of(__assign({ data: data, loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus }, (diff.complete ? null : { partial: true })));\n            };\n            if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n                return _this.localState\n                    .runResolvers({\n                    document: query,\n                    remoteResult: { data: data },\n                    context: context,\n                    variables: variables,\n                    onlyRunForcedResolvers: true,\n                })\n                    .then(function (resolved) { return fromData(resolved.data || void 0); });\n            }\n            // Resolves https://github.com/apollographql/apollo-client/issues/10317.\n            // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\n            // data was incorrectly returned from the cache on refetch:\n            // if diff.missing exists, we should not return cache data.\n            if (errorPolicy === \"none\" &&\n                networkStatus === NetworkStatus.refetch &&\n                Array.isArray(diff.missing)) {\n                return fromData(void 0);\n            }\n            return fromData(data);\n        };\n        var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 /* CacheWriteBehavior.FORBID */\n            // Watched queries must opt into overwriting existing data on refetch,\n            // by passing refetchWritePolicy: \"overwrite\" in their WatchQueryOptions.\n            : (networkStatus === NetworkStatus.refetch &&\n                refetchWritePolicy !== \"merge\") ?\n                1 /* CacheWriteBehavior.OVERWRITE */\n                : 2 /* CacheWriteBehavior.MERGE */;\n        var resultsFromLink = function () {\n            return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n                query: query,\n                variables: variables,\n                context: context,\n                fetchPolicy: fetchPolicy,\n                errorPolicy: errorPolicy,\n            });\n        };\n        var shouldNotify = notifyOnNetworkStatusChange &&\n            typeof oldNetworkStatus === \"number\" &&\n            oldNetworkStatus !== networkStatus &&\n            isNetworkRequestInFlight(networkStatus);\n        switch (fetchPolicy) {\n            default:\n            case \"cache-first\": {\n                var diff = readCache();\n                if (diff.complete) {\n                    return {\n                        fromLink: false,\n                        sources: [resultsFromCache(diff, queryInfo.markReady())],\n                    };\n                }\n                if (returnPartialData || shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(diff), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            }\n            case \"cache-and-network\": {\n                var diff = readCache();\n                if (diff.complete || returnPartialData || shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(diff), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            }\n            case \"cache-only\":\n                return {\n                    fromLink: false,\n                    sources: [resultsFromCache(readCache(), queryInfo.markReady())],\n                };\n            case \"network-only\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        sources: [resultsFromCache(readCache()), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            case \"no-cache\":\n                if (shouldNotify) {\n                    return {\n                        fromLink: true,\n                        // Note that queryInfo.getDiff() for no-cache queries does not call\n                        // cache.diff, but instead returns a { complete: false } stub result\n                        // when there is no queryInfo.diff already defined.\n                        sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\n                    };\n                }\n                return { fromLink: true, sources: [resultsFromLink()] };\n            case \"standby\":\n                return { fromLink: false, sources: [] };\n        }\n    };\n    QueryManager.prototype.getQuery = function (queryId) {\n        if (queryId && !this.queries.has(queryId)) {\n            this.queries.set(queryId, new QueryInfo(this, queryId));\n        }\n        return this.queries.get(queryId);\n    };\n    QueryManager.prototype.prepareContext = function (context) {\n        if (context === void 0) { context = {}; }\n        var newContext = this.localState.prepareContext(context);\n        return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });\n    };\n    return QueryManager;\n}());\nexport { QueryManager };\n//# sourceMappingURL=QueryManager.js.map",
      "start": 1746507072323,
      "end": 1746507072329,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "graphql",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1746507072329,
      "end": 1746507072329,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1746507072329,
      "end": 1746507072331,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { execute } from \"../link/core/index.js\";\nimport { hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, removeDirectivesFromDocument } from \"../utilities/index.js\";\nimport { canonicalStringify } from \"../cache/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform } from \"../utilities/index.js\";\nimport { mergeIncrementalData } from \"../utilities/common/incrementalResult.js\";\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors } from \"../errors/index.js\";\nimport { ObservableQuery, logMissingFieldErrors } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { LocalState } from \"./LocalState.js\";\nimport { QueryInfo, shouldWriteResult } from \"./QueryInfo.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../errors/index.js\";\nimport { print } from \"../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar IGNORE = /* @__PURE__ */ Object.create(null);\nimport { Trie } from \"@wry/trie\";\nimport { AutoCleanedWeakCache, cacheSizes } from \"../utilities/index.js\";\nvar QueryManager = (\n  /** @class */\n  function() {\n    function QueryManager2(_a) {\n      var cache = _a.cache, link = _a.link, defaultOptions = _a.defaultOptions, documentTransform = _a.documentTransform, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a.onBroadcast, _c = _a.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a.localState, _e = _a.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? !!cache.assumeImmutableResults : _e, defaultContext = _a.defaultContext;\n      var _this = this;\n      this.clientAwareness = {};\n      this.queries = /* @__PURE__ */ new Map();\n      this.fetchCancelFns = /* @__PURE__ */ new Map();\n      this.transformCache = new AutoCleanedWeakCache(\n        cacheSizes[\"queryManager.getDocumentInfo\"] || 2e3\n        /* defaultCacheSizes[\"queryManager.getDocumentInfo\"] */\n      );\n      this.queryIdCounter = 1;\n      this.requestIdCounter = 1;\n      this.mutationIdCounter = 1;\n      this.inFlightLinkObservables = new Trie(false);\n      var defaultDocumentTransform = new DocumentTransform(\n        function(document) {\n          return _this.cache.transformDocument(document);\n        },\n        // Allow the apollo cache to manage its own transform caches\n        { cache: false }\n      );\n      this.cache = cache;\n      this.link = link;\n      this.defaultOptions = defaultOptions || /* @__PURE__ */ Object.create(null);\n      this.queryDeduplication = queryDeduplication;\n      this.clientAwareness = clientAwareness;\n      this.localState = localState || new LocalState({ cache });\n      this.ssrMode = ssrMode;\n      this.assumeImmutableResults = assumeImmutableResults;\n      this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;\n      this.defaultContext = defaultContext || /* @__PURE__ */ Object.create(null);\n      if (this.onBroadcast = onBroadcast) {\n        this.mutationStore = /* @__PURE__ */ Object.create(null);\n      }\n    }\n    QueryManager2.prototype.stop = function() {\n      var _this = this;\n      this.queries.forEach(function(_info, queryId) {\n        _this.stopQueryNoBroadcast(queryId);\n      });\n      this.cancelPendingFetches(newInvariantError(25));\n    };\n    QueryManager2.prototype.cancelPendingFetches = function(error) {\n      this.fetchCancelFns.forEach(function(cancel) {\n        return cancel(error);\n      });\n      this.fetchCancelFns.clear();\n    };\n    QueryManager2.prototype.mutate = function(_a) {\n      var _b, _c;\n      var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueries = _a.updateQueries, _d = _a.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e = _a.awaitRefetchQueries, awaitRefetchQueries = _e === void 0 ? false : _e, updateWithProxyFn = _a.update, onQueryUpdated = _a.onQueryUpdated, _f = _a.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \"network-only\" : _f, _g = _a.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || \"none\" : _g, keepRootFields = _a.keepRootFields, context = _a.context;\n      return __awaiter(this, void 0, void 0, function() {\n        var mutationId, hasClientExports2, mutationStoreValue, isOptimistic, self;\n        return __generator(this, function(_h) {\n          switch (_h.label) {\n            case 0:\n              invariant(mutation, 26);\n              invariant(fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\", 27);\n              mutationId = this.generateMutationId();\n              mutation = this.cache.transformForLink(this.transform(mutation));\n              hasClientExports2 = this.getDocumentInfo(mutation).hasClientExports;\n              variables = this.getVariables(mutation, variables);\n              if (!hasClientExports2)\n                return [3, 2];\n              return [4, this.localState.addExportedVariables(mutation, variables, context)];\n            case 1:\n              variables = _h.sent();\n              _h.label = 2;\n            case 2:\n              mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n                mutation,\n                variables,\n                loading: true,\n                error: null\n              });\n              isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {\n                mutationId,\n                document: mutation,\n                variables,\n                fetchPolicy,\n                errorPolicy,\n                context,\n                updateQueries,\n                update: updateWithProxyFn,\n                keepRootFields\n              });\n              this.broadcastQueries();\n              self = this;\n              return [2, new Promise(function(resolve, reject) {\n                return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, false), function(result) {\n                  if (graphQLResultHasError(result) && errorPolicy === \"none\") {\n                    throw new ApolloError({\n                      graphQLErrors: getGraphQLErrorsFromResult(result)\n                    });\n                  }\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = null;\n                  }\n                  var storeResult = __assign({}, result);\n                  if (typeof refetchQueries === \"function\") {\n                    refetchQueries = refetchQueries(storeResult);\n                  }\n                  if (errorPolicy === \"ignore\" && graphQLResultHasError(storeResult)) {\n                    delete storeResult.errors;\n                  }\n                  return self.markMutationResult({\n                    mutationId,\n                    result: storeResult,\n                    document: mutation,\n                    variables,\n                    fetchPolicy,\n                    errorPolicy,\n                    context,\n                    update: updateWithProxyFn,\n                    updateQueries,\n                    awaitRefetchQueries,\n                    refetchQueries,\n                    removeOptimistic: isOptimistic ? mutationId : void 0,\n                    onQueryUpdated,\n                    keepRootFields\n                  });\n                }).subscribe({\n                  next: function(storeResult) {\n                    self.broadcastQueries();\n                    if (!(\"hasNext\" in storeResult) || storeResult.hasNext === false) {\n                      resolve(storeResult);\n                    }\n                  },\n                  error: function(err) {\n                    if (mutationStoreValue) {\n                      mutationStoreValue.loading = false;\n                      mutationStoreValue.error = err;\n                    }\n                    if (isOptimistic) {\n                      self.cache.removeOptimistic(mutationId);\n                    }\n                    self.broadcastQueries();\n                    reject(err instanceof ApolloError ? err : new ApolloError({\n                      networkError: err\n                    }));\n                  }\n                });\n              })];\n          }\n        });\n      });\n    };\n    QueryManager2.prototype.markMutationResult = function(mutation, cache) {\n      var _this = this;\n      if (cache === void 0) {\n        cache = this.cache;\n      }\n      var result = mutation.result;\n      var cacheWrites = [];\n      var skipCache = mutation.fetchPolicy === \"no-cache\";\n      if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n        if (!isExecutionPatchIncrementalResult(result)) {\n          cacheWrites.push({\n            result: result.data,\n            dataId: \"ROOT_MUTATION\",\n            query: mutation.document,\n            variables: mutation.variables\n          });\n        }\n        if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {\n          var diff = cache.diff({\n            id: \"ROOT_MUTATION\",\n            // The cache complains if passed a mutation where it expects a\n            // query, so we transform mutations and subscriptions to queries\n            // (only once, thanks to this.transformCache).\n            query: this.getDocumentInfo(mutation.document).asQuery,\n            variables: mutation.variables,\n            optimistic: false,\n            returnPartialData: true\n          });\n          var mergedData = void 0;\n          if (diff.result) {\n            mergedData = mergeIncrementalData(diff.result, result);\n          }\n          if (typeof mergedData !== \"undefined\") {\n            result.data = mergedData;\n            cacheWrites.push({\n              result: mergedData,\n              dataId: \"ROOT_MUTATION\",\n              query: mutation.document,\n              variables: mutation.variables\n            });\n          }\n        }\n        var updateQueries_1 = mutation.updateQueries;\n        if (updateQueries_1) {\n          this.queries.forEach(function(_a, queryId) {\n            var observableQuery = _a.observableQuery;\n            var queryName = observableQuery && observableQuery.queryName;\n            if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n              return;\n            }\n            var updater = updateQueries_1[queryName];\n            var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;\n            var _c = cache.diff({\n              query: document,\n              variables,\n              returnPartialData: true,\n              optimistic: false\n            }), currentQueryResult = _c.result, complete = _c.complete;\n            if (complete && currentQueryResult) {\n              var nextQueryResult = updater(currentQueryResult, {\n                mutationResult: result,\n                queryName: document && getOperationName(document) || void 0,\n                queryVariables: variables\n              });\n              if (nextQueryResult) {\n                cacheWrites.push({\n                  result: nextQueryResult,\n                  dataId: \"ROOT_QUERY\",\n                  query: document,\n                  variables\n                });\n              }\n            }\n          });\n        }\n      }\n      if (cacheWrites.length > 0 || (mutation.refetchQueries || \"\").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {\n        var results_1 = [];\n        this.refetchQueries({\n          updateCache: function(cache2) {\n            if (!skipCache) {\n              cacheWrites.forEach(function(write) {\n                return cache2.write(write);\n              });\n            }\n            var update = mutation.update;\n            var isFinalResult = !isExecutionPatchResult(result) || isExecutionPatchIncrementalResult(result) && !result.hasNext;\n            if (update) {\n              if (!skipCache) {\n                var diff2 = cache2.diff({\n                  id: \"ROOT_MUTATION\",\n                  // The cache complains if passed a mutation where it expects a\n                  // query, so we transform mutations and subscriptions to queries\n                  // (only once, thanks to this.transformCache).\n                  query: _this.getDocumentInfo(mutation.document).asQuery,\n                  variables: mutation.variables,\n                  optimistic: false,\n                  returnPartialData: true\n                });\n                if (diff2.complete) {\n                  result = __assign(__assign({}, result), { data: diff2.result });\n                  if (\"incremental\" in result) {\n                    delete result.incremental;\n                  }\n                  if (\"hasNext\" in result) {\n                    delete result.hasNext;\n                  }\n                }\n              }\n              if (isFinalResult) {\n                update(cache2, result, {\n                  context: mutation.context,\n                  variables: mutation.variables\n                });\n              }\n            }\n            if (!skipCache && !mutation.keepRootFields && isFinalResult) {\n              cache2.modify({\n                id: \"ROOT_MUTATION\",\n                fields: function(value, _a) {\n                  var fieldName = _a.fieldName, DELETE = _a.DELETE;\n                  return fieldName === \"__typename\" ? value : DELETE;\n                }\n              });\n            }\n          },\n          include: mutation.refetchQueries,\n          // Write the final mutation.result to the root layer of the cache.\n          optimistic: false,\n          // Remove the corresponding optimistic layer at the same time as we\n          // write the final non-optimistic result.\n          removeOptimistic: mutation.removeOptimistic,\n          // Let the caller of client.mutate optionally determine the refetching\n          // behavior for watched queries after the mutation.update function runs.\n          // If no onQueryUpdated function was provided for this mutation, pass\n          // null instead of undefined to disable the default refetching behavior.\n          onQueryUpdated: mutation.onQueryUpdated || null\n        }).forEach(function(result2) {\n          return results_1.push(result2);\n        });\n        if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n          return Promise.all(results_1).then(function() {\n            return result;\n          });\n        }\n      }\n      return Promise.resolve(result);\n    };\n    QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {\n      var _this = this;\n      var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables, { IGNORE }) : optimisticResponse;\n      if (data === IGNORE) {\n        return false;\n      }\n      this.cache.recordOptimisticTransaction(function(cache) {\n        try {\n          _this.markMutationResult(__assign(__assign({}, mutation), { result: { data } }), cache);\n        } catch (error) {\n          globalThis.__DEV__ !== false && invariant.error(error);\n        }\n      }, mutation.mutationId);\n      return true;\n    };\n    QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {\n      return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;\n    };\n    QueryManager2.prototype.getQueryStore = function() {\n      var store = /* @__PURE__ */ Object.create(null);\n      this.queries.forEach(function(info, queryId) {\n        store[queryId] = {\n          variables: info.variables,\n          networkStatus: info.networkStatus,\n          networkError: info.networkError,\n          graphQLErrors: info.graphQLErrors\n        };\n      });\n      return store;\n    };\n    QueryManager2.prototype.resetErrors = function(queryId) {\n      var queryInfo = this.queries.get(queryId);\n      if (queryInfo) {\n        queryInfo.networkError = void 0;\n        queryInfo.graphQLErrors = [];\n      }\n    };\n    QueryManager2.prototype.transform = function(document) {\n      return this.documentTransform.transformDocument(document);\n    };\n    QueryManager2.prototype.getDocumentInfo = function(document) {\n      var transformCache = this.transformCache;\n      if (!transformCache.has(document)) {\n        var cacheEntry = {\n          // TODO These three calls (hasClientExports, shouldForceResolvers, and\n          // usesNonreactiveDirective) are performing independent full traversals\n          // of the transformed document. We should consider merging these\n          // traversals into a single pass in the future, though the work is\n          // cached after the first time.\n          hasClientExports: hasClientExports(document),\n          hasForcedResolvers: this.localState.shouldForceResolvers(document),\n          hasNonreactiveDirective: hasDirectives([\"nonreactive\"], document),\n          clientQuery: this.localState.clientQuery(document),\n          serverQuery: removeDirectivesFromDocument([\n            { name: \"client\", remove: true },\n            { name: \"connection\" },\n            { name: \"nonreactive\" }\n          ], document),\n          defaultVars: getDefaultValues(getOperationDefinition(document)),\n          // Transform any mutation or subscription operations to query operations\n          // so we can read/write them from/to the cache.\n          asQuery: __assign(__assign({}, document), { definitions: document.definitions.map(function(def) {\n            if (def.kind === \"OperationDefinition\" && def.operation !== \"query\") {\n              return __assign(__assign({}, def), { operation: \"query\" });\n            }\n            return def;\n          }) })\n        };\n        transformCache.set(document, cacheEntry);\n      }\n      return transformCache.get(document);\n    };\n    QueryManager2.prototype.getVariables = function(document, variables) {\n      return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\n    };\n    QueryManager2.prototype.watchQuery = function(options) {\n      var query = this.transform(options.query);\n      options = __assign(__assign({}, options), { variables: this.getVariables(query, options.variables) });\n      if (typeof options.notifyOnNetworkStatusChange === \"undefined\") {\n        options.notifyOnNetworkStatusChange = false;\n      }\n      var queryInfo = new QueryInfo(this);\n      var observable = new ObservableQuery({\n        queryManager: this,\n        queryInfo,\n        options\n      });\n      observable[\"lastQuery\"] = query;\n      this.queries.set(observable.queryId, queryInfo);\n      queryInfo.init({\n        document: query,\n        observableQuery: observable,\n        variables: observable.variables\n      });\n      return observable;\n    };\n    QueryManager2.prototype.query = function(options, queryId) {\n      var _this = this;\n      if (queryId === void 0) {\n        queryId = this.generateQueryId();\n      }\n      invariant(options.query, 28);\n      invariant(options.query.kind === \"Document\", 29);\n      invariant(!options.returnPartialData, 30);\n      invariant(!options.pollInterval, 31);\n      return this.fetchQuery(queryId, __assign(__assign({}, options), { query: this.transform(options.query) })).finally(function() {\n        return _this.stopQuery(queryId);\n      });\n    };\n    QueryManager2.prototype.generateQueryId = function() {\n      return String(this.queryIdCounter++);\n    };\n    QueryManager2.prototype.generateRequestId = function() {\n      return this.requestIdCounter++;\n    };\n    QueryManager2.prototype.generateMutationId = function() {\n      return String(this.mutationIdCounter++);\n    };\n    QueryManager2.prototype.stopQueryInStore = function(queryId) {\n      this.stopQueryInStoreNoBroadcast(queryId);\n      this.broadcastQueries();\n    };\n    QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {\n      var queryInfo = this.queries.get(queryId);\n      if (queryInfo)\n        queryInfo.stop();\n    };\n    QueryManager2.prototype.clearStore = function(options) {\n      if (options === void 0) {\n        options = {\n          discardWatches: true\n        };\n      }\n      this.cancelPendingFetches(newInvariantError(32));\n      this.queries.forEach(function(queryInfo) {\n        if (queryInfo.observableQuery) {\n          queryInfo.networkStatus = NetworkStatus.loading;\n        } else {\n          queryInfo.stop();\n        }\n      });\n      if (this.mutationStore) {\n        this.mutationStore = /* @__PURE__ */ Object.create(null);\n      }\n      return this.cache.reset(options);\n    };\n    QueryManager2.prototype.getObservableQueries = function(include) {\n      var _this = this;\n      if (include === void 0) {\n        include = \"active\";\n      }\n      var queries = /* @__PURE__ */ new Map();\n      var queryNamesAndDocs = /* @__PURE__ */ new Map();\n      var legacyQueryOptions = /* @__PURE__ */ new Set();\n      if (Array.isArray(include)) {\n        include.forEach(function(desc) {\n          if (typeof desc === \"string\") {\n            queryNamesAndDocs.set(desc, false);\n          } else if (isDocumentNode(desc)) {\n            queryNamesAndDocs.set(_this.transform(desc), false);\n          } else if (isNonNullObject(desc) && desc.query) {\n            legacyQueryOptions.add(desc);\n          }\n        });\n      }\n      this.queries.forEach(function(_a, queryId) {\n        var oq = _a.observableQuery, document = _a.document;\n        if (oq) {\n          if (include === \"all\") {\n            queries.set(queryId, oq);\n            return;\n          }\n          var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;\n          if (fetchPolicy === \"standby\" || include === \"active\" && !oq.hasObservers()) {\n            return;\n          }\n          if (include === \"active\" || queryName && queryNamesAndDocs.has(queryName) || document && queryNamesAndDocs.has(document)) {\n            queries.set(queryId, oq);\n            if (queryName)\n              queryNamesAndDocs.set(queryName, true);\n            if (document)\n              queryNamesAndDocs.set(document, true);\n          }\n        }\n      });\n      if (legacyQueryOptions.size) {\n        legacyQueryOptions.forEach(function(options) {\n          var queryId = makeUniqueId(\"legacyOneTimeQuery\");\n          var queryInfo = _this.getQuery(queryId).init({\n            document: options.query,\n            variables: options.variables\n          });\n          var oq = new ObservableQuery({\n            queryManager: _this,\n            queryInfo,\n            options: __assign(__assign({}, options), { fetchPolicy: \"network-only\" })\n          });\n          invariant(oq.queryId === queryId);\n          queryInfo.setObservableQuery(oq);\n          queries.set(queryId, oq);\n        });\n      }\n      if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {\n        queryNamesAndDocs.forEach(function(included, nameOrDoc) {\n          if (!included) {\n            globalThis.__DEV__ !== false && invariant.warn(typeof nameOrDoc === \"string\" ? 33 : 34, nameOrDoc);\n          }\n        });\n      }\n      return queries;\n    };\n    QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {\n      var _this = this;\n      if (includeStandby === void 0) {\n        includeStandby = false;\n      }\n      var observableQueryPromises = [];\n      this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function(observableQuery, queryId) {\n        var fetchPolicy = observableQuery.options.fetchPolicy;\n        observableQuery.resetLastResults();\n        if (includeStandby || fetchPolicy !== \"standby\" && fetchPolicy !== \"cache-only\") {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n        _this.getQuery(queryId).setDiff(null);\n      });\n      this.broadcastQueries();\n      return Promise.all(observableQueryPromises);\n    };\n    QueryManager2.prototype.setObservableQuery = function(observableQuery) {\n      this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n    };\n    QueryManager2.prototype.startGraphQLSubscription = function(_a) {\n      var _this = this;\n      var query = _a.query, fetchPolicy = _a.fetchPolicy, _b = _a.errorPolicy, errorPolicy = _b === void 0 ? \"none\" : _b, variables = _a.variables, _c = _a.context, context = _c === void 0 ? {} : _c;\n      query = this.transform(query);\n      variables = this.getVariables(query, variables);\n      var makeObservable = function(variables2) {\n        return _this.getObservableFromLink(query, context, variables2).map(function(result) {\n          if (fetchPolicy !== \"no-cache\") {\n            if (shouldWriteResult(result, errorPolicy)) {\n              _this.cache.write({\n                query,\n                result: result.data,\n                dataId: \"ROOT_SUBSCRIPTION\",\n                variables: variables2\n              });\n            }\n            _this.broadcastQueries();\n          }\n          var hasErrors = graphQLResultHasError(result);\n          var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\n          if (hasErrors || hasProtocolErrors) {\n            var errors = {};\n            if (hasErrors) {\n              errors.graphQLErrors = result.errors;\n            }\n            if (hasProtocolErrors) {\n              errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\n            }\n            if (errorPolicy === \"none\" || hasProtocolErrors) {\n              throw new ApolloError(errors);\n            }\n          }\n          if (errorPolicy === \"ignore\") {\n            delete result.errors;\n          }\n          return result;\n        });\n      };\n      if (this.getDocumentInfo(query).hasClientExports) {\n        var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n        return new Observable(function(observer) {\n          var sub = null;\n          observablePromise_1.then(function(observable) {\n            return sub = observable.subscribe(observer);\n          }, observer.error);\n          return function() {\n            return sub && sub.unsubscribe();\n          };\n        });\n      }\n      return makeObservable(variables);\n    };\n    QueryManager2.prototype.stopQuery = function(queryId) {\n      this.stopQueryNoBroadcast(queryId);\n      this.broadcastQueries();\n    };\n    QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {\n      this.stopQueryInStoreNoBroadcast(queryId);\n      this.removeQuery(queryId);\n    };\n    QueryManager2.prototype.removeQuery = function(queryId) {\n      this.fetchCancelFns.delete(queryId);\n      if (this.queries.has(queryId)) {\n        this.getQuery(queryId).stop();\n        this.queries.delete(queryId);\n      }\n    };\n    QueryManager2.prototype.broadcastQueries = function() {\n      if (this.onBroadcast)\n        this.onBroadcast();\n      this.queries.forEach(function(info) {\n        return info.notify();\n      });\n    };\n    QueryManager2.prototype.getLocalState = function() {\n      return this.localState;\n    };\n    QueryManager2.prototype.getObservableFromLink = function(query, context, variables, deduplication) {\n      var _this = this;\n      var _a;\n      if (deduplication === void 0) {\n        deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n      }\n      var observable;\n      var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;\n      if (serverQuery) {\n        var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;\n        var operation = {\n          query: serverQuery,\n          variables,\n          operationName: getOperationName(serverQuery) || void 0,\n          context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication }))\n        };\n        context = operation.context;\n        if (deduplication) {\n          var printedServerQuery_1 = print(serverQuery);\n          var varJson_1 = canonicalStringify(variables);\n          var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\n          observable = entry.observable;\n          if (!observable) {\n            var concast = new Concast([\n              execute(link, operation)\n            ]);\n            observable = entry.observable = concast;\n            concast.beforeNext(function() {\n              inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\n            });\n          }\n        } else {\n          observable = new Concast([\n            execute(link, operation)\n          ]);\n        }\n      } else {\n        observable = new Concast([Observable.of({ data: {} })]);\n        context = this.prepareContext(context);\n      }\n      if (clientQuery) {\n        observable = asyncMap(observable, function(result) {\n          return _this.localState.runResolvers({\n            document: clientQuery,\n            remoteResult: result,\n            context,\n            variables\n          });\n        });\n      }\n      return observable;\n    };\n    QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {\n      var requestId = queryInfo.lastRequestId = this.generateRequestId();\n      var linkDocument = this.cache.transformForLink(options.query);\n      return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result) {\n        var graphQLErrors = getGraphQLErrorsFromResult(result);\n        var hasErrors = graphQLErrors.length > 0;\n        if (requestId >= queryInfo.lastRequestId) {\n          if (hasErrors && options.errorPolicy === \"none\") {\n            throw queryInfo.markError(new ApolloError({\n              graphQLErrors\n            }));\n          }\n          queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n          queryInfo.markReady();\n        }\n        var aqr = {\n          data: result.data,\n          loading: false,\n          networkStatus: NetworkStatus.ready\n        };\n        if (hasErrors && options.errorPolicy !== \"ignore\") {\n          aqr.errors = graphQLErrors;\n          aqr.networkStatus = NetworkStatus.error;\n        }\n        return aqr;\n      }, function(networkError) {\n        var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });\n        if (requestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n        throw error;\n      });\n    };\n    QueryManager2.prototype.fetchConcastWithInfo = function(queryId, options, networkStatus, query) {\n      var _this = this;\n      if (networkStatus === void 0) {\n        networkStatus = NetworkStatus.loading;\n      }\n      if (query === void 0) {\n        query = options.query;\n      }\n      var variables = this.getVariables(query, options.variables);\n      var queryInfo = this.getQuery(queryId);\n      var defaults = this.defaultOptions.watchQuery;\n      var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || \"cache-first\" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || \"none\" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;\n      var normalized = Object.assign({}, options, {\n        query,\n        variables,\n        fetchPolicy,\n        errorPolicy,\n        returnPartialData,\n        notifyOnNetworkStatusChange,\n        context\n      });\n      var fromVariables = function(variables2) {\n        normalized.variables = variables2;\n        var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n        if (\n          // If we're in standby, postpone advancing options.fetchPolicy using\n          // applyNextFetchPolicy.\n          normalized.fetchPolicy !== \"standby\" && // The \"standby\" policy currently returns [] from fetchQueryByPolicy, so\n          // this is another way to detect when nothing was done/fetched.\n          sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery\n        ) {\n          queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n        }\n        return sourcesWithInfo2;\n      };\n      var cleanupCancelFn = function() {\n        return _this.fetchCancelFns.delete(queryId);\n      };\n      this.fetchCancelFns.set(queryId, function(reason) {\n        cleanupCancelFn();\n        setTimeout(function() {\n          return concast.cancel(reason);\n        });\n      });\n      var concast, containsDataFromLink;\n      if (this.getDocumentInfo(normalized.query).hasClientExports) {\n        concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {\n          return sourcesWithInfo2.sources;\n        }));\n        containsDataFromLink = true;\n      } else {\n        var sourcesWithInfo = fromVariables(normalized.variables);\n        containsDataFromLink = sourcesWithInfo.fromLink;\n        concast = new Concast(sourcesWithInfo.sources);\n      }\n      concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n      return {\n        concast,\n        fromLink: containsDataFromLink\n      };\n    };\n    QueryManager2.prototype.refetchQueries = function(_a) {\n      var _this = this;\n      var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\"refetchQueries\") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;\n      var includedQueriesById = /* @__PURE__ */ new Map();\n      if (include) {\n        this.getObservableQueries(include).forEach(function(oq, queryId) {\n          includedQueriesById.set(queryId, {\n            oq,\n            lastDiff: _this.getQuery(queryId).getDiff()\n          });\n        });\n      }\n      var results = /* @__PURE__ */ new Map();\n      if (updateCache) {\n        this.cache.batch({\n          update: updateCache,\n          // Since you can perform any combination of cache reads and/or writes in\n          // the cache.batch update function, its optimistic option can be either\n          // a boolean or a string, representing three distinct modes of\n          // operation:\n          //\n          // * false: read/write only the root layer\n          // * true: read/write the topmost layer\n          // * string: read/write a fresh optimistic layer with that ID string\n          //\n          // When typeof optimistic === \"string\", a new optimistic layer will be\n          // temporarily created within cache.batch with that string as its ID. If\n          // we then pass that same string as the removeOptimistic option, we can\n          // make cache.batch immediately remove the optimistic layer after\n          // running the updateCache function, triggering only one broadcast.\n          //\n          // However, the refetchQueries method accepts only true or false for its\n          // optimistic option (not string). We interpret true to mean a temporary\n          // optimistic layer should be created, to allow efficiently rolling back\n          // the effect of the updateCache function, which involves passing a\n          // string instead of true as the optimistic option to cache.batch, when\n          // refetchQueries receives optimistic: true.\n          //\n          // In other words, we are deliberately not supporting the use case of\n          // writing to an *existing* optimistic layer (using the refetchQueries\n          // updateCache function), since that would potentially interfere with\n          // other optimistic updates in progress. Instead, you can read/write\n          // only the root layer by passing optimistic: false to refetchQueries,\n          // or you can read/write a brand new optimistic layer that will be\n          // automatically removed by passing optimistic: true.\n          optimistic: optimistic && removeOptimistic || false,\n          // The removeOptimistic option can also be provided by itself, even if\n          // optimistic === false, to remove some previously-added optimistic\n          // layer safely and efficiently, like we do in markMutationResult.\n          //\n          // If an explicit removeOptimistic string is provided with optimistic:\n          // true, the removeOptimistic string will determine the ID of the\n          // temporary optimistic layer, in case that ever matters.\n          removeOptimistic,\n          onWatchUpdated: function(watch, diff, lastDiff) {\n            var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\n            if (oq) {\n              if (onQueryUpdated) {\n                includedQueriesById.delete(oq.queryId);\n                var result = onQueryUpdated(oq, diff, lastDiff);\n                if (result === true) {\n                  result = oq.refetch();\n                }\n                if (result !== false) {\n                  results.set(oq, result);\n                }\n                return result;\n              }\n              if (onQueryUpdated !== null) {\n                includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });\n              }\n            }\n          }\n        });\n      }\n      if (includedQueriesById.size) {\n        includedQueriesById.forEach(function(_a2, queryId) {\n          var oq = _a2.oq, lastDiff = _a2.lastDiff, diff = _a2.diff;\n          var result;\n          if (onQueryUpdated) {\n            if (!diff) {\n              var info = oq[\"queryInfo\"];\n              info.reset();\n              diff = info.getDiff();\n            }\n            result = onQueryUpdated(oq, diff, lastDiff);\n          }\n          if (!onQueryUpdated || result === true) {\n            result = oq.refetch();\n          }\n          if (result !== false) {\n            results.set(oq, result);\n          }\n          if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n            _this.stopQueryNoBroadcast(queryId);\n          }\n        });\n      }\n      if (removeOptimistic) {\n        this.cache.removeOptimistic(removeOptimistic);\n      }\n      return results;\n    };\n    QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a, networkStatus) {\n      var _this = this;\n      var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n      var oldNetworkStatus = queryInfo.networkStatus;\n      queryInfo.init({\n        document: query,\n        variables,\n        networkStatus\n      });\n      var readCache = function() {\n        return queryInfo.getDiff();\n      };\n      var resultsFromCache = function(diff2, networkStatus2) {\n        if (networkStatus2 === void 0) {\n          networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;\n        }\n        var data = diff2.result;\n        if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\n          logMissingFieldErrors(diff2.missing);\n        }\n        var fromData = function(data2) {\n          return Observable.of(__assign({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));\n        };\n        if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\n          return _this.localState.runResolvers({\n            document: query,\n            remoteResult: { data },\n            context,\n            variables,\n            onlyRunForcedResolvers: true\n          }).then(function(resolved) {\n            return fromData(resolved.data || void 0);\n          });\n        }\n        if (errorPolicy === \"none\" && networkStatus2 === NetworkStatus.refetch && Array.isArray(diff2.missing)) {\n          return fromData(void 0);\n        }\n        return fromData(data);\n      };\n      var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== \"merge\" ? 1 : 2;\n      var resultsFromLink = function() {\n        return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n          query,\n          variables,\n          context,\n          fetchPolicy,\n          errorPolicy\n        });\n      };\n      var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);\n      switch (fetchPolicy) {\n        default:\n        case \"cache-first\": {\n          var diff = readCache();\n          if (diff.complete) {\n            return {\n              fromLink: false,\n              sources: [resultsFromCache(diff, queryInfo.markReady())]\n            };\n          }\n          if (returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return { fromLink: true, sources: [resultsFromLink()] };\n        }\n        case \"cache-and-network\": {\n          var diff = readCache();\n          if (diff.complete || returnPartialData || shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(diff), resultsFromLink()]\n            };\n          }\n          return { fromLink: true, sources: [resultsFromLink()] };\n        }\n        case \"cache-only\":\n          return {\n            fromLink: false,\n            sources: [resultsFromCache(readCache(), queryInfo.markReady())]\n          };\n        case \"network-only\":\n          if (shouldNotify) {\n            return {\n              fromLink: true,\n              sources: [resultsFromCache(readCache()), resultsFromLink()]\n            };\n          }\n          return { fromLink: true, sources: [resultsFromLink()] };\n        case \"no-cache\":\n          if (shouldNotify) {\n            return {\n              fromLink: true,\n              // Note that queryInfo.getDiff() for no-cache queries does not call\n              // cache.diff, but instead returns a { complete: false } stub result\n              // when there is no queryInfo.diff already defined.\n              sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]\n            };\n          }\n          return { fromLink: true, sources: [resultsFromLink()] };\n        case \"standby\":\n          return { fromLink: false, sources: [] };\n      }\n    };\n    QueryManager2.prototype.getQuery = function(queryId) {\n      if (queryId && !this.queries.has(queryId)) {\n        this.queries.set(queryId, new QueryInfo(this, queryId));\n      }\n      return this.queries.get(queryId);\n    };\n    QueryManager2.prototype.prepareContext = function(context) {\n      if (context === void 0) {\n        context = {};\n      }\n      var newContext = this.localState.prepareContext(context);\n      return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });\n    };\n    return QueryManager2;\n  }()\n);\nexport { QueryManager };\n",
      "start": 1746507072331,
      "end": 1746507072854,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/core/QueryManager.js\"],\n  \"sourcesContent\": [\"import { __assign, __awaiter, __generator } from \\\"tslib\\\";\\nimport { invariant, newInvariantError } from \\\"../utilities/globals/index.js\\\";\\nimport { equal } from \\\"@wry/equality\\\";\\nimport { execute } from \\\"../link/core/index.js\\\";\\nimport { hasDirectives, isExecutionPatchIncrementalResult, isExecutionPatchResult, removeDirectivesFromDocument, } from \\\"../utilities/index.js\\\";\\nimport { canonicalStringify } from \\\"../cache/index.js\\\";\\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, getGraphQLErrorsFromResult, Observable, asyncMap, isNonEmptyArray, Concast, makeUniqueId, isDocumentNode, isNonNullObject, DocumentTransform, } from \\\"../utilities/index.js\\\";\\nimport { mergeIncrementalData } from \\\"../utilities/common/incrementalResult.js\\\";\\nimport { ApolloError, isApolloError, graphQLResultHasProtocolErrors, } from \\\"../errors/index.js\\\";\\nimport { ObservableQuery, logMissingFieldErrors } from \\\"./ObservableQuery.js\\\";\\nimport { NetworkStatus, isNetworkRequestInFlight } from \\\"./networkStatus.js\\\";\\nimport { LocalState } from \\\"./LocalState.js\\\";\\nimport { QueryInfo, shouldWriteResult, } from \\\"./QueryInfo.js\\\";\\nimport { PROTOCOL_ERRORS_SYMBOL } from \\\"../errors/index.js\\\";\\nimport { print } from \\\"../utilities/index.js\\\";\\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\\nvar IGNORE = Object.create(null);\\nimport { Trie } from \\\"@wry/trie\\\";\\nimport { AutoCleanedWeakCache, cacheSizes } from \\\"../utilities/index.js\\\";\\nvar QueryManager = /** @class */ (function () {\\n    function QueryManager(_a) {\\n        var cache = _a.cache, link = _a.link, defaultOptions = _a.defaultOptions, documentTransform = _a.documentTransform, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a.onBroadcast, _c = _a.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a.localState, _e = _a.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? !!cache.assumeImmutableResults : _e, defaultContext = _a.defaultContext;\\n        var _this = this;\\n        this.clientAwareness = {};\\n        // All the queries that the QueryManager is currently managing (not\\n        // including mutations and subscriptions).\\n        this.queries = new Map();\\n        // Maps from queryId strings to Promise rejection functions for\\n        // currently active queries and fetches.\\n        // Use protected instead of private field so\\n        // @apollo/experimental-nextjs-app-support can access type info.\\n        this.fetchCancelFns = new Map();\\n        this.transformCache = new AutoCleanedWeakCache(cacheSizes[\\\"queryManager.getDocumentInfo\\\"] ||\\n            2000 /* defaultCacheSizes[\\\"queryManager.getDocumentInfo\\\"] */);\\n        this.queryIdCounter = 1;\\n        this.requestIdCounter = 1;\\n        this.mutationIdCounter = 1;\\n        // Use protected instead of private field so\\n        // @apollo/experimental-nextjs-app-support can access type info.\\n        this.inFlightLinkObservables = new Trie(false);\\n        var defaultDocumentTransform = new DocumentTransform(function (document) { return _this.cache.transformDocument(document); }, \\n        // Allow the apollo cache to manage its own transform caches\\n        { cache: false });\\n        this.cache = cache;\\n        this.link = link;\\n        this.defaultOptions = defaultOptions || Object.create(null);\\n        this.queryDeduplication = queryDeduplication;\\n        this.clientAwareness = clientAwareness;\\n        this.localState = localState || new LocalState({ cache: cache });\\n        this.ssrMode = ssrMode;\\n        this.assumeImmutableResults = assumeImmutableResults;\\n        this.documentTransform =\\n            documentTransform ?\\n                defaultDocumentTransform\\n                    .concat(documentTransform)\\n                    // The custom document transform may add new fragment spreads or new\\n                    // field selections, so we want to give the cache a chance to run\\n                    // again. For example, the InMemoryCache adds __typename to field\\n                    // selections and fragments from the fragment registry.\\n                    .concat(defaultDocumentTransform)\\n                : defaultDocumentTransform;\\n        this.defaultContext = defaultContext || Object.create(null);\\n        if ((this.onBroadcast = onBroadcast)) {\\n            this.mutationStore = Object.create(null);\\n        }\\n    }\\n    /**\\n     * Call this method to terminate any active query processes, making it safe\\n     * to dispose of this QueryManager instance.\\n     */\\n    QueryManager.prototype.stop = function () {\\n        var _this = this;\\n        this.queries.forEach(function (_info, queryId) {\\n            _this.stopQueryNoBroadcast(queryId);\\n        });\\n        this.cancelPendingFetches(newInvariantError(25));\\n    };\\n    QueryManager.prototype.cancelPendingFetches = function (error) {\\n        this.fetchCancelFns.forEach(function (cancel) { return cancel(error); });\\n        this.fetchCancelFns.clear();\\n    };\\n    QueryManager.prototype.mutate = function (_a) {\\n        var _b, _c;\\n        var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueries = _a.updateQueries, _d = _a.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e = _a.awaitRefetchQueries, awaitRefetchQueries = _e === void 0 ? false : _e, updateWithProxyFn = _a.update, onQueryUpdated = _a.onQueryUpdated, _f = _a.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \\\"network-only\\\" : _f, _g = _a.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || \\\"none\\\" : _g, keepRootFields = _a.keepRootFields, context = _a.context;\\n        return __awaiter(this, void 0, void 0, function () {\\n            var mutationId, hasClientExports, mutationStoreValue, isOptimistic, self;\\n            return __generator(this, function (_h) {\\n                switch (_h.label) {\\n                    case 0:\\n                        invariant(mutation, 26);\\n                        invariant(fetchPolicy === \\\"network-only\\\" || fetchPolicy === \\\"no-cache\\\", 27);\\n                        mutationId = this.generateMutationId();\\n                        mutation = this.cache.transformForLink(this.transform(mutation));\\n                        hasClientExports = this.getDocumentInfo(mutation).hasClientExports;\\n                        variables = this.getVariables(mutation, variables);\\n                        if (!hasClientExports) return [3 /*break*/, 2];\\n                        return [4 /*yield*/, this.localState.addExportedVariables(mutation, variables, context)];\\n                    case 1:\\n                        variables = (_h.sent());\\n                        _h.label = 2;\\n                    case 2:\\n                        mutationStoreValue = this.mutationStore &&\\n                            (this.mutationStore[mutationId] = {\\n                                mutation: mutation,\\n                                variables: variables,\\n                                loading: true,\\n                                error: null,\\n                            });\\n                        isOptimistic = optimisticResponse &&\\n                            this.markMutationOptimistic(optimisticResponse, {\\n                                mutationId: mutationId,\\n                                document: mutation,\\n                                variables: variables,\\n                                fetchPolicy: fetchPolicy,\\n                                errorPolicy: errorPolicy,\\n                                context: context,\\n                                updateQueries: updateQueries,\\n                                update: updateWithProxyFn,\\n                                keepRootFields: keepRootFields,\\n                            });\\n                        this.broadcastQueries();\\n                        self = this;\\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\\n                                return asyncMap(self.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, false), function (result) {\\n                                    if (graphQLResultHasError(result) && errorPolicy === \\\"none\\\") {\\n                                        throw new ApolloError({\\n                                            graphQLErrors: getGraphQLErrorsFromResult(result),\\n                                        });\\n                                    }\\n                                    if (mutationStoreValue) {\\n                                        mutationStoreValue.loading = false;\\n                                        mutationStoreValue.error = null;\\n                                    }\\n                                    var storeResult = __assign({}, result);\\n                                    if (typeof refetchQueries === \\\"function\\\") {\\n                                        refetchQueries = refetchQueries(storeResult);\\n                                    }\\n                                    if (errorPolicy === \\\"ignore\\\" && graphQLResultHasError(storeResult)) {\\n                                        delete storeResult.errors;\\n                                    }\\n                                    return self.markMutationResult({\\n                                        mutationId: mutationId,\\n                                        result: storeResult,\\n                                        document: mutation,\\n                                        variables: variables,\\n                                        fetchPolicy: fetchPolicy,\\n                                        errorPolicy: errorPolicy,\\n                                        context: context,\\n                                        update: updateWithProxyFn,\\n                                        updateQueries: updateQueries,\\n                                        awaitRefetchQueries: awaitRefetchQueries,\\n                                        refetchQueries: refetchQueries,\\n                                        removeOptimistic: isOptimistic ? mutationId : void 0,\\n                                        onQueryUpdated: onQueryUpdated,\\n                                        keepRootFields: keepRootFields,\\n                                    });\\n                                }).subscribe({\\n                                    next: function (storeResult) {\\n                                        self.broadcastQueries();\\n                                        // Since mutations might receive multiple payloads from the\\n                                        // ApolloLink chain (e.g. when used with @defer),\\n                                        // we resolve with a SingleExecutionResult or after the final\\n                                        // ExecutionPatchResult has arrived and we have assembled the\\n                                        // multipart response into a single result.\\n                                        if (!(\\\"hasNext\\\" in storeResult) || storeResult.hasNext === false) {\\n                                            resolve(storeResult);\\n                                        }\\n                                    },\\n                                    error: function (err) {\\n                                        if (mutationStoreValue) {\\n                                            mutationStoreValue.loading = false;\\n                                            mutationStoreValue.error = err;\\n                                        }\\n                                        if (isOptimistic) {\\n                                            self.cache.removeOptimistic(mutationId);\\n                                        }\\n                                        self.broadcastQueries();\\n                                        reject(err instanceof ApolloError ? err : (new ApolloError({\\n                                            networkError: err,\\n                                        })));\\n                                    },\\n                                });\\n                            })];\\n                }\\n            });\\n        });\\n    };\\n    QueryManager.prototype.markMutationResult = function (mutation, cache) {\\n        var _this = this;\\n        if (cache === void 0) { cache = this.cache; }\\n        var result = mutation.result;\\n        var cacheWrites = [];\\n        var skipCache = mutation.fetchPolicy === \\\"no-cache\\\";\\n        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\\n            if (!isExecutionPatchIncrementalResult(result)) {\\n                cacheWrites.push({\\n                    result: result.data,\\n                    dataId: \\\"ROOT_MUTATION\\\",\\n                    query: mutation.document,\\n                    variables: mutation.variables,\\n                });\\n            }\\n            if (isExecutionPatchIncrementalResult(result) &&\\n                isNonEmptyArray(result.incremental)) {\\n                var diff = cache.diff({\\n                    id: \\\"ROOT_MUTATION\\\",\\n                    // The cache complains if passed a mutation where it expects a\\n                    // query, so we transform mutations and subscriptions to queries\\n                    // (only once, thanks to this.transformCache).\\n                    query: this.getDocumentInfo(mutation.document).asQuery,\\n                    variables: mutation.variables,\\n                    optimistic: false,\\n                    returnPartialData: true,\\n                });\\n                var mergedData = void 0;\\n                if (diff.result) {\\n                    mergedData = mergeIncrementalData(diff.result, result);\\n                }\\n                if (typeof mergedData !== \\\"undefined\\\") {\\n                    // cast the ExecutionPatchResult to FetchResult here since\\n                    // ExecutionPatchResult never has `data` when returned from the server\\n                    result.data = mergedData;\\n                    cacheWrites.push({\\n                        result: mergedData,\\n                        dataId: \\\"ROOT_MUTATION\\\",\\n                        query: mutation.document,\\n                        variables: mutation.variables,\\n                    });\\n                }\\n            }\\n            var updateQueries_1 = mutation.updateQueries;\\n            if (updateQueries_1) {\\n                this.queries.forEach(function (_a, queryId) {\\n                    var observableQuery = _a.observableQuery;\\n                    var queryName = observableQuery && observableQuery.queryName;\\n                    if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\\n                        return;\\n                    }\\n                    var updater = updateQueries_1[queryName];\\n                    var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;\\n                    // Read the current query result from the store.\\n                    var _c = cache.diff({\\n                        query: document,\\n                        variables: variables,\\n                        returnPartialData: true,\\n                        optimistic: false,\\n                    }), currentQueryResult = _c.result, complete = _c.complete;\\n                    if (complete && currentQueryResult) {\\n                        // Run our reducer using the current query result and the mutation result.\\n                        var nextQueryResult = updater(currentQueryResult, {\\n                            mutationResult: result,\\n                            queryName: (document && getOperationName(document)) || void 0,\\n                            queryVariables: variables,\\n                        });\\n                        // Write the modified result back into the store if we got a new result.\\n                        if (nextQueryResult) {\\n                            cacheWrites.push({\\n                                result: nextQueryResult,\\n                                dataId: \\\"ROOT_QUERY\\\",\\n                                query: document,\\n                                variables: variables,\\n                            });\\n                        }\\n                    }\\n                });\\n            }\\n        }\\n        if (cacheWrites.length > 0 ||\\n            (mutation.refetchQueries || \\\"\\\").length > 0 ||\\n            mutation.update ||\\n            mutation.onQueryUpdated ||\\n            mutation.removeOptimistic) {\\n            var results_1 = [];\\n            this.refetchQueries({\\n                updateCache: function (cache) {\\n                    if (!skipCache) {\\n                        cacheWrites.forEach(function (write) { return cache.write(write); });\\n                    }\\n                    // If the mutation has some writes associated with it then we need to\\n                    // apply those writes to the store by running this reducer again with\\n                    // a write action.\\n                    var update = mutation.update;\\n                    // Determine whether result is a SingleExecutionResult,\\n                    // or the final ExecutionPatchResult.\\n                    var isFinalResult = !isExecutionPatchResult(result) ||\\n                        (isExecutionPatchIncrementalResult(result) && !result.hasNext);\\n                    if (update) {\\n                        if (!skipCache) {\\n                            // Re-read the ROOT_MUTATION data we just wrote into the cache\\n                            // (the first cache.write call in the cacheWrites.forEach loop\\n                            // above), so field read functions have a chance to run for\\n                            // fields within mutation result objects.\\n                            var diff = cache.diff({\\n                                id: \\\"ROOT_MUTATION\\\",\\n                                // The cache complains if passed a mutation where it expects a\\n                                // query, so we transform mutations and subscriptions to queries\\n                                // (only once, thanks to this.transformCache).\\n                                query: _this.getDocumentInfo(mutation.document).asQuery,\\n                                variables: mutation.variables,\\n                                optimistic: false,\\n                                returnPartialData: true,\\n                            });\\n                            if (diff.complete) {\\n                                result = __assign(__assign({}, result), { data: diff.result });\\n                                if (\\\"incremental\\\" in result) {\\n                                    delete result.incremental;\\n                                }\\n                                if (\\\"hasNext\\\" in result) {\\n                                    delete result.hasNext;\\n                                }\\n                            }\\n                        }\\n                        // If we've received the whole response,\\n                        // either a SingleExecutionResult or the final ExecutionPatchResult,\\n                        // call the update function.\\n                        if (isFinalResult) {\\n                            update(cache, result, {\\n                                context: mutation.context,\\n                                variables: mutation.variables,\\n                            });\\n                        }\\n                    }\\n                    // TODO Do this with cache.evict({ id: 'ROOT_MUTATION' }) but make it\\n                    // shallow to allow rolling back optimistic evictions.\\n                    if (!skipCache && !mutation.keepRootFields && isFinalResult) {\\n                        cache.modify({\\n                            id: \\\"ROOT_MUTATION\\\",\\n                            fields: function (value, _a) {\\n                                var fieldName = _a.fieldName, DELETE = _a.DELETE;\\n                                return fieldName === \\\"__typename\\\" ? value : DELETE;\\n                            },\\n                        });\\n                    }\\n                },\\n                include: mutation.refetchQueries,\\n                // Write the final mutation.result to the root layer of the cache.\\n                optimistic: false,\\n                // Remove the corresponding optimistic layer at the same time as we\\n                // write the final non-optimistic result.\\n                removeOptimistic: mutation.removeOptimistic,\\n                // Let the caller of client.mutate optionally determine the refetching\\n                // behavior for watched queries after the mutation.update function runs.\\n                // If no onQueryUpdated function was provided for this mutation, pass\\n                // null instead of undefined to disable the default refetching behavior.\\n                onQueryUpdated: mutation.onQueryUpdated || null,\\n            }).forEach(function (result) { return results_1.push(result); });\\n            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\\n                // Returning a promise here makes the mutation await that promise, so we\\n                // include results in that promise's work if awaitRefetchQueries or an\\n                // onQueryUpdated function was specified.\\n                return Promise.all(results_1).then(function () { return result; });\\n            }\\n        }\\n        return Promise.resolve(result);\\n    };\\n    QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\\n        var _this = this;\\n        var data = typeof optimisticResponse === \\\"function\\\" ?\\n            optimisticResponse(mutation.variables, { IGNORE: IGNORE })\\n            : optimisticResponse;\\n        if (data === IGNORE) {\\n            return false;\\n        }\\n        this.cache.recordOptimisticTransaction(function (cache) {\\n            try {\\n                _this.markMutationResult(__assign(__assign({}, mutation), { result: { data: data } }), cache);\\n            }\\n            catch (error) {\\n                globalThis.__DEV__ !== false && invariant.error(error);\\n            }\\n        }, mutation.mutationId);\\n        return true;\\n    };\\n    QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\\n        return this.fetchConcastWithInfo(queryId, options, networkStatus).concast\\n            .promise;\\n    };\\n    QueryManager.prototype.getQueryStore = function () {\\n        var store = Object.create(null);\\n        this.queries.forEach(function (info, queryId) {\\n            store[queryId] = {\\n                variables: info.variables,\\n                networkStatus: info.networkStatus,\\n                networkError: info.networkError,\\n                graphQLErrors: info.graphQLErrors,\\n            };\\n        });\\n        return store;\\n    };\\n    QueryManager.prototype.resetErrors = function (queryId) {\\n        var queryInfo = this.queries.get(queryId);\\n        if (queryInfo) {\\n            queryInfo.networkError = undefined;\\n            queryInfo.graphQLErrors = [];\\n        }\\n    };\\n    QueryManager.prototype.transform = function (document) {\\n        return this.documentTransform.transformDocument(document);\\n    };\\n    QueryManager.prototype.getDocumentInfo = function (document) {\\n        var transformCache = this.transformCache;\\n        if (!transformCache.has(document)) {\\n            var cacheEntry = {\\n                // TODO These three calls (hasClientExports, shouldForceResolvers, and\\n                // usesNonreactiveDirective) are performing independent full traversals\\n                // of the transformed document. We should consider merging these\\n                // traversals into a single pass in the future, though the work is\\n                // cached after the first time.\\n                hasClientExports: hasClientExports(document),\\n                hasForcedResolvers: this.localState.shouldForceResolvers(document),\\n                hasNonreactiveDirective: hasDirectives([\\\"nonreactive\\\"], document),\\n                clientQuery: this.localState.clientQuery(document),\\n                serverQuery: removeDirectivesFromDocument([\\n                    { name: \\\"client\\\", remove: true },\\n                    { name: \\\"connection\\\" },\\n                    { name: \\\"nonreactive\\\" },\\n                ], document),\\n                defaultVars: getDefaultValues(getOperationDefinition(document)),\\n                // Transform any mutation or subscription operations to query operations\\n                // so we can read/write them from/to the cache.\\n                asQuery: __assign(__assign({}, document), { definitions: document.definitions.map(function (def) {\\n                        if (def.kind === \\\"OperationDefinition\\\" &&\\n                            def.operation !== \\\"query\\\") {\\n                            return __assign(__assign({}, def), { operation: \\\"query\\\" });\\n                        }\\n                        return def;\\n                    }) }),\\n            };\\n            transformCache.set(document, cacheEntry);\\n        }\\n        return transformCache.get(document);\\n    };\\n    QueryManager.prototype.getVariables = function (document, variables) {\\n        return __assign(__assign({}, this.getDocumentInfo(document).defaultVars), variables);\\n    };\\n    QueryManager.prototype.watchQuery = function (options) {\\n        var query = this.transform(options.query);\\n        // assign variable default values if supplied\\n        // NOTE: We don't modify options.query here with the transformed query to\\n        // ensure observable.options.query is set to the raw untransformed query.\\n        options = __assign(__assign({}, options), { variables: this.getVariables(query, options.variables) });\\n        if (typeof options.notifyOnNetworkStatusChange === \\\"undefined\\\") {\\n            options.notifyOnNetworkStatusChange = false;\\n        }\\n        var queryInfo = new QueryInfo(this);\\n        var observable = new ObservableQuery({\\n            queryManager: this,\\n            queryInfo: queryInfo,\\n            options: options,\\n        });\\n        observable[\\\"lastQuery\\\"] = query;\\n        this.queries.set(observable.queryId, queryInfo);\\n        // We give queryInfo the transformed query to ensure the first cache diff\\n        // uses the transformed query instead of the raw query\\n        queryInfo.init({\\n            document: query,\\n            observableQuery: observable,\\n            variables: observable.variables,\\n        });\\n        return observable;\\n    };\\n    QueryManager.prototype.query = function (options, queryId) {\\n        var _this = this;\\n        if (queryId === void 0) { queryId = this.generateQueryId(); }\\n        invariant(options.query, 28);\\n        invariant(options.query.kind === \\\"Document\\\", 29);\\n        invariant(!options.returnPartialData, 30);\\n        invariant(!options.pollInterval, 31);\\n        return this.fetchQuery(queryId, __assign(__assign({}, options), { query: this.transform(options.query) })).finally(function () { return _this.stopQuery(queryId); });\\n    };\\n    QueryManager.prototype.generateQueryId = function () {\\n        return String(this.queryIdCounter++);\\n    };\\n    QueryManager.prototype.generateRequestId = function () {\\n        return this.requestIdCounter++;\\n    };\\n    QueryManager.prototype.generateMutationId = function () {\\n        return String(this.mutationIdCounter++);\\n    };\\n    QueryManager.prototype.stopQueryInStore = function (queryId) {\\n        this.stopQueryInStoreNoBroadcast(queryId);\\n        this.broadcastQueries();\\n    };\\n    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\\n        var queryInfo = this.queries.get(queryId);\\n        if (queryInfo)\\n            queryInfo.stop();\\n    };\\n    QueryManager.prototype.clearStore = function (options) {\\n        if (options === void 0) { options = {\\n            discardWatches: true,\\n        }; }\\n        // Before we have sent the reset action to the store, we can no longer\\n        // rely on the results returned by in-flight requests since these may\\n        // depend on values that previously existed in the data portion of the\\n        // store. So, we cancel the promises and observers that we have issued\\n        // so far and not yet resolved (in the case of queries).\\n        this.cancelPendingFetches(newInvariantError(32));\\n        this.queries.forEach(function (queryInfo) {\\n            if (queryInfo.observableQuery) {\\n                // Set loading to true so listeners don't trigger unless they want\\n                // results with partial data.\\n                queryInfo.networkStatus = NetworkStatus.loading;\\n            }\\n            else {\\n                queryInfo.stop();\\n            }\\n        });\\n        if (this.mutationStore) {\\n            this.mutationStore = Object.create(null);\\n        }\\n        // begin removing data from the store\\n        return this.cache.reset(options);\\n    };\\n    QueryManager.prototype.getObservableQueries = function (include) {\\n        var _this = this;\\n        if (include === void 0) { include = \\\"active\\\"; }\\n        var queries = new Map();\\n        var queryNamesAndDocs = new Map();\\n        var legacyQueryOptions = new Set();\\n        if (Array.isArray(include)) {\\n            include.forEach(function (desc) {\\n                if (typeof desc === \\\"string\\\") {\\n                    queryNamesAndDocs.set(desc, false);\\n                }\\n                else if (isDocumentNode(desc)) {\\n                    queryNamesAndDocs.set(_this.transform(desc), false);\\n                }\\n                else if (isNonNullObject(desc) && desc.query) {\\n                    legacyQueryOptions.add(desc);\\n                }\\n            });\\n        }\\n        this.queries.forEach(function (_a, queryId) {\\n            var oq = _a.observableQuery, document = _a.document;\\n            if (oq) {\\n                if (include === \\\"all\\\") {\\n                    queries.set(queryId, oq);\\n                    return;\\n                }\\n                var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;\\n                if (fetchPolicy === \\\"standby\\\" ||\\n                    (include === \\\"active\\\" && !oq.hasObservers())) {\\n                    return;\\n                }\\n                if (include === \\\"active\\\" ||\\n                    (queryName && queryNamesAndDocs.has(queryName)) ||\\n                    (document && queryNamesAndDocs.has(document))) {\\n                    queries.set(queryId, oq);\\n                    if (queryName)\\n                        queryNamesAndDocs.set(queryName, true);\\n                    if (document)\\n                        queryNamesAndDocs.set(document, true);\\n                }\\n            }\\n        });\\n        if (legacyQueryOptions.size) {\\n            legacyQueryOptions.forEach(function (options) {\\n                // We will be issuing a fresh network request for this query, so we\\n                // pre-allocate a new query ID here, using a special prefix to enable\\n                // cleaning up these temporary queries later, after fetching.\\n                var queryId = makeUniqueId(\\\"legacyOneTimeQuery\\\");\\n                var queryInfo = _this.getQuery(queryId).init({\\n                    document: options.query,\\n                    variables: options.variables,\\n                });\\n                var oq = new ObservableQuery({\\n                    queryManager: _this,\\n                    queryInfo: queryInfo,\\n                    options: __assign(__assign({}, options), { fetchPolicy: \\\"network-only\\\" }),\\n                });\\n                invariant(oq.queryId === queryId);\\n                queryInfo.setObservableQuery(oq);\\n                queries.set(queryId, oq);\\n            });\\n        }\\n        if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {\\n            queryNamesAndDocs.forEach(function (included, nameOrDoc) {\\n                if (!included) {\\n                    globalThis.__DEV__ !== false && invariant.warn(typeof nameOrDoc === \\\"string\\\" ? 33 : 34, nameOrDoc);\\n                }\\n            });\\n        }\\n        return queries;\\n    };\\n    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\\n        var _this = this;\\n        if (includeStandby === void 0) { includeStandby = false; }\\n        var observableQueryPromises = [];\\n        this.getObservableQueries(includeStandby ? \\\"all\\\" : \\\"active\\\").forEach(function (observableQuery, queryId) {\\n            var fetchPolicy = observableQuery.options.fetchPolicy;\\n            observableQuery.resetLastResults();\\n            if (includeStandby ||\\n                (fetchPolicy !== \\\"standby\\\" && fetchPolicy !== \\\"cache-only\\\")) {\\n                observableQueryPromises.push(observableQuery.refetch());\\n            }\\n            _this.getQuery(queryId).setDiff(null);\\n        });\\n        this.broadcastQueries();\\n        return Promise.all(observableQueryPromises);\\n    };\\n    QueryManager.prototype.setObservableQuery = function (observableQuery) {\\n        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\\n    };\\n    QueryManager.prototype.startGraphQLSubscription = function (_a) {\\n        var _this = this;\\n        var query = _a.query, fetchPolicy = _a.fetchPolicy, _b = _a.errorPolicy, errorPolicy = _b === void 0 ? \\\"none\\\" : _b, variables = _a.variables, _c = _a.context, context = _c === void 0 ? {} : _c;\\n        query = this.transform(query);\\n        variables = this.getVariables(query, variables);\\n        var makeObservable = function (variables) {\\n            return _this.getObservableFromLink(query, context, variables).map(function (result) {\\n                if (fetchPolicy !== \\\"no-cache\\\") {\\n                    // the subscription interface should handle not sending us results we no longer subscribe to.\\n                    // XXX I don't think we ever send in an object with errors, but we might in the future...\\n                    if (shouldWriteResult(result, errorPolicy)) {\\n                        _this.cache.write({\\n                            query: query,\\n                            result: result.data,\\n                            dataId: \\\"ROOT_SUBSCRIPTION\\\",\\n                            variables: variables,\\n                        });\\n                    }\\n                    _this.broadcastQueries();\\n                }\\n                var hasErrors = graphQLResultHasError(result);\\n                var hasProtocolErrors = graphQLResultHasProtocolErrors(result);\\n                if (hasErrors || hasProtocolErrors) {\\n                    var errors = {};\\n                    if (hasErrors) {\\n                        errors.graphQLErrors = result.errors;\\n                    }\\n                    if (hasProtocolErrors) {\\n                        errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];\\n                    }\\n                    // `errorPolicy` is a mechanism for handling GraphQL errors, according\\n                    // to our documentation, so we throw protocol errors regardless of the\\n                    // set error policy.\\n                    if (errorPolicy === \\\"none\\\" || hasProtocolErrors) {\\n                        throw new ApolloError(errors);\\n                    }\\n                }\\n                if (errorPolicy === \\\"ignore\\\") {\\n                    delete result.errors;\\n                }\\n                return result;\\n            });\\n        };\\n        if (this.getDocumentInfo(query).hasClientExports) {\\n            var observablePromise_1 = this.localState\\n                .addExportedVariables(query, variables, context)\\n                .then(makeObservable);\\n            return new Observable(function (observer) {\\n                var sub = null;\\n                observablePromise_1.then(function (observable) { return (sub = observable.subscribe(observer)); }, observer.error);\\n                return function () { return sub && sub.unsubscribe(); };\\n            });\\n        }\\n        return makeObservable(variables);\\n    };\\n    QueryManager.prototype.stopQuery = function (queryId) {\\n        this.stopQueryNoBroadcast(queryId);\\n        this.broadcastQueries();\\n    };\\n    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\\n        this.stopQueryInStoreNoBroadcast(queryId);\\n        this.removeQuery(queryId);\\n    };\\n    QueryManager.prototype.removeQuery = function (queryId) {\\n        // teardown all links\\n        // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\\n        // that each add their reject functions to fetchCancelFns.\\n        // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\\n        // The same queryId could have two rejection fns for two promises\\n        this.fetchCancelFns.delete(queryId);\\n        if (this.queries.has(queryId)) {\\n            this.getQuery(queryId).stop();\\n            this.queries.delete(queryId);\\n        }\\n    };\\n    QueryManager.prototype.broadcastQueries = function () {\\n        if (this.onBroadcast)\\n            this.onBroadcast();\\n        this.queries.forEach(function (info) { return info.notify(); });\\n    };\\n    QueryManager.prototype.getLocalState = function () {\\n        return this.localState;\\n    };\\n    QueryManager.prototype.getObservableFromLink = function (query, context, variables, \\n    // Prefer context.queryDeduplication if specified.\\n    deduplication) {\\n        var _this = this;\\n        var _a;\\n        if (deduplication === void 0) { deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication; }\\n        var observable;\\n        var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;\\n        if (serverQuery) {\\n            var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;\\n            var operation = {\\n                query: serverQuery,\\n                variables: variables,\\n                operationName: getOperationName(serverQuery) || void 0,\\n                context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),\\n            };\\n            context = operation.context;\\n            if (deduplication) {\\n                var printedServerQuery_1 = print(serverQuery);\\n                var varJson_1 = canonicalStringify(variables);\\n                var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);\\n                observable = entry.observable;\\n                if (!observable) {\\n                    var concast = new Concast([\\n                        execute(link, operation),\\n                    ]);\\n                    observable = entry.observable = concast;\\n                    concast.beforeNext(function () {\\n                        inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);\\n                    });\\n                }\\n            }\\n            else {\\n                observable = new Concast([\\n                    execute(link, operation),\\n                ]);\\n            }\\n        }\\n        else {\\n            observable = new Concast([Observable.of({ data: {} })]);\\n            context = this.prepareContext(context);\\n        }\\n        if (clientQuery) {\\n            observable = asyncMap(observable, function (result) {\\n                return _this.localState.runResolvers({\\n                    document: clientQuery,\\n                    remoteResult: result,\\n                    context: context,\\n                    variables: variables,\\n                });\\n            });\\n        }\\n        return observable;\\n    };\\n    QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\\n        var requestId = (queryInfo.lastRequestId = this.generateRequestId());\\n        // Performing transformForLink here gives this.cache a chance to fill in\\n        // missing fragment definitions (for example) before sending this document\\n        // through the link chain.\\n        var linkDocument = this.cache.transformForLink(options.query);\\n        return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\\n            var graphQLErrors = getGraphQLErrorsFromResult(result);\\n            var hasErrors = graphQLErrors.length > 0;\\n            // If we interrupted this request by calling getResultsFromLink again\\n            // with the same QueryInfo object, we ignore the old results.\\n            if (requestId >= queryInfo.lastRequestId) {\\n                if (hasErrors && options.errorPolicy === \\\"none\\\") {\\n                    // Throwing here effectively calls observer.error.\\n                    throw queryInfo.markError(new ApolloError({\\n                        graphQLErrors: graphQLErrors,\\n                    }));\\n                }\\n                // Use linkDocument rather than queryInfo.document so the\\n                // operation/fragments used to write the result are the same as the\\n                // ones used to obtain it from the link.\\n                queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\\n                queryInfo.markReady();\\n            }\\n            var aqr = {\\n                data: result.data,\\n                loading: false,\\n                networkStatus: NetworkStatus.ready,\\n            };\\n            if (hasErrors && options.errorPolicy !== \\\"ignore\\\") {\\n                aqr.errors = graphQLErrors;\\n                aqr.networkStatus = NetworkStatus.error;\\n            }\\n            return aqr;\\n        }, function (networkError) {\\n            var error = isApolloError(networkError) ? networkError : (new ApolloError({ networkError: networkError }));\\n            // Avoid storing errors from older interrupted queries.\\n            if (requestId >= queryInfo.lastRequestId) {\\n                queryInfo.markError(error);\\n            }\\n            throw error;\\n        });\\n    };\\n    QueryManager.prototype.fetchConcastWithInfo = function (queryId, options, \\n    // The initial networkStatus for this fetch, most often\\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\\n    // or setVariables.\\n    networkStatus, query) {\\n        var _this = this;\\n        if (networkStatus === void 0) { networkStatus = NetworkStatus.loading; }\\n        if (query === void 0) { query = options.query; }\\n        var variables = this.getVariables(query, options.variables);\\n        var queryInfo = this.getQuery(queryId);\\n        var defaults = this.defaultOptions.watchQuery;\\n        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? (defaults && defaults.fetchPolicy) || \\\"cache-first\\\" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? (defaults && defaults.errorPolicy) || \\\"none\\\" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;\\n        var normalized = Object.assign({}, options, {\\n            query: query,\\n            variables: variables,\\n            fetchPolicy: fetchPolicy,\\n            errorPolicy: errorPolicy,\\n            returnPartialData: returnPartialData,\\n            notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\\n            context: context,\\n        });\\n        var fromVariables = function (variables) {\\n            // Since normalized is always a fresh copy of options, it's safe to\\n            // modify its properties here, rather than creating yet another new\\n            // WatchQueryOptions object.\\n            normalized.variables = variables;\\n            var sourcesWithInfo = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\\n            if (\\n            // If we're in standby, postpone advancing options.fetchPolicy using\\n            // applyNextFetchPolicy.\\n            normalized.fetchPolicy !== \\\"standby\\\" &&\\n                // The \\\"standby\\\" policy currently returns [] from fetchQueryByPolicy, so\\n                // this is another way to detect when nothing was done/fetched.\\n                sourcesWithInfo.sources.length > 0 &&\\n                queryInfo.observableQuery) {\\n                queryInfo.observableQuery[\\\"applyNextFetchPolicy\\\"](\\\"after-fetch\\\", options);\\n            }\\n            return sourcesWithInfo;\\n        };\\n        // This cancel function needs to be set before the concast is created,\\n        // in case concast creation synchronously cancels the request.\\n        var cleanupCancelFn = function () { return _this.fetchCancelFns.delete(queryId); };\\n        this.fetchCancelFns.set(queryId, function (reason) {\\n            cleanupCancelFn();\\n            // This delay ensures the concast variable has been initialized.\\n            setTimeout(function () { return concast.cancel(reason); });\\n        });\\n        var concast, containsDataFromLink;\\n        // If the query has @export(as: ...) directives, then we need to\\n        // process those directives asynchronously. When there are no\\n        // @export directives (the common case), we deliberately avoid\\n        // wrapping the result of this.fetchQueryByPolicy in a Promise,\\n        // since the timing of result delivery is (unfortunately) important\\n        // for backwards compatibility. TODO This code could be simpler if\\n        // we deprecated and removed LocalState.\\n        if (this.getDocumentInfo(normalized.query).hasClientExports) {\\n            concast = new Concast(this.localState\\n                .addExportedVariables(normalized.query, normalized.variables, normalized.context)\\n                .then(fromVariables)\\n                .then(function (sourcesWithInfo) { return sourcesWithInfo.sources; }));\\n            // there is just no way we can synchronously get the *right* value here,\\n            // so we will assume `true`, which is the behaviour before the bug fix in\\n            // #10597. This means that bug is not fixed in that case, and is probably\\n            // un-fixable with reasonable effort for the edge case of @export as\\n            // directives.\\n            containsDataFromLink = true;\\n        }\\n        else {\\n            var sourcesWithInfo = fromVariables(normalized.variables);\\n            containsDataFromLink = sourcesWithInfo.fromLink;\\n            concast = new Concast(sourcesWithInfo.sources);\\n        }\\n        concast.promise.then(cleanupCancelFn, cleanupCancelFn);\\n        return {\\n            concast: concast,\\n            fromLink: containsDataFromLink,\\n        };\\n    };\\n    QueryManager.prototype.refetchQueries = function (_a) {\\n        var _this = this;\\n        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId(\\\"refetchQueries\\\") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;\\n        var includedQueriesById = new Map();\\n        if (include) {\\n            this.getObservableQueries(include).forEach(function (oq, queryId) {\\n                includedQueriesById.set(queryId, {\\n                    oq: oq,\\n                    lastDiff: _this.getQuery(queryId).getDiff(),\\n                });\\n            });\\n        }\\n        var results = new Map();\\n        if (updateCache) {\\n            this.cache.batch({\\n                update: updateCache,\\n                // Since you can perform any combination of cache reads and/or writes in\\n                // the cache.batch update function, its optimistic option can be either\\n                // a boolean or a string, representing three distinct modes of\\n                // operation:\\n                //\\n                // * false: read/write only the root layer\\n                // * true: read/write the topmost layer\\n                // * string: read/write a fresh optimistic layer with that ID string\\n                //\\n                // When typeof optimistic === \\\"string\\\", a new optimistic layer will be\\n                // temporarily created within cache.batch with that string as its ID. If\\n                // we then pass that same string as the removeOptimistic option, we can\\n                // make cache.batch immediately remove the optimistic layer after\\n                // running the updateCache function, triggering only one broadcast.\\n                //\\n                // However, the refetchQueries method accepts only true or false for its\\n                // optimistic option (not string). We interpret true to mean a temporary\\n                // optimistic layer should be created, to allow efficiently rolling back\\n                // the effect of the updateCache function, which involves passing a\\n                // string instead of true as the optimistic option to cache.batch, when\\n                // refetchQueries receives optimistic: true.\\n                //\\n                // In other words, we are deliberately not supporting the use case of\\n                // writing to an *existing* optimistic layer (using the refetchQueries\\n                // updateCache function), since that would potentially interfere with\\n                // other optimistic updates in progress. Instead, you can read/write\\n                // only the root layer by passing optimistic: false to refetchQueries,\\n                // or you can read/write a brand new optimistic layer that will be\\n                // automatically removed by passing optimistic: true.\\n                optimistic: (optimistic && removeOptimistic) || false,\\n                // The removeOptimistic option can also be provided by itself, even if\\n                // optimistic === false, to remove some previously-added optimistic\\n                // layer safely and efficiently, like we do in markMutationResult.\\n                //\\n                // If an explicit removeOptimistic string is provided with optimistic:\\n                // true, the removeOptimistic string will determine the ID of the\\n                // temporary optimistic layer, in case that ever matters.\\n                removeOptimistic: removeOptimistic,\\n                onWatchUpdated: function (watch, diff, lastDiff) {\\n                    var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;\\n                    if (oq) {\\n                        if (onQueryUpdated) {\\n                            // Since we're about to handle this query now, remove it from\\n                            // includedQueriesById, in case it was added earlier because of\\n                            // options.include.\\n                            includedQueriesById.delete(oq.queryId);\\n                            var result = onQueryUpdated(oq, diff, lastDiff);\\n                            if (result === true) {\\n                                // The onQueryUpdated function requested the default refetching\\n                                // behavior by returning true.\\n                                result = oq.refetch();\\n                            }\\n                            // Record the result in the results Map, as long as onQueryUpdated\\n                            // did not return false to skip/ignore this result.\\n                            if (result !== false) {\\n                                results.set(oq, result);\\n                            }\\n                            // Allow the default cache broadcast to happen, except when\\n                            // onQueryUpdated returns false.\\n                            return result;\\n                        }\\n                        if (onQueryUpdated !== null) {\\n                            // If we don't have an onQueryUpdated function, and onQueryUpdated\\n                            // was not disabled by passing null, make sure this query is\\n                            // \\\"included\\\" like any other options.include-specified query.\\n                            includedQueriesById.set(oq.queryId, { oq: oq, lastDiff: lastDiff, diff: diff });\\n                        }\\n                    }\\n                },\\n            });\\n        }\\n        if (includedQueriesById.size) {\\n            includedQueriesById.forEach(function (_a, queryId) {\\n                var oq = _a.oq, lastDiff = _a.lastDiff, diff = _a.diff;\\n                var result;\\n                // If onQueryUpdated is provided, we want to use it for all included\\n                // queries, even the QueryOptions ones.\\n                if (onQueryUpdated) {\\n                    if (!diff) {\\n                        var info = oq[\\\"queryInfo\\\"];\\n                        info.reset(); // Force info.getDiff() to read from cache.\\n                        diff = info.getDiff();\\n                    }\\n                    result = onQueryUpdated(oq, diff, lastDiff);\\n                }\\n                // Otherwise, we fall back to refetching.\\n                if (!onQueryUpdated || result === true) {\\n                    result = oq.refetch();\\n                }\\n                if (result !== false) {\\n                    results.set(oq, result);\\n                }\\n                if (queryId.indexOf(\\\"legacyOneTimeQuery\\\") >= 0) {\\n                    _this.stopQueryNoBroadcast(queryId);\\n                }\\n            });\\n        }\\n        if (removeOptimistic) {\\n            // In case no updateCache callback was provided (so cache.batch was not\\n            // called above, and thus did not already remove the optimistic layer),\\n            // remove it here. Since this is a no-op when the layer has already been\\n            // removed, we do it even if we called cache.batch above, since it's\\n            // possible this.cache is an instance of some ApolloCache subclass other\\n            // than InMemoryCache, and does not fully support the removeOptimistic\\n            // option for cache.batch.\\n            this.cache.removeOptimistic(removeOptimistic);\\n        }\\n        return results;\\n    };\\n    QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, \\n    // The initial networkStatus for this fetch, most often\\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\\n    // or setVariables.\\n    networkStatus) {\\n        var _this = this;\\n        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\\n        var oldNetworkStatus = queryInfo.networkStatus;\\n        queryInfo.init({\\n            document: query,\\n            variables: variables,\\n            networkStatus: networkStatus,\\n        });\\n        var readCache = function () { return queryInfo.getDiff(); };\\n        var resultsFromCache = function (diff, networkStatus) {\\n            if (networkStatus === void 0) { networkStatus = queryInfo.networkStatus || NetworkStatus.loading; }\\n            var data = diff.result;\\n            if (globalThis.__DEV__ !== false && !returnPartialData && !equal(data, {})) {\\n                logMissingFieldErrors(diff.missing);\\n            }\\n            var fromData = function (data) {\\n                return Observable.of(__assign({ data: data, loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus }, (diff.complete ? null : { partial: true })));\\n            };\\n            if (data && _this.getDocumentInfo(query).hasForcedResolvers) {\\n                return _this.localState\\n                    .runResolvers({\\n                    document: query,\\n                    remoteResult: { data: data },\\n                    context: context,\\n                    variables: variables,\\n                    onlyRunForcedResolvers: true,\\n                })\\n                    .then(function (resolved) { return fromData(resolved.data || void 0); });\\n            }\\n            // Resolves https://github.com/apollographql/apollo-client/issues/10317.\\n            // If errorPolicy is 'none' and notifyOnNetworkStatusChange is true,\\n            // data was incorrectly returned from the cache on refetch:\\n            // if diff.missing exists, we should not return cache data.\\n            if (errorPolicy === \\\"none\\\" &&\\n                networkStatus === NetworkStatus.refetch &&\\n                Array.isArray(diff.missing)) {\\n                return fromData(void 0);\\n            }\\n            return fromData(data);\\n        };\\n        var cacheWriteBehavior = fetchPolicy === \\\"no-cache\\\" ? 0 /* CacheWriteBehavior.FORBID */\\n            // Watched queries must opt into overwriting existing data on refetch,\\n            // by passing refetchWritePolicy: \\\"overwrite\\\" in their WatchQueryOptions.\\n            : (networkStatus === NetworkStatus.refetch &&\\n                refetchWritePolicy !== \\\"merge\\\") ?\\n                1 /* CacheWriteBehavior.OVERWRITE */\\n                : 2 /* CacheWriteBehavior.MERGE */;\\n        var resultsFromLink = function () {\\n            return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\\n                query: query,\\n                variables: variables,\\n                context: context,\\n                fetchPolicy: fetchPolicy,\\n                errorPolicy: errorPolicy,\\n            });\\n        };\\n        var shouldNotify = notifyOnNetworkStatusChange &&\\n            typeof oldNetworkStatus === \\\"number\\\" &&\\n            oldNetworkStatus !== networkStatus &&\\n            isNetworkRequestInFlight(networkStatus);\\n        switch (fetchPolicy) {\\n            default:\\n            case \\\"cache-first\\\": {\\n                var diff = readCache();\\n                if (diff.complete) {\\n                    return {\\n                        fromLink: false,\\n                        sources: [resultsFromCache(diff, queryInfo.markReady())],\\n                    };\\n                }\\n                if (returnPartialData || shouldNotify) {\\n                    return {\\n                        fromLink: true,\\n                        sources: [resultsFromCache(diff), resultsFromLink()],\\n                    };\\n                }\\n                return { fromLink: true, sources: [resultsFromLink()] };\\n            }\\n            case \\\"cache-and-network\\\": {\\n                var diff = readCache();\\n                if (diff.complete || returnPartialData || shouldNotify) {\\n                    return {\\n                        fromLink: true,\\n                        sources: [resultsFromCache(diff), resultsFromLink()],\\n                    };\\n                }\\n                return { fromLink: true, sources: [resultsFromLink()] };\\n            }\\n            case \\\"cache-only\\\":\\n                return {\\n                    fromLink: false,\\n                    sources: [resultsFromCache(readCache(), queryInfo.markReady())],\\n                };\\n            case \\\"network-only\\\":\\n                if (shouldNotify) {\\n                    return {\\n                        fromLink: true,\\n                        sources: [resultsFromCache(readCache()), resultsFromLink()],\\n                    };\\n                }\\n                return { fromLink: true, sources: [resultsFromLink()] };\\n            case \\\"no-cache\\\":\\n                if (shouldNotify) {\\n                    return {\\n                        fromLink: true,\\n                        // Note that queryInfo.getDiff() for no-cache queries does not call\\n                        // cache.diff, but instead returns a { complete: false } stub result\\n                        // when there is no queryInfo.diff already defined.\\n                        sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()],\\n                    };\\n                }\\n                return { fromLink: true, sources: [resultsFromLink()] };\\n            case \\\"standby\\\":\\n                return { fromLink: false, sources: [] };\\n        }\\n    };\\n    QueryManager.prototype.getQuery = function (queryId) {\\n        if (queryId && !this.queries.has(queryId)) {\\n            this.queries.set(queryId, new QueryInfo(this, queryId));\\n        }\\n        return this.queries.get(queryId);\\n    };\\n    QueryManager.prototype.prepareContext = function (context) {\\n        if (context === void 0) { context = {}; }\\n        var newContext = this.localState.prepareContext(context);\\n        return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });\\n    };\\n    return QueryManager;\\n}());\\nexport { QueryManager };\\n//# sourceMappingURL=QueryManager.js.map\"],\n  \"mappings\": \"AAAA,SAAS,UAAU,WAAW,mBAAmB;AACjD,SAAS,WAAW,yBAAyB;AAC7C,SAAS,aAAa;AACtB,SAAS,eAAe;AACxB,SAAS,eAAe,mCAAmC,wBAAwB,oCAAqC;AACxH,SAAS,0BAA0B;AACnC,SAAS,kBAAkB,wBAAwB,kBAAkB,kBAAkB,uBAAuB,4BAA4B,YAAY,UAAU,iBAAiB,SAAS,cAAc,gBAAgB,iBAAiB,yBAA0B;AACnQ,SAAS,4BAA4B;AACrC,SAAS,aAAa,eAAe,sCAAuC;AAC5E,SAAS,iBAAiB,6BAA6B;AACvD,SAAS,eAAe,gCAAgC;AACxD,SAAS,kBAAkB;AAC3B,SAAS,WAAW,yBAA0B;AAC9C,SAAS,8BAA8B;AACvC,SAAS,aAAa;AACtB,IAAI,iBAAiB,OAAO,UAAU;AACtC,IAAI,SAAS,uBAAO,OAAO,IAAI;AAC/B,SAAS,YAAY;AACrB,SAAS,sBAAsB,kBAAkB;AACjD,IAAI;AAAA;AAAA,EAA8B,WAAY;AAC1C,aAASA,cAAa,IAAI;AACtB,UAAI,QAAQ,GAAG,OAAO,OAAO,GAAG,MAAM,iBAAiB,GAAG,gBAAgB,oBAAoB,GAAG,mBAAmB,KAAK,GAAG,oBAAoB,qBAAqB,OAAO,SAAS,QAAQ,IAAI,cAAc,GAAG,aAAa,KAAK,GAAG,SAAS,UAAU,OAAO,SAAS,QAAQ,IAAI,KAAK,GAAG,iBAAiB,kBAAkB,OAAO,SAAS,CAAC,IAAI,IAAI,aAAa,GAAG,YAAY,KAAK,GAAG,wBAAwB,yBAAyB,OAAO,SAAS,CAAC,CAAC,MAAM,yBAAyB,IAAI,iBAAiB,GAAG;AACxf,UAAI,QAAQ;AACZ,WAAK,kBAAkB,CAAC;AAGxB,WAAK,UAAU,oBAAI,IAAI;AAKvB,WAAK,iBAAiB,oBAAI,IAAI;AAC9B,WAAK,iBAAiB,IAAI;AAAA,QAAqB,WAAW,8BAA8B,KACpF;AAAA;AAAA,MAA4D;AAChE,WAAK,iBAAiB;AACtB,WAAK,mBAAmB;AACxB,WAAK,oBAAoB;AAGzB,WAAK,0BAA0B,IAAI,KAAK,KAAK;AAC7C,UAAI,2BAA2B,IAAI;AAAA,QAAkB,SAAU,UAAU;AAAE,iBAAO,MAAM,MAAM,kBAAkB,QAAQ;AAAA,QAAG;AAAA;AAAA,QAE3H,EAAE,OAAO,MAAM;AAAA,MAAC;AAChB,WAAK,QAAQ;AACb,WAAK,OAAO;AACZ,WAAK,iBAAiB,kBAAkB,uBAAO,OAAO,IAAI;AAC1D,WAAK,qBAAqB;AAC1B,WAAK,kBAAkB;AACvB,WAAK,aAAa,cAAc,IAAI,WAAW,EAAE,MAAa,CAAC;AAC/D,WAAK,UAAU;AACf,WAAK,yBAAyB;AAC9B,WAAK,oBACD,oBACI,yBACK,OAAO,iBAAiB,EAKxB,OAAO,wBAAwB,IAClC;AACV,WAAK,iBAAiB,kBAAkB,uBAAO,OAAO,IAAI;AAC1D,UAAK,KAAK,cAAc,aAAc;AAClC,aAAK,gBAAgB,uBAAO,OAAO,IAAI;AAAA,MAC3C;AAAA,IACJ;AAKA,IAAAA,cAAa,UAAU,OAAO,WAAY;AACtC,UAAI,QAAQ;AACZ,WAAK,QAAQ,QAAQ,SAAU,OAAO,SAAS;AAC3C,cAAM,qBAAqB,OAAO;AAAA,MACtC,CAAC;AACD,WAAK,qBAAqB,kBAAkB,EAAE,CAAC;AAAA,IACnD;AACA,IAAAA,cAAa,UAAU,uBAAuB,SAAU,OAAO;AAC3D,WAAK,eAAe,QAAQ,SAAU,QAAQ;AAAE,eAAO,OAAO,KAAK;AAAA,MAAG,CAAC;AACvE,WAAK,eAAe,MAAM;AAAA,IAC9B;AACA,IAAAA,cAAa,UAAU,SAAS,SAAU,IAAI;AAC1C,UAAI,IAAI;AACR,UAAI,WAAW,GAAG,UAAU,YAAY,GAAG,WAAW,qBAAqB,GAAG,oBAAoB,gBAAgB,GAAG,eAAe,KAAK,GAAG,gBAAgB,iBAAiB,OAAO,SAAS,CAAC,IAAI,IAAI,KAAK,GAAG,qBAAqB,sBAAsB,OAAO,SAAS,QAAQ,IAAI,oBAAoB,GAAG,QAAQ,iBAAiB,GAAG,gBAAgB,KAAK,GAAG,aAAa,cAAc,OAAO,WAAW,KAAK,KAAK,eAAe,YAAY,QAAQ,OAAO,SAAS,SAAS,GAAG,gBAAgB,iBAAiB,IAAI,KAAK,GAAG,aAAa,cAAc,OAAO,WAAW,KAAK,KAAK,eAAe,YAAY,QAAQ,OAAO,SAAS,SAAS,GAAG,gBAAgB,SAAS,IAAI,iBAAiB,GAAG,gBAAgB,UAAU,GAAG;AACvsB,aAAO,UAAU,MAAM,QAAQ,QAAQ,WAAY;AAC/C,YAAI,YAAYC,mBAAkB,oBAAoB,cAAc;AACpE,eAAO,YAAY,MAAM,SAAU,IAAI;AACnC,kBAAQ,GAAG,OAAO;AAAA,YACd,KAAK;AACD,wBAAU,UAAU,EAAE;AACtB,wBAAU,gBAAgB,kBAAkB,gBAAgB,YAAY,EAAE;AAC1E,2BAAa,KAAK,mBAAmB;AACrC,yBAAW,KAAK,MAAM,iBAAiB,KAAK,UAAU,QAAQ,CAAC;AAC/D,cAAAA,oBAAmB,KAAK,gBAAgB,QAAQ,EAAE;AAClD,0BAAY,KAAK,aAAa,UAAU,SAAS;AACjD,kBAAI,CAACA;AAAkB,uBAAO,CAAC,GAAa,CAAC;AAC7C,qBAAO,CAAC,GAAa,KAAK,WAAW,qBAAqB,UAAU,WAAW,OAAO,CAAC;AAAA,YAC3F,KAAK;AACD,0BAAa,GAAG,KAAK;AACrB,iBAAG,QAAQ;AAAA,YACf,KAAK;AACD,mCAAqB,KAAK,kBACrB,KAAK,cAAc,UAAU,IAAI;AAAA,gBAC9B;AAAA,gBACA;AAAA,gBACA,SAAS;AAAA,gBACT,OAAO;AAAA,cACX;AACJ,6BAAe,sBACX,KAAK,uBAAuB,oBAAoB;AAAA,gBAC5C;AAAA,gBACA,UAAU;AAAA,gBACV;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,QAAQ;AAAA,gBACR;AAAA,cACJ,CAAC;AACL,mBAAK,iBAAiB;AACtB,qBAAO;AACP,qBAAO,CAAC,GAAc,IAAI,QAAQ,SAAU,SAAS,QAAQ;AACrD,uBAAO,SAAS,KAAK,sBAAsB,UAAU,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,oBAAoB,eAAe,qBAAqB,OAAO,CAAC,GAAG,WAAW,KAAK,GAAG,SAAU,QAAQ;AAC3L,sBAAI,sBAAsB,MAAM,KAAK,gBAAgB,QAAQ;AACzD,0BAAM,IAAI,YAAY;AAAA,sBAClB,eAAe,2BAA2B,MAAM;AAAA,oBACpD,CAAC;AAAA,kBACL;AACA,sBAAI,oBAAoB;AACpB,uCAAmB,UAAU;AAC7B,uCAAmB,QAAQ;AAAA,kBAC/B;AACA,sBAAI,cAAc,SAAS,CAAC,GAAG,MAAM;AACrC,sBAAI,OAAO,mBAAmB,YAAY;AACtC,qCAAiB,eAAe,WAAW;AAAA,kBAC/C;AACA,sBAAI,gBAAgB,YAAY,sBAAsB,WAAW,GAAG;AAChE,2BAAO,YAAY;AAAA,kBACvB;AACA,yBAAO,KAAK,mBAAmB;AAAA,oBAC3B;AAAA,oBACA,QAAQ;AAAA,oBACR,UAAU;AAAA,oBACV;AAAA,oBACA;AAAA,oBACA;AAAA,oBACA;AAAA,oBACA,QAAQ;AAAA,oBACR;AAAA,oBACA;AAAA,oBACA;AAAA,oBACA,kBAAkB,eAAe,aAAa;AAAA,oBAC9C;AAAA,oBACA;AAAA,kBACJ,CAAC;AAAA,gBACL,CAAC,EAAE,UAAU;AAAA,kBACT,MAAM,SAAU,aAAa;AACzB,yBAAK,iBAAiB;AAMtB,wBAAI,EAAE,aAAa,gBAAgB,YAAY,YAAY,OAAO;AAC9D,8BAAQ,WAAW;AAAA,oBACvB;AAAA,kBACJ;AAAA,kBACA,OAAO,SAAU,KAAK;AAClB,wBAAI,oBAAoB;AACpB,yCAAmB,UAAU;AAC7B,yCAAmB,QAAQ;AAAA,oBAC/B;AACA,wBAAI,cAAc;AACd,2BAAK,MAAM,iBAAiB,UAAU;AAAA,oBAC1C;AACA,yBAAK,iBAAiB;AACtB,2BAAO,eAAe,cAAc,MAAO,IAAI,YAAY;AAAA,sBACvD,cAAc;AAAA,oBAClB,CAAC,CAAE;AAAA,kBACP;AAAA,gBACJ,CAAC;AAAA,cACL,CAAC,CAAC;AAAA,UACd;AAAA,QACJ,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACA,IAAAD,cAAa,UAAU,qBAAqB,SAAU,UAAU,OAAO;AACnE,UAAI,QAAQ;AACZ,UAAI,UAAU,QAAQ;AAAE,gBAAQ,KAAK;AAAA,MAAO;AAC5C,UAAI,SAAS,SAAS;AACtB,UAAI,cAAc,CAAC;AACnB,UAAI,YAAY,SAAS,gBAAgB;AACzC,UAAI,CAAC,aAAa,kBAAkB,QAAQ,SAAS,WAAW,GAAG;AAC/D,YAAI,CAAC,kCAAkC,MAAM,GAAG;AAC5C,sBAAY,KAAK;AAAA,YACb,QAAQ,OAAO;AAAA,YACf,QAAQ;AAAA,YACR,OAAO,SAAS;AAAA,YAChB,WAAW,SAAS;AAAA,UACxB,CAAC;AAAA,QACL;AACA,YAAI,kCAAkC,MAAM,KACxC,gBAAgB,OAAO,WAAW,GAAG;AACrC,cAAI,OAAO,MAAM,KAAK;AAAA,YAClB,IAAI;AAAA;AAAA;AAAA;AAAA,YAIJ,OAAO,KAAK,gBAAgB,SAAS,QAAQ,EAAE;AAAA,YAC/C,WAAW,SAAS;AAAA,YACpB,YAAY;AAAA,YACZ,mBAAmB;AAAA,UACvB,CAAC;AACD,cAAI,aAAa;AACjB,cAAI,KAAK,QAAQ;AACb,yBAAa,qBAAqB,KAAK,QAAQ,MAAM;AAAA,UACzD;AACA,cAAI,OAAO,eAAe,aAAa;AAGnC,mBAAO,OAAO;AACd,wBAAY,KAAK;AAAA,cACb,QAAQ;AAAA,cACR,QAAQ;AAAA,cACR,OAAO,SAAS;AAAA,cAChB,WAAW,SAAS;AAAA,YACxB,CAAC;AAAA,UACL;AAAA,QACJ;AACA,YAAI,kBAAkB,SAAS;AAC/B,YAAI,iBAAiB;AACjB,eAAK,QAAQ,QAAQ,SAAU,IAAI,SAAS;AACxC,gBAAI,kBAAkB,GAAG;AACzB,gBAAI,YAAY,mBAAmB,gBAAgB;AACnD,gBAAI,CAAC,aAAa,CAAC,eAAe,KAAK,iBAAiB,SAAS,GAAG;AAChE;AAAA,YACJ;AACA,gBAAI,UAAU,gBAAgB,SAAS;AACvC,gBAAI,KAAK,MAAM,QAAQ,IAAI,OAAO,GAAG,WAAW,GAAG,UAAU,YAAY,GAAG;AAE5E,gBAAI,KAAK,MAAM,KAAK;AAAA,cAChB,OAAO;AAAA,cACP;AAAA,cACA,mBAAmB;AAAA,cACnB,YAAY;AAAA,YAChB,CAAC,GAAG,qBAAqB,GAAG,QAAQ,WAAW,GAAG;AAClD,gBAAI,YAAY,oBAAoB;AAEhC,kBAAI,kBAAkB,QAAQ,oBAAoB;AAAA,gBAC9C,gBAAgB;AAAA,gBAChB,WAAY,YAAY,iBAAiB,QAAQ,KAAM;AAAA,gBACvD,gBAAgB;AAAA,cACpB,CAAC;AAED,kBAAI,iBAAiB;AACjB,4BAAY,KAAK;AAAA,kBACb,QAAQ;AAAA,kBACR,QAAQ;AAAA,kBACR,OAAO;AAAA,kBACP;AAAA,gBACJ,CAAC;AAAA,cACL;AAAA,YACJ;AAAA,UACJ,CAAC;AAAA,QACL;AAAA,MACJ;AACA,UAAI,YAAY,SAAS,MACpB,SAAS,kBAAkB,IAAI,SAAS,KACzC,SAAS,UACT,SAAS,kBACT,SAAS,kBAAkB;AAC3B,YAAI,YAAY,CAAC;AACjB,aAAK,eAAe;AAAA,UAChB,aAAa,SAAUE,QAAO;AAC1B,gBAAI,CAAC,WAAW;AACZ,0BAAY,QAAQ,SAAU,OAAO;AAAE,uBAAOA,OAAM,MAAM,KAAK;AAAA,cAAG,CAAC;AAAA,YACvE;AAIA,gBAAI,SAAS,SAAS;AAGtB,gBAAI,gBAAgB,CAAC,uBAAuB,MAAM,KAC7C,kCAAkC,MAAM,KAAK,CAAC,OAAO;AAC1D,gBAAI,QAAQ;AACR,kBAAI,CAAC,WAAW;AAKZ,oBAAIC,QAAOD,OAAM,KAAK;AAAA,kBAClB,IAAI;AAAA;AAAA;AAAA;AAAA,kBAIJ,OAAO,MAAM,gBAAgB,SAAS,QAAQ,EAAE;AAAA,kBAChD,WAAW,SAAS;AAAA,kBACpB,YAAY;AAAA,kBACZ,mBAAmB;AAAA,gBACvB,CAAC;AACD,oBAAIC,MAAK,UAAU;AACf,2BAAS,SAAS,SAAS,CAAC,GAAG,MAAM,GAAG,EAAE,MAAMA,MAAK,OAAO,CAAC;AAC7D,sBAAI,iBAAiB,QAAQ;AACzB,2BAAO,OAAO;AAAA,kBAClB;AACA,sBAAI,aAAa,QAAQ;AACrB,2BAAO,OAAO;AAAA,kBAClB;AAAA,gBACJ;AAAA,cACJ;AAIA,kBAAI,eAAe;AACf,uBAAOD,QAAO,QAAQ;AAAA,kBAClB,SAAS,SAAS;AAAA,kBAClB,WAAW,SAAS;AAAA,gBACxB,CAAC;AAAA,cACL;AAAA,YACJ;AAGA,gBAAI,CAAC,aAAa,CAAC,SAAS,kBAAkB,eAAe;AACzD,cAAAA,OAAM,OAAO;AAAA,gBACT,IAAI;AAAA,gBACJ,QAAQ,SAAU,OAAO,IAAI;AACzB,sBAAI,YAAY,GAAG,WAAW,SAAS,GAAG;AAC1C,yBAAO,cAAc,eAAe,QAAQ;AAAA,gBAChD;AAAA,cACJ,CAAC;AAAA,YACL;AAAA,UACJ;AAAA,UACA,SAAS,SAAS;AAAA;AAAA,UAElB,YAAY;AAAA;AAAA;AAAA,UAGZ,kBAAkB,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA,UAK3B,gBAAgB,SAAS,kBAAkB;AAAA,QAC/C,CAAC,EAAE,QAAQ,SAAUE,SAAQ;AAAE,iBAAO,UAAU,KAAKA,OAAM;AAAA,QAAG,CAAC;AAC/D,YAAI,SAAS,uBAAuB,SAAS,gBAAgB;AAIzD,iBAAO,QAAQ,IAAI,SAAS,EAAE,KAAK,WAAY;AAAE,mBAAO;AAAA,UAAQ,CAAC;AAAA,QACrE;AAAA,MACJ;AACA,aAAO,QAAQ,QAAQ,MAAM;AAAA,IACjC;AACA,IAAAJ,cAAa,UAAU,yBAAyB,SAAU,oBAAoB,UAAU;AACpF,UAAI,QAAQ;AACZ,UAAI,OAAO,OAAO,uBAAuB,aACrC,mBAAmB,SAAS,WAAW,EAAE,OAAe,CAAC,IACvD;AACN,UAAI,SAAS,QAAQ;AACjB,eAAO;AAAA,MACX;AACA,WAAK,MAAM,4BAA4B,SAAU,OAAO;AACpD,YAAI;AACA,gBAAM,mBAAmB,SAAS,SAAS,CAAC,GAAG,QAAQ,GAAG,EAAE,QAAQ,EAAE,KAAW,EAAE,CAAC,GAAG,KAAK;AAAA,QAChG,SACO,OAAO;AACV,qBAAW,YAAY,SAAS,UAAU,MAAM,KAAK;AAAA,QACzD;AAAA,MACJ,GAAG,SAAS,UAAU;AACtB,aAAO;AAAA,IACX;AACA,IAAAA,cAAa,UAAU,aAAa,SAAU,SAAS,SAAS,eAAe;AAC3E,aAAO,KAAK,qBAAqB,SAAS,SAAS,aAAa,EAAE,QAC7D;AAAA,IACT;AACA,IAAAA,cAAa,UAAU,gBAAgB,WAAY;AAC/C,UAAI,QAAQ,uBAAO,OAAO,IAAI;AAC9B,WAAK,QAAQ,QAAQ,SAAU,MAAM,SAAS;AAC1C,cAAM,OAAO,IAAI;AAAA,UACb,WAAW,KAAK;AAAA,UAChB,eAAe,KAAK;AAAA,UACpB,cAAc,KAAK;AAAA,UACnB,eAAe,KAAK;AAAA,QACxB;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,IACX;AACA,IAAAA,cAAa,UAAU,cAAc,SAAU,SAAS;AACpD,UAAI,YAAY,KAAK,QAAQ,IAAI,OAAO;AACxC,UAAI,WAAW;AACX,kBAAU,eAAe;AACzB,kBAAU,gBAAgB,CAAC;AAAA,MAC/B;AAAA,IACJ;AACA,IAAAA,cAAa,UAAU,YAAY,SAAU,UAAU;AACnD,aAAO,KAAK,kBAAkB,kBAAkB,QAAQ;AAAA,IAC5D;AACA,IAAAA,cAAa,UAAU,kBAAkB,SAAU,UAAU;AACzD,UAAI,iBAAiB,KAAK;AAC1B,UAAI,CAAC,eAAe,IAAI,QAAQ,GAAG;AAC/B,YAAI,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAMb,kBAAkB,iBAAiB,QAAQ;AAAA,UAC3C,oBAAoB,KAAK,WAAW,qBAAqB,QAAQ;AAAA,UACjE,yBAAyB,cAAc,CAAC,aAAa,GAAG,QAAQ;AAAA,UAChE,aAAa,KAAK,WAAW,YAAY,QAAQ;AAAA,UACjD,aAAa,6BAA6B;AAAA,YACtC,EAAE,MAAM,UAAU,QAAQ,KAAK;AAAA,YAC/B,EAAE,MAAM,aAAa;AAAA,YACrB,EAAE,MAAM,cAAc;AAAA,UAC1B,GAAG,QAAQ;AAAA,UACX,aAAa,iBAAiB,uBAAuB,QAAQ,CAAC;AAAA;AAAA;AAAA,UAG9D,SAAS,SAAS,SAAS,CAAC,GAAG,QAAQ,GAAG,EAAE,aAAa,SAAS,YAAY,IAAI,SAAU,KAAK;AACzF,gBAAI,IAAI,SAAS,yBACb,IAAI,cAAc,SAAS;AAC3B,qBAAO,SAAS,SAAS,CAAC,GAAG,GAAG,GAAG,EAAE,WAAW,QAAQ,CAAC;AAAA,YAC7D;AACA,mBAAO;AAAA,UACX,CAAC,EAAE,CAAC;AAAA,QACZ;AACA,uBAAe,IAAI,UAAU,UAAU;AAAA,MAC3C;AACA,aAAO,eAAe,IAAI,QAAQ;AAAA,IACtC;AACA,IAAAA,cAAa,UAAU,eAAe,SAAU,UAAU,WAAW;AACjE,aAAO,SAAS,SAAS,CAAC,GAAG,KAAK,gBAAgB,QAAQ,EAAE,WAAW,GAAG,SAAS;AAAA,IACvF;AACA,IAAAA,cAAa,UAAU,aAAa,SAAU,SAAS;AACnD,UAAI,QAAQ,KAAK,UAAU,QAAQ,KAAK;AAIxC,gBAAU,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,WAAW,KAAK,aAAa,OAAO,QAAQ,SAAS,EAAE,CAAC;AACpG,UAAI,OAAO,QAAQ,gCAAgC,aAAa;AAC5D,gBAAQ,8BAA8B;AAAA,MAC1C;AACA,UAAI,YAAY,IAAI,UAAU,IAAI;AAClC,UAAI,aAAa,IAAI,gBAAgB;AAAA,QACjC,cAAc;AAAA,QACd;AAAA,QACA;AAAA,MACJ,CAAC;AACD,iBAAW,WAAW,IAAI;AAC1B,WAAK,QAAQ,IAAI,WAAW,SAAS,SAAS;AAG9C,gBAAU,KAAK;AAAA,QACX,UAAU;AAAA,QACV,iBAAiB;AAAA,QACjB,WAAW,WAAW;AAAA,MAC1B,CAAC;AACD,aAAO;AAAA,IACX;AACA,IAAAA,cAAa,UAAU,QAAQ,SAAU,SAAS,SAAS;AACvD,UAAI,QAAQ;AACZ,UAAI,YAAY,QAAQ;AAAE,kBAAU,KAAK,gBAAgB;AAAA,MAAG;AAC5D,gBAAU,QAAQ,OAAO,EAAE;AAC3B,gBAAU,QAAQ,MAAM,SAAS,YAAY,EAAE;AAC/C,gBAAU,CAAC,QAAQ,mBAAmB,EAAE;AACxC,gBAAU,CAAC,QAAQ,cAAc,EAAE;AACnC,aAAO,KAAK,WAAW,SAAS,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,OAAO,KAAK,UAAU,QAAQ,KAAK,EAAE,CAAC,CAAC,EAAE,QAAQ,WAAY;AAAE,eAAO,MAAM,UAAU,OAAO;AAAA,MAAG,CAAC;AAAA,IACvK;AACA,IAAAA,cAAa,UAAU,kBAAkB,WAAY;AACjD,aAAO,OAAO,KAAK,gBAAgB;AAAA,IACvC;AACA,IAAAA,cAAa,UAAU,oBAAoB,WAAY;AACnD,aAAO,KAAK;AAAA,IAChB;AACA,IAAAA,cAAa,UAAU,qBAAqB,WAAY;AACpD,aAAO,OAAO,KAAK,mBAAmB;AAAA,IAC1C;AACA,IAAAA,cAAa,UAAU,mBAAmB,SAAU,SAAS;AACzD,WAAK,4BAA4B,OAAO;AACxC,WAAK,iBAAiB;AAAA,IAC1B;AACA,IAAAA,cAAa,UAAU,8BAA8B,SAAU,SAAS;AACpE,UAAI,YAAY,KAAK,QAAQ,IAAI,OAAO;AACxC,UAAI;AACA,kBAAU,KAAK;AAAA,IACvB;AACA,IAAAA,cAAa,UAAU,aAAa,SAAU,SAAS;AACnD,UAAI,YAAY,QAAQ;AAAE,kBAAU;AAAA,UAChC,gBAAgB;AAAA,QACpB;AAAA,MAAG;AAMH,WAAK,qBAAqB,kBAAkB,EAAE,CAAC;AAC/C,WAAK,QAAQ,QAAQ,SAAU,WAAW;AACtC,YAAI,UAAU,iBAAiB;AAG3B,oBAAU,gBAAgB,cAAc;AAAA,QAC5C,OACK;AACD,oBAAU,KAAK;AAAA,QACnB;AAAA,MACJ,CAAC;AACD,UAAI,KAAK,eAAe;AACpB,aAAK,gBAAgB,uBAAO,OAAO,IAAI;AAAA,MAC3C;AAEA,aAAO,KAAK,MAAM,MAAM,OAAO;AAAA,IACnC;AACA,IAAAA,cAAa,UAAU,uBAAuB,SAAU,SAAS;AAC7D,UAAI,QAAQ;AACZ,UAAI,YAAY,QAAQ;AAAE,kBAAU;AAAA,MAAU;AAC9C,UAAI,UAAU,oBAAI,IAAI;AACtB,UAAI,oBAAoB,oBAAI,IAAI;AAChC,UAAI,qBAAqB,oBAAI,IAAI;AACjC,UAAI,MAAM,QAAQ,OAAO,GAAG;AACxB,gBAAQ,QAAQ,SAAU,MAAM;AAC5B,cAAI,OAAO,SAAS,UAAU;AAC1B,8BAAkB,IAAI,MAAM,KAAK;AAAA,UACrC,WACS,eAAe,IAAI,GAAG;AAC3B,8BAAkB,IAAI,MAAM,UAAU,IAAI,GAAG,KAAK;AAAA,UACtD,WACS,gBAAgB,IAAI,KAAK,KAAK,OAAO;AAC1C,+BAAmB,IAAI,IAAI;AAAA,UAC/B;AAAA,QACJ,CAAC;AAAA,MACL;AACA,WAAK,QAAQ,QAAQ,SAAU,IAAI,SAAS;AACxC,YAAI,KAAK,GAAG,iBAAiB,WAAW,GAAG;AAC3C,YAAI,IAAI;AACJ,cAAI,YAAY,OAAO;AACnB,oBAAQ,IAAI,SAAS,EAAE;AACvB;AAAA,UACJ;AACA,cAAI,YAAY,GAAG,WAAW,cAAc,GAAG,QAAQ;AACvD,cAAI,gBAAgB,aACf,YAAY,YAAY,CAAC,GAAG,aAAa,GAAI;AAC9C;AAAA,UACJ;AACA,cAAI,YAAY,YACX,aAAa,kBAAkB,IAAI,SAAS,KAC5C,YAAY,kBAAkB,IAAI,QAAQ,GAAI;AAC/C,oBAAQ,IAAI,SAAS,EAAE;AACvB,gBAAI;AACA,gCAAkB,IAAI,WAAW,IAAI;AACzC,gBAAI;AACA,gCAAkB,IAAI,UAAU,IAAI;AAAA,UAC5C;AAAA,QACJ;AAAA,MACJ,CAAC;AACD,UAAI,mBAAmB,MAAM;AACzB,2BAAmB,QAAQ,SAAU,SAAS;AAI1C,cAAI,UAAU,aAAa,oBAAoB;AAC/C,cAAI,YAAY,MAAM,SAAS,OAAO,EAAE,KAAK;AAAA,YACzC,UAAU,QAAQ;AAAA,YAClB,WAAW,QAAQ;AAAA,UACvB,CAAC;AACD,cAAI,KAAK,IAAI,gBAAgB;AAAA,YACzB,cAAc;AAAA,YACd;AAAA,YACA,SAAS,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,aAAa,eAAe,CAAC;AAAA,UAC5E,CAAC;AACD,oBAAU,GAAG,YAAY,OAAO;AAChC,oBAAU,mBAAmB,EAAE;AAC/B,kBAAQ,IAAI,SAAS,EAAE;AAAA,QAC3B,CAAC;AAAA,MACL;AACA,UAAI,WAAW,YAAY,SAAS,kBAAkB,MAAM;AACxD,0BAAkB,QAAQ,SAAU,UAAU,WAAW;AACrD,cAAI,CAAC,UAAU;AACX,uBAAW,YAAY,SAAS,UAAU,KAAK,OAAO,cAAc,WAAW,KAAK,IAAI,SAAS;AAAA,UACrG;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AACA,IAAAA,cAAa,UAAU,2BAA2B,SAAU,gBAAgB;AACxE,UAAI,QAAQ;AACZ,UAAI,mBAAmB,QAAQ;AAAE,yBAAiB;AAAA,MAAO;AACzD,UAAI,0BAA0B,CAAC;AAC/B,WAAK,qBAAqB,iBAAiB,QAAQ,QAAQ,EAAE,QAAQ,SAAU,iBAAiB,SAAS;AACrG,YAAI,cAAc,gBAAgB,QAAQ;AAC1C,wBAAgB,iBAAiB;AACjC,YAAI,kBACC,gBAAgB,aAAa,gBAAgB,cAAe;AAC7D,kCAAwB,KAAK,gBAAgB,QAAQ,CAAC;AAAA,QAC1D;AACA,cAAM,SAAS,OAAO,EAAE,QAAQ,IAAI;AAAA,MACxC,CAAC;AACD,WAAK,iBAAiB;AACtB,aAAO,QAAQ,IAAI,uBAAuB;AAAA,IAC9C;AACA,IAAAA,cAAa,UAAU,qBAAqB,SAAU,iBAAiB;AACnE,WAAK,SAAS,gBAAgB,OAAO,EAAE,mBAAmB,eAAe;AAAA,IAC7E;AACA,IAAAA,cAAa,UAAU,2BAA2B,SAAU,IAAI;AAC5D,UAAI,QAAQ;AACZ,UAAI,QAAQ,GAAG,OAAO,cAAc,GAAG,aAAa,KAAK,GAAG,aAAa,cAAc,OAAO,SAAS,SAAS,IAAI,YAAY,GAAG,WAAW,KAAK,GAAG,SAAS,UAAU,OAAO,SAAS,CAAC,IAAI;AAC9L,cAAQ,KAAK,UAAU,KAAK;AAC5B,kBAAY,KAAK,aAAa,OAAO,SAAS;AAC9C,UAAI,iBAAiB,SAAUK,YAAW;AACtC,eAAO,MAAM,sBAAsB,OAAO,SAASA,UAAS,EAAE,IAAI,SAAU,QAAQ;AAChF,cAAI,gBAAgB,YAAY;AAG5B,gBAAI,kBAAkB,QAAQ,WAAW,GAAG;AACxC,oBAAM,MAAM,MAAM;AAAA,gBACd;AAAA,gBACA,QAAQ,OAAO;AAAA,gBACf,QAAQ;AAAA,gBACR,WAAWA;AAAA,cACf,CAAC;AAAA,YACL;AACA,kBAAM,iBAAiB;AAAA,UAC3B;AACA,cAAI,YAAY,sBAAsB,MAAM;AAC5C,cAAI,oBAAoB,+BAA+B,MAAM;AAC7D,cAAI,aAAa,mBAAmB;AAChC,gBAAI,SAAS,CAAC;AACd,gBAAI,WAAW;AACX,qBAAO,gBAAgB,OAAO;AAAA,YAClC;AACA,gBAAI,mBAAmB;AACnB,qBAAO,iBAAiB,OAAO,WAAW,sBAAsB;AAAA,YACpE;AAIA,gBAAI,gBAAgB,UAAU,mBAAmB;AAC7C,oBAAM,IAAI,YAAY,MAAM;AAAA,YAChC;AAAA,UACJ;AACA,cAAI,gBAAgB,UAAU;AAC1B,mBAAO,OAAO;AAAA,UAClB;AACA,iBAAO;AAAA,QACX,CAAC;AAAA,MACL;AACA,UAAI,KAAK,gBAAgB,KAAK,EAAE,kBAAkB;AAC9C,YAAI,sBAAsB,KAAK,WAC1B,qBAAqB,OAAO,WAAW,OAAO,EAC9C,KAAK,cAAc;AACxB,eAAO,IAAI,WAAW,SAAU,UAAU;AACtC,cAAI,MAAM;AACV,8BAAoB,KAAK,SAAU,YAAY;AAAE,mBAAQ,MAAM,WAAW,UAAU,QAAQ;AAAA,UAAI,GAAG,SAAS,KAAK;AACjH,iBAAO,WAAY;AAAE,mBAAO,OAAO,IAAI,YAAY;AAAA,UAAG;AAAA,QAC1D,CAAC;AAAA,MACL;AACA,aAAO,eAAe,SAAS;AAAA,IACnC;AACA,IAAAL,cAAa,UAAU,YAAY,SAAU,SAAS;AAClD,WAAK,qBAAqB,OAAO;AACjC,WAAK,iBAAiB;AAAA,IAC1B;AACA,IAAAA,cAAa,UAAU,uBAAuB,SAAU,SAAS;AAC7D,WAAK,4BAA4B,OAAO;AACxC,WAAK,YAAY,OAAO;AAAA,IAC5B;AACA,IAAAA,cAAa,UAAU,cAAc,SAAU,SAAS;AAMpD,WAAK,eAAe,OAAO,OAAO;AAClC,UAAI,KAAK,QAAQ,IAAI,OAAO,GAAG;AAC3B,aAAK,SAAS,OAAO,EAAE,KAAK;AAC5B,aAAK,QAAQ,OAAO,OAAO;AAAA,MAC/B;AAAA,IACJ;AACA,IAAAA,cAAa,UAAU,mBAAmB,WAAY;AAClD,UAAI,KAAK;AACL,aAAK,YAAY;AACrB,WAAK,QAAQ,QAAQ,SAAU,MAAM;AAAE,eAAO,KAAK,OAAO;AAAA,MAAG,CAAC;AAAA,IAClE;AACA,IAAAA,cAAa,UAAU,gBAAgB,WAAY;AAC/C,aAAO,KAAK;AAAA,IAChB;AACA,IAAAA,cAAa,UAAU,wBAAwB,SAAU,OAAO,SAAS,WAEzE,eAAe;AACX,UAAI,QAAQ;AACZ,UAAI;AACJ,UAAI,kBAAkB,QAAQ;AAAE,yBAAiB,KAAK,YAAY,QAAQ,YAAY,SAAS,SAAS,QAAQ,wBAAwB,QAAQ,OAAO,SAAS,KAAK,KAAK;AAAA,MAAoB;AAC9L,UAAI;AACJ,UAAI,KAAK,KAAK,gBAAgB,KAAK,GAAG,cAAc,GAAG,aAAa,cAAc,GAAG;AACrF,UAAI,aAAa;AACb,YAAI,KAAK,MAAM,4BAA4B,GAAG,yBAAyB,OAAO,GAAG;AACjF,YAAI,YAAY;AAAA,UACZ,OAAO;AAAA,UACP;AAAA,UACA,eAAe,iBAAiB,WAAW,KAAK;AAAA,UAChD,SAAS,KAAK,eAAe,SAAS,SAAS,CAAC,GAAG,OAAO,GAAG,EAAE,YAAY,CAAC,cAAc,CAAC,CAAC;AAAA,QAChG;AACA,kBAAU,UAAU;AACpB,YAAI,eAAe;AACf,cAAI,uBAAuB,MAAM,WAAW;AAC5C,cAAI,YAAY,mBAAmB,SAAS;AAC5C,cAAI,QAAQ,0BAA0B,OAAO,sBAAsB,SAAS;AAC5E,uBAAa,MAAM;AACnB,cAAI,CAAC,YAAY;AACb,gBAAI,UAAU,IAAI,QAAQ;AAAA,cACtB,QAAQ,MAAM,SAAS;AAAA,YAC3B,CAAC;AACD,yBAAa,MAAM,aAAa;AAChC,oBAAQ,WAAW,WAAY;AAC3B,wCAA0B,OAAO,sBAAsB,SAAS;AAAA,YACpE,CAAC;AAAA,UACL;AAAA,QACJ,OACK;AACD,uBAAa,IAAI,QAAQ;AAAA,YACrB,QAAQ,MAAM,SAAS;AAAA,UAC3B,CAAC;AAAA,QACL;AAAA,MACJ,OACK;AACD,qBAAa,IAAI,QAAQ,CAAC,WAAW,GAAG,EAAE,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC;AACtD,kBAAU,KAAK,eAAe,OAAO;AAAA,MACzC;AACA,UAAI,aAAa;AACb,qBAAa,SAAS,YAAY,SAAU,QAAQ;AAChD,iBAAO,MAAM,WAAW,aAAa;AAAA,YACjC,UAAU;AAAA,YACV,cAAc;AAAA,YACd;AAAA,YACA;AAAA,UACJ,CAAC;AAAA,QACL,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AACA,IAAAA,cAAa,UAAU,qBAAqB,SAAU,WAAW,oBAAoB,SAAS;AAC1F,UAAI,YAAa,UAAU,gBAAgB,KAAK,kBAAkB;AAIlE,UAAI,eAAe,KAAK,MAAM,iBAAiB,QAAQ,KAAK;AAC5D,aAAO,SAAS,KAAK,sBAAsB,cAAc,QAAQ,SAAS,QAAQ,SAAS,GAAG,SAAU,QAAQ;AAC5G,YAAI,gBAAgB,2BAA2B,MAAM;AACrD,YAAI,YAAY,cAAc,SAAS;AAGvC,YAAI,aAAa,UAAU,eAAe;AACtC,cAAI,aAAa,QAAQ,gBAAgB,QAAQ;AAE7C,kBAAM,UAAU,UAAU,IAAI,YAAY;AAAA,cACtC;AAAA,YACJ,CAAC,CAAC;AAAA,UACN;AAIA,oBAAU,WAAW,QAAQ,cAAc,SAAS,kBAAkB;AACtE,oBAAU,UAAU;AAAA,QACxB;AACA,YAAI,MAAM;AAAA,UACN,MAAM,OAAO;AAAA,UACb,SAAS;AAAA,UACT,eAAe,cAAc;AAAA,QACjC;AACA,YAAI,aAAa,QAAQ,gBAAgB,UAAU;AAC/C,cAAI,SAAS;AACb,cAAI,gBAAgB,cAAc;AAAA,QACtC;AACA,eAAO;AAAA,MACX,GAAG,SAAU,cAAc;AACvB,YAAI,QAAQ,cAAc,YAAY,IAAI,eAAgB,IAAI,YAAY,EAAE,aAA2B,CAAC;AAExG,YAAI,aAAa,UAAU,eAAe;AACtC,oBAAU,UAAU,KAAK;AAAA,QAC7B;AACA,cAAM;AAAA,MACV,CAAC;AAAA,IACL;AACA,IAAAA,cAAa,UAAU,uBAAuB,SAAU,SAAS,SAIjE,eAAe,OAAO;AAClB,UAAI,QAAQ;AACZ,UAAI,kBAAkB,QAAQ;AAAE,wBAAgB,cAAc;AAAA,MAAS;AACvE,UAAI,UAAU,QAAQ;AAAE,gBAAQ,QAAQ;AAAA,MAAO;AAC/C,UAAI,YAAY,KAAK,aAAa,OAAO,QAAQ,SAAS;AAC1D,UAAI,YAAY,KAAK,SAAS,OAAO;AACrC,UAAI,WAAW,KAAK,eAAe;AACnC,UAAI,KAAK,QAAQ,aAAa,cAAc,OAAO,SAAU,YAAY,SAAS,eAAgB,gBAAgB,IAAI,KAAK,QAAQ,aAAa,cAAc,OAAO,SAAU,YAAY,SAAS,eAAgB,SAAS,IAAI,KAAK,QAAQ,mBAAmB,oBAAoB,OAAO,SAAS,QAAQ,IAAI,KAAK,QAAQ,6BAA6B,8BAA8B,OAAO,SAAS,QAAQ,IAAI,KAAK,QAAQ,SAAS,UAAU,OAAO,SAAS,CAAC,IAAI;AAC1c,UAAI,aAAa,OAAO,OAAO,CAAC,GAAG,SAAS;AAAA,QACxC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ,CAAC;AACD,UAAI,gBAAgB,SAAUK,YAAW;AAIrC,mBAAW,YAAYA;AACvB,YAAIC,mBAAkB,MAAM,mBAAmB,WAAW,YAAY,aAAa;AACnF;AAAA;AAAA;AAAA,UAGA,WAAW,gBAAgB;AAAA;AAAA,UAGvBA,iBAAgB,QAAQ,SAAS,KACjC,UAAU;AAAA,UAAiB;AAC3B,oBAAU,gBAAgB,sBAAsB,EAAE,eAAe,OAAO;AAAA,QAC5E;AACA,eAAOA;AAAA,MACX;AAGA,UAAI,kBAAkB,WAAY;AAAE,eAAO,MAAM,eAAe,OAAO,OAAO;AAAA,MAAG;AACjF,WAAK,eAAe,IAAI,SAAS,SAAU,QAAQ;AAC/C,wBAAgB;AAEhB,mBAAW,WAAY;AAAE,iBAAO,QAAQ,OAAO,MAAM;AAAA,QAAG,CAAC;AAAA,MAC7D,CAAC;AACD,UAAI,SAAS;AAQb,UAAI,KAAK,gBAAgB,WAAW,KAAK,EAAE,kBAAkB;AACzD,kBAAU,IAAI,QAAQ,KAAK,WACtB,qBAAqB,WAAW,OAAO,WAAW,WAAW,WAAW,OAAO,EAC/E,KAAK,aAAa,EAClB,KAAK,SAAUA,kBAAiB;AAAE,iBAAOA,iBAAgB;AAAA,QAAS,CAAC,CAAC;AAMzE,+BAAuB;AAAA,MAC3B,OACK;AACD,YAAI,kBAAkB,cAAc,WAAW,SAAS;AACxD,+BAAuB,gBAAgB;AACvC,kBAAU,IAAI,QAAQ,gBAAgB,OAAO;AAAA,MACjD;AACA,cAAQ,QAAQ,KAAK,iBAAiB,eAAe;AACrD,aAAO;AAAA,QACH;AAAA,QACA,UAAU;AAAA,MACd;AAAA,IACJ;AACA,IAAAN,cAAa,UAAU,iBAAiB,SAAU,IAAI;AAClD,UAAI,QAAQ;AACZ,UAAI,cAAc,GAAG,aAAa,UAAU,GAAG,SAAS,KAAK,GAAG,YAAY,aAAa,OAAO,SAAS,QAAQ,IAAI,KAAK,GAAG,kBAAkB,mBAAmB,OAAO,SAAS,aAAa,aAAa,gBAAgB,IAAI,SAAS,IAAI,iBAAiB,GAAG;AACjQ,UAAI,sBAAsB,oBAAI,IAAI;AAClC,UAAI,SAAS;AACT,aAAK,qBAAqB,OAAO,EAAE,QAAQ,SAAU,IAAI,SAAS;AAC9D,8BAAoB,IAAI,SAAS;AAAA,YAC7B;AAAA,YACA,UAAU,MAAM,SAAS,OAAO,EAAE,QAAQ;AAAA,UAC9C,CAAC;AAAA,QACL,CAAC;AAAA,MACL;AACA,UAAI,UAAU,oBAAI,IAAI;AACtB,UAAI,aAAa;AACb,aAAK,MAAM,MAAM;AAAA,UACb,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UA8BR,YAAa,cAAc,oBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAQhD;AAAA,UACA,gBAAgB,SAAU,OAAO,MAAM,UAAU;AAC7C,gBAAI,KAAK,MAAM,mBAAmB,aAAa,MAAM,QAAQ;AAC7D,gBAAI,IAAI;AACJ,kBAAI,gBAAgB;AAIhB,oCAAoB,OAAO,GAAG,OAAO;AACrC,oBAAI,SAAS,eAAe,IAAI,MAAM,QAAQ;AAC9C,oBAAI,WAAW,MAAM;AAGjB,2BAAS,GAAG,QAAQ;AAAA,gBACxB;AAGA,oBAAI,WAAW,OAAO;AAClB,0BAAQ,IAAI,IAAI,MAAM;AAAA,gBAC1B;AAGA,uBAAO;AAAA,cACX;AACA,kBAAI,mBAAmB,MAAM;AAIzB,oCAAoB,IAAI,GAAG,SAAS,EAAE,IAAQ,UAAoB,KAAW,CAAC;AAAA,cAClF;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AACA,UAAI,oBAAoB,MAAM;AAC1B,4BAAoB,QAAQ,SAAUO,KAAI,SAAS;AAC/C,cAAI,KAAKA,IAAG,IAAI,WAAWA,IAAG,UAAU,OAAOA,IAAG;AAClD,cAAI;AAGJ,cAAI,gBAAgB;AAChB,gBAAI,CAAC,MAAM;AACP,kBAAI,OAAO,GAAG,WAAW;AACzB,mBAAK,MAAM;AACX,qBAAO,KAAK,QAAQ;AAAA,YACxB;AACA,qBAAS,eAAe,IAAI,MAAM,QAAQ;AAAA,UAC9C;AAEA,cAAI,CAAC,kBAAkB,WAAW,MAAM;AACpC,qBAAS,GAAG,QAAQ;AAAA,UACxB;AACA,cAAI,WAAW,OAAO;AAClB,oBAAQ,IAAI,IAAI,MAAM;AAAA,UAC1B;AACA,cAAI,QAAQ,QAAQ,oBAAoB,KAAK,GAAG;AAC5C,kBAAM,qBAAqB,OAAO;AAAA,UACtC;AAAA,QACJ,CAAC;AAAA,MACL;AACA,UAAI,kBAAkB;AAQlB,aAAK,MAAM,iBAAiB,gBAAgB;AAAA,MAChD;AACA,aAAO;AAAA,IACX;AACA,IAAAP,cAAa,UAAU,qBAAqB,SAAU,WAAW,IAIjE,eAAe;AACX,UAAI,QAAQ;AACZ,UAAI,QAAQ,GAAG,OAAO,YAAY,GAAG,WAAW,cAAc,GAAG,aAAa,qBAAqB,GAAG,oBAAoB,cAAc,GAAG,aAAa,oBAAoB,GAAG,mBAAmB,UAAU,GAAG,SAAS,8BAA8B,GAAG;AACzP,UAAI,mBAAmB,UAAU;AACjC,gBAAU,KAAK;AAAA,QACX,UAAU;AAAA,QACV;AAAA,QACA;AAAA,MACJ,CAAC;AACD,UAAI,YAAY,WAAY;AAAE,eAAO,UAAU,QAAQ;AAAA,MAAG;AAC1D,UAAI,mBAAmB,SAAUG,OAAMK,gBAAe;AAClD,YAAIA,mBAAkB,QAAQ;AAAE,UAAAA,iBAAgB,UAAU,iBAAiB,cAAc;AAAA,QAAS;AAClG,YAAI,OAAOL,MAAK;AAChB,YAAI,WAAW,YAAY,SAAS,CAAC,qBAAqB,CAAC,MAAM,MAAM,CAAC,CAAC,GAAG;AACxE,gCAAsBA,MAAK,OAAO;AAAA,QACtC;AACA,YAAI,WAAW,SAAUM,OAAM;AAC3B,iBAAO,WAAW,GAAG,SAAS,EAAE,MAAMA,OAAM,SAAS,yBAAyBD,cAAa,GAAG,eAAeA,eAAc,GAAIL,MAAK,WAAW,OAAO,EAAE,SAAS,KAAK,CAAE,CAAC;AAAA,QAC7K;AACA,YAAI,QAAQ,MAAM,gBAAgB,KAAK,EAAE,oBAAoB;AACzD,iBAAO,MAAM,WACR,aAAa;AAAA,YACd,UAAU;AAAA,YACV,cAAc,EAAE,KAAW;AAAA,YAC3B;AAAA,YACA;AAAA,YACA,wBAAwB;AAAA,UAC5B,CAAC,EACI,KAAK,SAAU,UAAU;AAAE,mBAAO,SAAS,SAAS,QAAQ,MAAM;AAAA,UAAG,CAAC;AAAA,QAC/E;AAKA,YAAI,gBAAgB,UAChBK,mBAAkB,cAAc,WAChC,MAAM,QAAQL,MAAK,OAAO,GAAG;AAC7B,iBAAO,SAAS,MAAM;AAAA,QAC1B;AACA,eAAO,SAAS,IAAI;AAAA,MACxB;AACA,UAAI,qBAAqB,gBAAgB,aAAa,IAG/C,kBAAkB,cAAc,WAC/B,uBAAuB,UACvB,IACE;AACV,UAAI,kBAAkB,WAAY;AAC9B,eAAO,MAAM,mBAAmB,WAAW,oBAAoB;AAAA,UAC3D;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACJ,CAAC;AAAA,MACL;AACA,UAAI,eAAe,+BACf,OAAO,qBAAqB,YAC5B,qBAAqB,iBACrB,yBAAyB,aAAa;AAC1C,cAAQ,aAAa;AAAA,QACjB;AAAA,QACA,KAAK,eAAe;AAChB,cAAI,OAAO,UAAU;AACrB,cAAI,KAAK,UAAU;AACf,mBAAO;AAAA,cACH,UAAU;AAAA,cACV,SAAS,CAAC,iBAAiB,MAAM,UAAU,UAAU,CAAC,CAAC;AAAA,YAC3D;AAAA,UACJ;AACA,cAAI,qBAAqB,cAAc;AACnC,mBAAO;AAAA,cACH,UAAU;AAAA,cACV,SAAS,CAAC,iBAAiB,IAAI,GAAG,gBAAgB,CAAC;AAAA,YACvD;AAAA,UACJ;AACA,iBAAO,EAAE,UAAU,MAAM,SAAS,CAAC,gBAAgB,CAAC,EAAE;AAAA,QAC1D;AAAA,QACA,KAAK,qBAAqB;AACtB,cAAI,OAAO,UAAU;AACrB,cAAI,KAAK,YAAY,qBAAqB,cAAc;AACpD,mBAAO;AAAA,cACH,UAAU;AAAA,cACV,SAAS,CAAC,iBAAiB,IAAI,GAAG,gBAAgB,CAAC;AAAA,YACvD;AAAA,UACJ;AACA,iBAAO,EAAE,UAAU,MAAM,SAAS,CAAC,gBAAgB,CAAC,EAAE;AAAA,QAC1D;AAAA,QACA,KAAK;AACD,iBAAO;AAAA,YACH,UAAU;AAAA,YACV,SAAS,CAAC,iBAAiB,UAAU,GAAG,UAAU,UAAU,CAAC,CAAC;AAAA,UAClE;AAAA,QACJ,KAAK;AACD,cAAI,cAAc;AACd,mBAAO;AAAA,cACH,UAAU;AAAA,cACV,SAAS,CAAC,iBAAiB,UAAU,CAAC,GAAG,gBAAgB,CAAC;AAAA,YAC9D;AAAA,UACJ;AACA,iBAAO,EAAE,UAAU,MAAM,SAAS,CAAC,gBAAgB,CAAC,EAAE;AAAA,QAC1D,KAAK;AACD,cAAI,cAAc;AACd,mBAAO;AAAA,cACH,UAAU;AAAA;AAAA;AAAA;AAAA,cAIV,SAAS,CAAC,iBAAiB,UAAU,QAAQ,CAAC,GAAG,gBAAgB,CAAC;AAAA,YACtE;AAAA,UACJ;AACA,iBAAO,EAAE,UAAU,MAAM,SAAS,CAAC,gBAAgB,CAAC,EAAE;AAAA,QAC1D,KAAK;AACD,iBAAO,EAAE,UAAU,OAAO,SAAS,CAAC,EAAE;AAAA,MAC9C;AAAA,IACJ;AACA,IAAAH,cAAa,UAAU,WAAW,SAAU,SAAS;AACjD,UAAI,WAAW,CAAC,KAAK,QAAQ,IAAI,OAAO,GAAG;AACvC,aAAK,QAAQ,IAAI,SAAS,IAAI,UAAU,MAAM,OAAO,CAAC;AAAA,MAC1D;AACA,aAAO,KAAK,QAAQ,IAAI,OAAO;AAAA,IACnC;AACA,IAAAA,cAAa,UAAU,iBAAiB,SAAU,SAAS;AACvD,UAAI,YAAY,QAAQ;AAAE,kBAAU,CAAC;AAAA,MAAG;AACxC,UAAI,aAAa,KAAK,WAAW,eAAe,OAAO;AACvD,aAAO,SAAS,SAAS,SAAS,CAAC,GAAG,KAAK,cAAc,GAAG,UAAU,GAAG,EAAE,iBAAiB,KAAK,gBAAgB,CAAC;AAAA,IACtH;AACA,WAAOA;AAAA,EACX,EAAE;AAAA;AACF,SAAS;\",\n  \"names\": [\"QueryManager\", \"hasClientExports\", \"cache\", \"diff\", \"result\", \"variables\", \"sourcesWithInfo\", \"_a\", \"networkStatus\", \"data\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1746507072854,
      "end": 1746507072854,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1746507072854,
      "end": 1746507072854,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1746507072854,
      "end": 1746507072854,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1746507072854,
      "end": 1746507072854,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1746507072854,
      "end": 1746507072857,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1746507072857,
      "end": 1746507072857,
      "order": "normal"
    }
  ]
}
