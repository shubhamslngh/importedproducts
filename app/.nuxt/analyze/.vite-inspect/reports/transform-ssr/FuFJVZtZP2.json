{
  "resolvedId": "/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/core/ApolloClient.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport { version } from \"../version.js\";\nimport { HttpLink } from \"../link/http/index.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nimport { LocalState } from \"./LocalState.js\";\nvar hasSuggestedDevtools = false;\n// Though mergeOptions now resides in @apollo/client/utilities, it was\n// previously declared and exported from this module, and then reexported from\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\n// solution is to reexport mergeOptions where it was previously declared (here).\nimport { mergeOptions } from \"../utilities/index.js\";\nimport { getApolloClientMemoryInternals } from \"../utilities/caching/getMemoryInternals.js\";\nexport { mergeOptions };\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over an {@link ApolloLink} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nvar ApolloClient = /** @class */ (function () {\n    /**\n     * Constructs an instance of {@link ApolloClient}.\n     *\n     * @example\n     * ```js\n     * import { ApolloClient, InMemoryCache } from '@apollo/client';\n     *\n     * const cache = new InMemoryCache();\n     *\n     * const client = new ApolloClient({\n     *   // Provide required constructor fields\n     *   cache: cache,\n     *   uri: 'http://localhost:4000/',\n     *\n     *   // Provide some optional constructor fields\n     *   name: 'react-web-client',\n     *   version: '1.3',\n     *   queryDeduplication: false,\n     *   defaultOptions: {\n     *     watchQuery: {\n     *       fetchPolicy: 'cache-and-network',\n     *     },\n     *   },\n     * });\n     * ```\n     */\n    function ApolloClient(options) {\n        var _this = this;\n        this.resetStoreCallbacks = [];\n        this.clearStoreCallbacks = [];\n        if (!options.cache) {\n            throw newInvariantError(15);\n        }\n        var uri = options.uri, credentials = options.credentials, headers = options.headers, cache = options.cache, documentTransform = options.documentTransform, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, \n        // Expose the client instance as window.__APOLLO_CLIENT__ and call\n        // onBroadcast in queryManager.broadcastQueries to enable browser\n        // devtools, but disable them by default in production.\n        _c = options.connectToDevTools, \n        // Expose the client instance as window.__APOLLO_CLIENT__ and call\n        // onBroadcast in queryManager.broadcastQueries to enable browser\n        // devtools, but disable them by default in production.\n        connectToDevTools = _c === void 0 ? typeof window === \"object\" &&\n            !window.__APOLLO_CLIENT__ &&\n            globalThis.__DEV__ !== false : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions = options.defaultOptions, defaultContext = options.defaultContext, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? cache.assumeImmutableResults : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;\n        var link = options.link;\n        if (!link) {\n            link =\n                uri ? new HttpLink({ uri: uri, credentials: credentials, headers: headers }) : ApolloLink.empty();\n        }\n        this.link = link;\n        this.cache = cache;\n        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n        this.queryDeduplication = queryDeduplication;\n        this.defaultOptions = defaultOptions || Object.create(null);\n        this.typeDefs = typeDefs;\n        if (ssrForceFetchDelay) {\n            setTimeout(function () { return (_this.disableNetworkFetches = false); }, ssrForceFetchDelay);\n        }\n        this.watchQuery = this.watchQuery.bind(this);\n        this.query = this.query.bind(this);\n        this.mutate = this.mutate.bind(this);\n        this.resetStore = this.resetStore.bind(this);\n        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n        this.version = version;\n        this.localState = new LocalState({\n            cache: cache,\n            client: this,\n            resolvers: resolvers,\n            fragmentMatcher: fragmentMatcher,\n        });\n        this.queryManager = new QueryManager({\n            cache: this.cache,\n            link: this.link,\n            defaultOptions: this.defaultOptions,\n            defaultContext: defaultContext,\n            documentTransform: documentTransform,\n            queryDeduplication: queryDeduplication,\n            ssrMode: ssrMode,\n            clientAwareness: {\n                name: clientAwarenessName,\n                version: clientAwarenessVersion,\n            },\n            localState: this.localState,\n            assumeImmutableResults: assumeImmutableResults,\n            onBroadcast: connectToDevTools ?\n                function () {\n                    if (_this.devToolsHookCb) {\n                        _this.devToolsHookCb({\n                            action: {},\n                            state: {\n                                queries: _this.queryManager.getQueryStore(),\n                                mutations: _this.queryManager.mutationStore || {},\n                            },\n                            dataWithOptimisticResults: _this.cache.extract(true),\n                        });\n                    }\n                }\n                : void 0,\n        });\n        if (connectToDevTools)\n            this.connectToDevTools();\n    }\n    ApolloClient.prototype.connectToDevTools = function () {\n        if (typeof window === \"object\") {\n            var windowWithDevTools = window;\n            var devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n            (windowWithDevTools[devtoolsSymbol] =\n                windowWithDevTools[devtoolsSymbol] || []).push(this);\n            windowWithDevTools.__APOLLO_CLIENT__ = this;\n        }\n        /**\n         * Suggest installing the devtools for developers who don't have them\n         */\n        if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {\n            hasSuggestedDevtools = true;\n            setTimeout(function () {\n                if (typeof window !== \"undefined\" &&\n                    window.document &&\n                    window.top === window.self &&\n                    !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n                    var nav = window.navigator;\n                    var ua = nav && nav.userAgent;\n                    var url = void 0;\n                    if (typeof ua === \"string\") {\n                        if (ua.indexOf(\"Chrome/\") > -1) {\n                            url =\n                                \"https://chrome.google.com/webstore/detail/\" +\n                                    \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n                        }\n                        else if (ua.indexOf(\"Firefox/\") > -1) {\n                            url =\n                                \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n                        }\n                    }\n                    if (url) {\n                        globalThis.__DEV__ !== false && invariant.log(\"Download the Apollo DevTools for a better development \" +\n                            \"experience: %s\", url);\n                    }\n                }\n            }, 10000);\n        }\n    };\n    Object.defineProperty(ApolloClient.prototype, \"documentTransform\", {\n        /**\n         * The `DocumentTransform` used to modify GraphQL documents before a request\n         * is made. If a custom `DocumentTransform` is not provided, this will be the\n         * default document transform.\n         */\n        get: function () {\n            return this.queryManager.documentTransform;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Call this method to terminate any active client processes, making it safe\n     * to dispose of this `ApolloClient` instance.\n     */\n    ApolloClient.prototype.stop = function () {\n        this.queryManager.stop();\n    };\n    /**\n     * This watches the cache store of the query according to the options specified and\n     * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n     * receive updated results through a GraphQL observer when the cache store changes.\n     *\n     * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n     * it uses Apollo's store in order to reactively deliver updates to your query results.\n     *\n     * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n     * first and last name and this person has a particular object identifier, provided by\n     * dataIdFromObject. Later, a different query fetches that same person's\n     * first and last name and the first name has now changed. Then, any observers associated\n     * with the results of the first query will be updated with a new result object.\n     *\n     * Note that if the cache does not change, the subscriber will *not* be notified.\n     *\n     * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n     * a description of store reactivity.\n     */\n    ApolloClient.prototype.watchQuery = function (options) {\n        if (this.defaultOptions.watchQuery) {\n            options = mergeOptions(this.defaultOptions.watchQuery, options);\n        }\n        // XXX Overwriting options is probably not the best way to do this long term...\n        if (this.disableNetworkFetches &&\n            (options.fetchPolicy === \"network-only\" ||\n                options.fetchPolicy === \"cache-and-network\")) {\n            options = __assign(__assign({}, options), { fetchPolicy: \"cache-first\" });\n        }\n        return this.queryManager.watchQuery(options);\n    };\n    /**\n     * This resolves a single query according to the options specified and\n     * returns a `Promise` which is either resolved with the resulting data\n     * or rejected with an error.\n     *\n     * @param options - An object of type {@link QueryOptions} that allows us to\n     * describe how this query should be treated e.g. whether it should hit the\n     * server at all or just resolve from the cache, etc.\n     */\n    ApolloClient.prototype.query = function (options) {\n        if (this.defaultOptions.query) {\n            options = mergeOptions(this.defaultOptions.query, options);\n        }\n        invariant(options.fetchPolicy !== \"cache-and-network\", 16);\n        if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n            options = __assign(__assign({}, options), { fetchPolicy: \"cache-first\" });\n        }\n        return this.queryManager.query(options);\n    };\n    /**\n     * This resolves a single mutation according to the options specified and returns a\n     * Promise which is either resolved with the resulting data or rejected with an\n     * error. In some cases both `data` and `errors` might be undefined, for example\n     * when `errorPolicy` is set to `'ignore'`.\n     *\n     * It takes options as an object with the following keys and values:\n     */\n    ApolloClient.prototype.mutate = function (options) {\n        if (this.defaultOptions.mutate) {\n            options = mergeOptions(this.defaultOptions.mutate, options);\n        }\n        return this.queryManager.mutate(options);\n    };\n    /**\n     * This subscribes to a graphql subscription according to the options specified and returns an\n     * {@link Observable} which either emits received data or an error.\n     */\n    ApolloClient.prototype.subscribe = function (options) {\n        return this.queryManager.startGraphQLSubscription(options);\n    };\n    /**\n     * Tries to read some data from the store in the shape of the provided\n     * GraphQL query without making a network request. This method will start at\n     * the root query. To start at a specific id returned by `dataIdFromObject`\n     * use `readFragment`.\n     *\n     * @param optimistic - Set to `true` to allow `readQuery` to return\n     * optimistic results. Is `false` by default.\n     */\n    ApolloClient.prototype.readQuery = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return this.cache.readQuery(options, optimistic);\n    };\n    /**\n     * Tries to read some data from the store in the shape of the provided\n     * GraphQL fragment without making a network request. This method will read a\n     * GraphQL fragment from any arbitrary id that is currently cached, unlike\n     * `readQuery` which will only read from the root query.\n     *\n     * You must pass in a GraphQL document with a single fragment or a document\n     * with multiple fragments that represent what you are reading. If you pass\n     * in a document with multiple fragments then you must also specify a\n     * `fragmentName`.\n     *\n     * @param optimistic - Set to `true` to allow `readFragment` to return\n     * optimistic results. Is `false` by default.\n     */\n    ApolloClient.prototype.readFragment = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return this.cache.readFragment(options, optimistic);\n    };\n    /**\n     * Writes some data in the shape of the provided GraphQL query directly to\n     * the store. This method will start at the root query. To start at a\n     * specific id returned by `dataIdFromObject` then use `writeFragment`.\n     */\n    ApolloClient.prototype.writeQuery = function (options) {\n        var ref = this.cache.writeQuery(options);\n        if (options.broadcast !== false) {\n            this.queryManager.broadcastQueries();\n        }\n        return ref;\n    };\n    /**\n     * Writes some data in the shape of the provided GraphQL fragment directly to\n     * the store. This method will write to a GraphQL fragment from any arbitrary\n     * id that is currently cached, unlike `writeQuery` which will only write\n     * from the root query.\n     *\n     * You must pass in a GraphQL document with a single fragment or a document\n     * with multiple fragments that represent what you are writing. If you pass\n     * in a document with multiple fragments then you must also specify a\n     * `fragmentName`.\n     */\n    ApolloClient.prototype.writeFragment = function (options) {\n        var ref = this.cache.writeFragment(options);\n        if (options.broadcast !== false) {\n            this.queryManager.broadcastQueries();\n        }\n        return ref;\n    };\n    ApolloClient.prototype.__actionHookForDevTools = function (cb) {\n        this.devToolsHookCb = cb;\n    };\n    ApolloClient.prototype.__requestRaw = function (payload) {\n        return execute(this.link, payload);\n    };\n    /**\n     * Resets your entire store by clearing out your cache and then re-executing\n     * all of your active queries. This makes it so that you may guarantee that\n     * there is no data left in your store from a time before you called this\n     * method.\n     *\n     * `resetStore()` is useful when your user just logged out. Youâ€™ve removed the\n     * user session, and you now want to make sure that any references to data you\n     * might have fetched while the user session was active is gone.\n     *\n     * It is important to remember that `resetStore()` *will* refetch any active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     */\n    ApolloClient.prototype.resetStore = function () {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            return _this.queryManager.clearStore({\n                discardWatches: false,\n            });\n        })\n            .then(function () { return Promise.all(_this.resetStoreCallbacks.map(function (fn) { return fn(); })); })\n            .then(function () { return _this.reFetchObservableQueries(); });\n    };\n    /**\n     * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n     * not refetch any active queries.\n     */\n    ApolloClient.prototype.clearStore = function () {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            return _this.queryManager.clearStore({\n                discardWatches: true,\n            });\n        })\n            .then(function () { return Promise.all(_this.clearStoreCallbacks.map(function (fn) { return fn(); })); });\n    };\n    /**\n     * Allows callbacks to be registered that are executed when the store is\n     * reset. `onResetStore` returns an unsubscribe function that can be used\n     * to remove registered callbacks.\n     */\n    ApolloClient.prototype.onResetStore = function (cb) {\n        var _this = this;\n        this.resetStoreCallbacks.push(cb);\n        return function () {\n            _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) { return c !== cb; });\n        };\n    };\n    /**\n     * Allows callbacks to be registered that are executed when the store is\n     * cleared. `onClearStore` returns an unsubscribe function that can be used\n     * to remove registered callbacks.\n     */\n    ApolloClient.prototype.onClearStore = function (cb) {\n        var _this = this;\n        this.clearStoreCallbacks.push(cb);\n        return function () {\n            _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) { return c !== cb; });\n        };\n    };\n    /**\n     * Refetches all of your active queries.\n     *\n     * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n     *\n     * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n     */\n    ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\n        return this.queryManager.reFetchObservableQueries(includeStandby);\n    };\n    /**\n     * Refetches specified active queries. Similar to \"reFetchObservableQueries()\" but with a specific list of queries.\n     *\n     * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\n     *\n     * It is important to remember that `refetchQueries()` *will* refetch specified active\n     * queries. This means that any components that might be mounted will execute\n     * their queries again using your network interface. If you do not want to\n     * re-execute any queries then you should make sure to stop watching any\n     * active queries.\n     */\n    ApolloClient.prototype.refetchQueries = function (options) {\n        var map = this.queryManager.refetchQueries(options);\n        var queries = [];\n        var results = [];\n        map.forEach(function (result, obsQuery) {\n            queries.push(obsQuery);\n            results.push(result);\n        });\n        var result = Promise.all(results);\n        // In case you need the raw results immediately, without awaiting\n        // Promise.all(results):\n        result.queries = queries;\n        result.results = results;\n        // If you decide to ignore the result Promise because you're using\n        // result.queries and result.results instead, you shouldn't have to worry\n        // about preventing uncaught rejections for the Promise.all result.\n        result.catch(function (error) {\n            globalThis.__DEV__ !== false && invariant.debug(17, error);\n        });\n        return result;\n    };\n    /**\n     * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\n     * query ID strings.\n     *\n     * An \"active\" query is one that has observers and a `fetchPolicy` other than\n     * \"standby\" or \"cache-only\".\n     *\n     * You can include all `ObservableQuery` objects (including the inactive ones)\n     * by passing \"all\" instead of \"active\", or you can include just a subset of\n     * active queries by passing an array of query names or DocumentNode objects.\n     */\n    ApolloClient.prototype.getObservableQueries = function (include) {\n        if (include === void 0) { include = \"active\"; }\n        return this.queryManager.getObservableQueries(include);\n    };\n    /**\n     * Exposes the cache's complete state, in a serializable format for later restoration.\n     */\n    ApolloClient.prototype.extract = function (optimistic) {\n        return this.cache.extract(optimistic);\n    };\n    /**\n     * Replaces existing state in the cache (if any) with the values expressed by\n     * `serializedState`.\n     *\n     * Called when hydrating a cache (server side rendering, or offline storage),\n     * and also (potentially) during hot reloads.\n     */\n    ApolloClient.prototype.restore = function (serializedState) {\n        return this.cache.restore(serializedState);\n    };\n    /**\n     * Add additional local resolvers.\n     */\n    ApolloClient.prototype.addResolvers = function (resolvers) {\n        this.localState.addResolvers(resolvers);\n    };\n    /**\n     * Set (override existing) local resolvers.\n     */\n    ApolloClient.prototype.setResolvers = function (resolvers) {\n        this.localState.setResolvers(resolvers);\n    };\n    /**\n     * Get all registered local resolvers.\n     */\n    ApolloClient.prototype.getResolvers = function () {\n        return this.localState.getResolvers();\n    };\n    /**\n     * Set a custom local state fragment matcher.\n     */\n    ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\n        this.localState.setFragmentMatcher(fragmentMatcher);\n    };\n    /**\n     * Define a new ApolloLink (or link chain) that Apollo Client will use.\n     */\n    ApolloClient.prototype.setLink = function (newLink) {\n        this.link = this.queryManager.link = newLink;\n    };\n    Object.defineProperty(ApolloClient.prototype, \"defaultContext\", {\n        get: function () {\n            return this.queryManager.defaultContext;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ApolloClient;\n}());\nexport { ApolloClient };\nif (globalThis.__DEV__ !== false) {\n    ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n//# sourceMappingURL=ApolloClient.js.map",
      "start": 1716304642724,
      "end": 1716304642748,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "graphql",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1716304642748,
      "end": 1716304642748,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1716304642748,
      "end": 1716304642749,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../utilities/globals/index.js\";\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport { version } from \"../version.js\";\nimport { HttpLink } from \"../link/http/index.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nimport { LocalState } from \"./LocalState.js\";\nvar hasSuggestedDevtools = false;\nimport { mergeOptions } from \"../utilities/index.js\";\nimport { getApolloClientMemoryInternals } from \"../utilities/caching/getMemoryInternals.js\";\nexport { mergeOptions };\nvar ApolloClient = (\n  /** @class */\n  function() {\n    function ApolloClient2(options) {\n      var _this = this;\n      this.resetStoreCallbacks = [];\n      this.clearStoreCallbacks = [];\n      if (!options.cache) {\n        throw newInvariantError(15);\n      }\n      var uri = options.uri, credentials = options.credentials, headers = options.headers, cache = options.cache, documentTransform = options.documentTransform, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options.connectToDevTools, connectToDevTools = _c === void 0 ? false : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions = options.defaultOptions, defaultContext = options.defaultContext, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? cache.assumeImmutableResults : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;\n      var link = options.link;\n      if (!link) {\n        link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();\n      }\n      this.link = link;\n      this.cache = cache;\n      this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n      this.queryDeduplication = queryDeduplication;\n      this.defaultOptions = defaultOptions || /* @__PURE__ */ Object.create(null);\n      this.typeDefs = typeDefs;\n      if (ssrForceFetchDelay) {\n        setTimeout(function() {\n          return _this.disableNetworkFetches = false;\n        }, ssrForceFetchDelay);\n      }\n      this.watchQuery = this.watchQuery.bind(this);\n      this.query = this.query.bind(this);\n      this.mutate = this.mutate.bind(this);\n      this.resetStore = this.resetStore.bind(this);\n      this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n      this.version = version;\n      this.localState = new LocalState({\n        cache,\n        client: this,\n        resolvers,\n        fragmentMatcher\n      });\n      this.queryManager = new QueryManager({\n        cache: this.cache,\n        link: this.link,\n        defaultOptions: this.defaultOptions,\n        defaultContext,\n        documentTransform,\n        queryDeduplication,\n        ssrMode,\n        clientAwareness: {\n          name: clientAwarenessName,\n          version: clientAwarenessVersion\n        },\n        localState: this.localState,\n        assumeImmutableResults,\n        onBroadcast: connectToDevTools ? function() {\n          if (_this.devToolsHookCb) {\n            _this.devToolsHookCb({\n              action: {},\n              state: {\n                queries: _this.queryManager.getQueryStore(),\n                mutations: _this.queryManager.mutationStore || {}\n              },\n              dataWithOptimisticResults: _this.cache.extract(true)\n            });\n          }\n        } : void 0\n      });\n      if (connectToDevTools)\n        this.connectToDevTools();\n    }\n    ApolloClient2.prototype.connectToDevTools = function() {\n      if (false) {\n        var windowWithDevTools = void 0;\n        var devtoolsSymbol = Symbol.for(\"apollo.devtools\");\n        (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);\n        windowWithDevTools.__APOLLO_CLIENT__ = this;\n      }\n      if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {\n        hasSuggestedDevtools = true;\n        setTimeout(function() {\n          if (false) {\n            var nav = (void 0).navigator;\n            var ua = nav && nav.userAgent;\n            var url = void 0;\n            if (typeof ua === \"string\") {\n              if (ua.indexOf(\"Chrome/\") > -1) {\n                url = \"https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n              } else if (ua.indexOf(\"Firefox/\") > -1) {\n                url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n              }\n            }\n            if (url) {\n              globalThis.__DEV__ !== false && invariant.log(\"Download the Apollo DevTools for a better development experience: %s\", url);\n            }\n          }\n        }, 1e4);\n      }\n    };\n    Object.defineProperty(ApolloClient2.prototype, \"documentTransform\", {\n      /**\n       * The `DocumentTransform` used to modify GraphQL documents before a request\n       * is made. If a custom `DocumentTransform` is not provided, this will be the\n       * default document transform.\n       */\n      get: function() {\n        return this.queryManager.documentTransform;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    ApolloClient2.prototype.stop = function() {\n      this.queryManager.stop();\n    };\n    ApolloClient2.prototype.watchQuery = function(options) {\n      if (this.defaultOptions.watchQuery) {\n        options = mergeOptions(this.defaultOptions.watchQuery, options);\n      }\n      if (this.disableNetworkFetches && (options.fetchPolicy === \"network-only\" || options.fetchPolicy === \"cache-and-network\")) {\n        options = __assign(__assign({}, options), { fetchPolicy: \"cache-first\" });\n      }\n      return this.queryManager.watchQuery(options);\n    };\n    ApolloClient2.prototype.query = function(options) {\n      if (this.defaultOptions.query) {\n        options = mergeOptions(this.defaultOptions.query, options);\n      }\n      invariant(options.fetchPolicy !== \"cache-and-network\", 16);\n      if (this.disableNetworkFetches && options.fetchPolicy === \"network-only\") {\n        options = __assign(__assign({}, options), { fetchPolicy: \"cache-first\" });\n      }\n      return this.queryManager.query(options);\n    };\n    ApolloClient2.prototype.mutate = function(options) {\n      if (this.defaultOptions.mutate) {\n        options = mergeOptions(this.defaultOptions.mutate, options);\n      }\n      return this.queryManager.mutate(options);\n    };\n    ApolloClient2.prototype.subscribe = function(options) {\n      return this.queryManager.startGraphQLSubscription(options);\n    };\n    ApolloClient2.prototype.readQuery = function(options, optimistic) {\n      if (optimistic === void 0) {\n        optimistic = false;\n      }\n      return this.cache.readQuery(options, optimistic);\n    };\n    ApolloClient2.prototype.readFragment = function(options, optimistic) {\n      if (optimistic === void 0) {\n        optimistic = false;\n      }\n      return this.cache.readFragment(options, optimistic);\n    };\n    ApolloClient2.prototype.writeQuery = function(options) {\n      var ref = this.cache.writeQuery(options);\n      if (options.broadcast !== false) {\n        this.queryManager.broadcastQueries();\n      }\n      return ref;\n    };\n    ApolloClient2.prototype.writeFragment = function(options) {\n      var ref = this.cache.writeFragment(options);\n      if (options.broadcast !== false) {\n        this.queryManager.broadcastQueries();\n      }\n      return ref;\n    };\n    ApolloClient2.prototype.__actionHookForDevTools = function(cb) {\n      this.devToolsHookCb = cb;\n    };\n    ApolloClient2.prototype.__requestRaw = function(payload) {\n      return execute(this.link, payload);\n    };\n    ApolloClient2.prototype.resetStore = function() {\n      var _this = this;\n      return Promise.resolve().then(function() {\n        return _this.queryManager.clearStore({\n          discardWatches: false\n        });\n      }).then(function() {\n        return Promise.all(_this.resetStoreCallbacks.map(function(fn) {\n          return fn();\n        }));\n      }).then(function() {\n        return _this.reFetchObservableQueries();\n      });\n    };\n    ApolloClient2.prototype.clearStore = function() {\n      var _this = this;\n      return Promise.resolve().then(function() {\n        return _this.queryManager.clearStore({\n          discardWatches: true\n        });\n      }).then(function() {\n        return Promise.all(_this.clearStoreCallbacks.map(function(fn) {\n          return fn();\n        }));\n      });\n    };\n    ApolloClient2.prototype.onResetStore = function(cb) {\n      var _this = this;\n      this.resetStoreCallbacks.push(cb);\n      return function() {\n        _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {\n          return c !== cb;\n        });\n      };\n    };\n    ApolloClient2.prototype.onClearStore = function(cb) {\n      var _this = this;\n      this.clearStoreCallbacks.push(cb);\n      return function() {\n        _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {\n          return c !== cb;\n        });\n      };\n    };\n    ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {\n      return this.queryManager.reFetchObservableQueries(includeStandby);\n    };\n    ApolloClient2.prototype.refetchQueries = function(options) {\n      var map = this.queryManager.refetchQueries(options);\n      var queries = [];\n      var results = [];\n      map.forEach(function(result2, obsQuery) {\n        queries.push(obsQuery);\n        results.push(result2);\n      });\n      var result = Promise.all(results);\n      result.queries = queries;\n      result.results = results;\n      result.catch(function(error) {\n        globalThis.__DEV__ !== false && invariant.debug(17, error);\n      });\n      return result;\n    };\n    ApolloClient2.prototype.getObservableQueries = function(include) {\n      if (include === void 0) {\n        include = \"active\";\n      }\n      return this.queryManager.getObservableQueries(include);\n    };\n    ApolloClient2.prototype.extract = function(optimistic) {\n      return this.cache.extract(optimistic);\n    };\n    ApolloClient2.prototype.restore = function(serializedState) {\n      return this.cache.restore(serializedState);\n    };\n    ApolloClient2.prototype.addResolvers = function(resolvers) {\n      this.localState.addResolvers(resolvers);\n    };\n    ApolloClient2.prototype.setResolvers = function(resolvers) {\n      this.localState.setResolvers(resolvers);\n    };\n    ApolloClient2.prototype.getResolvers = function() {\n      return this.localState.getResolvers();\n    };\n    ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {\n      this.localState.setFragmentMatcher(fragmentMatcher);\n    };\n    ApolloClient2.prototype.setLink = function(newLink) {\n      this.link = this.queryManager.link = newLink;\n    };\n    Object.defineProperty(ApolloClient2.prototype, \"defaultContext\", {\n      get: function() {\n        return this.queryManager.defaultContext;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return ApolloClient2;\n  }()\n);\nexport { ApolloClient };\nif (globalThis.__DEV__ !== false) {\n  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\n}\n",
      "start": 1716304642749,
      "end": 1716304643184,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/core/ApolloClient.js\"],\n  \"sourcesContent\": [\"import { __assign } from \\\"tslib\\\";\\nimport { invariant, newInvariantError } from \\\"../utilities/globals/index.js\\\";\\nimport { ApolloLink, execute } from \\\"../link/core/index.js\\\";\\nimport { version } from \\\"../version.js\\\";\\nimport { HttpLink } from \\\"../link/http/index.js\\\";\\nimport { QueryManager } from \\\"./QueryManager.js\\\";\\nimport { LocalState } from \\\"./LocalState.js\\\";\\nvar hasSuggestedDevtools = false;\\n// Though mergeOptions now resides in @apollo/client/utilities, it was\\n// previously declared and exported from this module, and then reexported from\\n// @apollo/client/core. Since we need to preserve that API anyway, the easiest\\n// solution is to reexport mergeOptions where it was previously declared (here).\\nimport { mergeOptions } from \\\"../utilities/index.js\\\";\\nimport { getApolloClientMemoryInternals } from \\\"../utilities/caching/getMemoryInternals.js\\\";\\nexport { mergeOptions };\\n/**\\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\\n * and mutations) to a GraphQL spec-compliant server over an {@link ApolloLink} instance,\\n * receive results from the server and cache the results in a store. It also delivers updates\\n * to GraphQL queries through {@link Observable} instances.\\n */\\nvar ApolloClient = /** @class */ (function () {\\n    /**\\n     * Constructs an instance of {@link ApolloClient}.\\n     *\\n     * @example\\n     * ```js\\n     * import { ApolloClient, InMemoryCache } from '@apollo/client';\\n     *\\n     * const cache = new InMemoryCache();\\n     *\\n     * const client = new ApolloClient({\\n     *   // Provide required constructor fields\\n     *   cache: cache,\\n     *   uri: 'http://localhost:4000/',\\n     *\\n     *   // Provide some optional constructor fields\\n     *   name: 'react-web-client',\\n     *   version: '1.3',\\n     *   queryDeduplication: false,\\n     *   defaultOptions: {\\n     *     watchQuery: {\\n     *       fetchPolicy: 'cache-and-network',\\n     *     },\\n     *   },\\n     * });\\n     * ```\\n     */\\n    function ApolloClient(options) {\\n        var _this = this;\\n        this.resetStoreCallbacks = [];\\n        this.clearStoreCallbacks = [];\\n        if (!options.cache) {\\n            throw newInvariantError(15);\\n        }\\n        var uri = options.uri, credentials = options.credentials, headers = options.headers, cache = options.cache, documentTransform = options.documentTransform, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, \\n        // Expose the client instance as window.__APOLLO_CLIENT__ and call\\n        // onBroadcast in queryManager.broadcastQueries to enable browser\\n        // devtools, but disable them by default in production.\\n        _c = options.connectToDevTools, \\n        // Expose the client instance as window.__APOLLO_CLIENT__ and call\\n        // onBroadcast in queryManager.broadcastQueries to enable browser\\n        // devtools, but disable them by default in production.\\n        connectToDevTools = _c === void 0 ? typeof window === \\\"object\\\" &&\\n            !window.__APOLLO_CLIENT__ &&\\n            globalThis.__DEV__ !== false : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions = options.defaultOptions, defaultContext = options.defaultContext, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? cache.assumeImmutableResults : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;\\n        var link = options.link;\\n        if (!link) {\\n            link =\\n                uri ? new HttpLink({ uri: uri, credentials: credentials, headers: headers }) : ApolloLink.empty();\\n        }\\n        this.link = link;\\n        this.cache = cache;\\n        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\\n        this.queryDeduplication = queryDeduplication;\\n        this.defaultOptions = defaultOptions || Object.create(null);\\n        this.typeDefs = typeDefs;\\n        if (ssrForceFetchDelay) {\\n            setTimeout(function () { return (_this.disableNetworkFetches = false); }, ssrForceFetchDelay);\\n        }\\n        this.watchQuery = this.watchQuery.bind(this);\\n        this.query = this.query.bind(this);\\n        this.mutate = this.mutate.bind(this);\\n        this.resetStore = this.resetStore.bind(this);\\n        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\\n        this.version = version;\\n        this.localState = new LocalState({\\n            cache: cache,\\n            client: this,\\n            resolvers: resolvers,\\n            fragmentMatcher: fragmentMatcher,\\n        });\\n        this.queryManager = new QueryManager({\\n            cache: this.cache,\\n            link: this.link,\\n            defaultOptions: this.defaultOptions,\\n            defaultContext: defaultContext,\\n            documentTransform: documentTransform,\\n            queryDeduplication: queryDeduplication,\\n            ssrMode: ssrMode,\\n            clientAwareness: {\\n                name: clientAwarenessName,\\n                version: clientAwarenessVersion,\\n            },\\n            localState: this.localState,\\n            assumeImmutableResults: assumeImmutableResults,\\n            onBroadcast: connectToDevTools ?\\n                function () {\\n                    if (_this.devToolsHookCb) {\\n                        _this.devToolsHookCb({\\n                            action: {},\\n                            state: {\\n                                queries: _this.queryManager.getQueryStore(),\\n                                mutations: _this.queryManager.mutationStore || {},\\n                            },\\n                            dataWithOptimisticResults: _this.cache.extract(true),\\n                        });\\n                    }\\n                }\\n                : void 0,\\n        });\\n        if (connectToDevTools)\\n            this.connectToDevTools();\\n    }\\n    ApolloClient.prototype.connectToDevTools = function () {\\n        if (typeof window === \\\"object\\\") {\\n            var windowWithDevTools = window;\\n            var devtoolsSymbol = Symbol.for(\\\"apollo.devtools\\\");\\n            (windowWithDevTools[devtoolsSymbol] =\\n                windowWithDevTools[devtoolsSymbol] || []).push(this);\\n            windowWithDevTools.__APOLLO_CLIENT__ = this;\\n        }\\n        /**\\n         * Suggest installing the devtools for developers who don't have them\\n         */\\n        if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {\\n            hasSuggestedDevtools = true;\\n            setTimeout(function () {\\n                if (typeof window !== \\\"undefined\\\" &&\\n                    window.document &&\\n                    window.top === window.self &&\\n                    !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\\n                    var nav = window.navigator;\\n                    var ua = nav && nav.userAgent;\\n                    var url = void 0;\\n                    if (typeof ua === \\\"string\\\") {\\n                        if (ua.indexOf(\\\"Chrome/\\\") > -1) {\\n                            url =\\n                                \\\"https://chrome.google.com/webstore/detail/\\\" +\\n                                    \\\"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\\\";\\n                        }\\n                        else if (ua.indexOf(\\\"Firefox/\\\") > -1) {\\n                            url =\\n                                \\\"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\\\";\\n                        }\\n                    }\\n                    if (url) {\\n                        globalThis.__DEV__ !== false && invariant.log(\\\"Download the Apollo DevTools for a better development \\\" +\\n                            \\\"experience: %s\\\", url);\\n                    }\\n                }\\n            }, 10000);\\n        }\\n    };\\n    Object.defineProperty(ApolloClient.prototype, \\\"documentTransform\\\", {\\n        /**\\n         * The `DocumentTransform` used to modify GraphQL documents before a request\\n         * is made. If a custom `DocumentTransform` is not provided, this will be the\\n         * default document transform.\\n         */\\n        get: function () {\\n            return this.queryManager.documentTransform;\\n        },\\n        enumerable: false,\\n        configurable: true\\n    });\\n    /**\\n     * Call this method to terminate any active client processes, making it safe\\n     * to dispose of this `ApolloClient` instance.\\n     */\\n    ApolloClient.prototype.stop = function () {\\n        this.queryManager.stop();\\n    };\\n    /**\\n     * This watches the cache store of the query according to the options specified and\\n     * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\\n     * receive updated results through a GraphQL observer when the cache store changes.\\n     *\\n     * Note that this method is not an implementation of GraphQL subscriptions. Rather,\\n     * it uses Apollo's store in order to reactively deliver updates to your query results.\\n     *\\n     * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\\n     * first and last name and this person has a particular object identifier, provided by\\n     * dataIdFromObject. Later, a different query fetches that same person's\\n     * first and last name and the first name has now changed. Then, any observers associated\\n     * with the results of the first query will be updated with a new result object.\\n     *\\n     * Note that if the cache does not change, the subscriber will *not* be notified.\\n     *\\n     * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\\n     * a description of store reactivity.\\n     */\\n    ApolloClient.prototype.watchQuery = function (options) {\\n        if (this.defaultOptions.watchQuery) {\\n            options = mergeOptions(this.defaultOptions.watchQuery, options);\\n        }\\n        // XXX Overwriting options is probably not the best way to do this long term...\\n        if (this.disableNetworkFetches &&\\n            (options.fetchPolicy === \\\"network-only\\\" ||\\n                options.fetchPolicy === \\\"cache-and-network\\\")) {\\n            options = __assign(__assign({}, options), { fetchPolicy: \\\"cache-first\\\" });\\n        }\\n        return this.queryManager.watchQuery(options);\\n    };\\n    /**\\n     * This resolves a single query according to the options specified and\\n     * returns a `Promise` which is either resolved with the resulting data\\n     * or rejected with an error.\\n     *\\n     * @param options - An object of type {@link QueryOptions} that allows us to\\n     * describe how this query should be treated e.g. whether it should hit the\\n     * server at all or just resolve from the cache, etc.\\n     */\\n    ApolloClient.prototype.query = function (options) {\\n        if (this.defaultOptions.query) {\\n            options = mergeOptions(this.defaultOptions.query, options);\\n        }\\n        invariant(options.fetchPolicy !== \\\"cache-and-network\\\", 16);\\n        if (this.disableNetworkFetches && options.fetchPolicy === \\\"network-only\\\") {\\n            options = __assign(__assign({}, options), { fetchPolicy: \\\"cache-first\\\" });\\n        }\\n        return this.queryManager.query(options);\\n    };\\n    /**\\n     * This resolves a single mutation according to the options specified and returns a\\n     * Promise which is either resolved with the resulting data or rejected with an\\n     * error. In some cases both `data` and `errors` might be undefined, for example\\n     * when `errorPolicy` is set to `'ignore'`.\\n     *\\n     * It takes options as an object with the following keys and values:\\n     */\\n    ApolloClient.prototype.mutate = function (options) {\\n        if (this.defaultOptions.mutate) {\\n            options = mergeOptions(this.defaultOptions.mutate, options);\\n        }\\n        return this.queryManager.mutate(options);\\n    };\\n    /**\\n     * This subscribes to a graphql subscription according to the options specified and returns an\\n     * {@link Observable} which either emits received data or an error.\\n     */\\n    ApolloClient.prototype.subscribe = function (options) {\\n        return this.queryManager.startGraphQLSubscription(options);\\n    };\\n    /**\\n     * Tries to read some data from the store in the shape of the provided\\n     * GraphQL query without making a network request. This method will start at\\n     * the root query. To start at a specific id returned by `dataIdFromObject`\\n     * use `readFragment`.\\n     *\\n     * @param optimistic - Set to `true` to allow `readQuery` to return\\n     * optimistic results. Is `false` by default.\\n     */\\n    ApolloClient.prototype.readQuery = function (options, optimistic) {\\n        if (optimistic === void 0) { optimistic = false; }\\n        return this.cache.readQuery(options, optimistic);\\n    };\\n    /**\\n     * Tries to read some data from the store in the shape of the provided\\n     * GraphQL fragment without making a network request. This method will read a\\n     * GraphQL fragment from any arbitrary id that is currently cached, unlike\\n     * `readQuery` which will only read from the root query.\\n     *\\n     * You must pass in a GraphQL document with a single fragment or a document\\n     * with multiple fragments that represent what you are reading. If you pass\\n     * in a document with multiple fragments then you must also specify a\\n     * `fragmentName`.\\n     *\\n     * @param optimistic - Set to `true` to allow `readFragment` to return\\n     * optimistic results. Is `false` by default.\\n     */\\n    ApolloClient.prototype.readFragment = function (options, optimistic) {\\n        if (optimistic === void 0) { optimistic = false; }\\n        return this.cache.readFragment(options, optimistic);\\n    };\\n    /**\\n     * Writes some data in the shape of the provided GraphQL query directly to\\n     * the store. This method will start at the root query. To start at a\\n     * specific id returned by `dataIdFromObject` then use `writeFragment`.\\n     */\\n    ApolloClient.prototype.writeQuery = function (options) {\\n        var ref = this.cache.writeQuery(options);\\n        if (options.broadcast !== false) {\\n            this.queryManager.broadcastQueries();\\n        }\\n        return ref;\\n    };\\n    /**\\n     * Writes some data in the shape of the provided GraphQL fragment directly to\\n     * the store. This method will write to a GraphQL fragment from any arbitrary\\n     * id that is currently cached, unlike `writeQuery` which will only write\\n     * from the root query.\\n     *\\n     * You must pass in a GraphQL document with a single fragment or a document\\n     * with multiple fragments that represent what you are writing. If you pass\\n     * in a document with multiple fragments then you must also specify a\\n     * `fragmentName`.\\n     */\\n    ApolloClient.prototype.writeFragment = function (options) {\\n        var ref = this.cache.writeFragment(options);\\n        if (options.broadcast !== false) {\\n            this.queryManager.broadcastQueries();\\n        }\\n        return ref;\\n    };\\n    ApolloClient.prototype.__actionHookForDevTools = function (cb) {\\n        this.devToolsHookCb = cb;\\n    };\\n    ApolloClient.prototype.__requestRaw = function (payload) {\\n        return execute(this.link, payload);\\n    };\\n    /**\\n     * Resets your entire store by clearing out your cache and then re-executing\\n     * all of your active queries. This makes it so that you may guarantee that\\n     * there is no data left in your store from a time before you called this\\n     * method.\\n     *\\n     * `resetStore()` is useful when your user just logged out. Youâ€™ve removed the\\n     * user session, and you now want to make sure that any references to data you\\n     * might have fetched while the user session was active is gone.\\n     *\\n     * It is important to remember that `resetStore()` *will* refetch any active\\n     * queries. This means that any components that might be mounted will execute\\n     * their queries again using your network interface. If you do not want to\\n     * re-execute any queries then you should make sure to stop watching any\\n     * active queries.\\n     */\\n    ApolloClient.prototype.resetStore = function () {\\n        var _this = this;\\n        return Promise.resolve()\\n            .then(function () {\\n            return _this.queryManager.clearStore({\\n                discardWatches: false,\\n            });\\n        })\\n            .then(function () { return Promise.all(_this.resetStoreCallbacks.map(function (fn) { return fn(); })); })\\n            .then(function () { return _this.reFetchObservableQueries(); });\\n    };\\n    /**\\n     * Remove all data from the store. Unlike `resetStore`, `clearStore` will\\n     * not refetch any active queries.\\n     */\\n    ApolloClient.prototype.clearStore = function () {\\n        var _this = this;\\n        return Promise.resolve()\\n            .then(function () {\\n            return _this.queryManager.clearStore({\\n                discardWatches: true,\\n            });\\n        })\\n            .then(function () { return Promise.all(_this.clearStoreCallbacks.map(function (fn) { return fn(); })); });\\n    };\\n    /**\\n     * Allows callbacks to be registered that are executed when the store is\\n     * reset. `onResetStore` returns an unsubscribe function that can be used\\n     * to remove registered callbacks.\\n     */\\n    ApolloClient.prototype.onResetStore = function (cb) {\\n        var _this = this;\\n        this.resetStoreCallbacks.push(cb);\\n        return function () {\\n            _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) { return c !== cb; });\\n        };\\n    };\\n    /**\\n     * Allows callbacks to be registered that are executed when the store is\\n     * cleared. `onClearStore` returns an unsubscribe function that can be used\\n     * to remove registered callbacks.\\n     */\\n    ApolloClient.prototype.onClearStore = function (cb) {\\n        var _this = this;\\n        this.clearStoreCallbacks.push(cb);\\n        return function () {\\n            _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) { return c !== cb; });\\n        };\\n    };\\n    /**\\n     * Refetches all of your active queries.\\n     *\\n     * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\\n     *\\n     * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\\n     * queries. This means that any components that might be mounted will execute\\n     * their queries again using your network interface. If you do not want to\\n     * re-execute any queries then you should make sure to stop watching any\\n     * active queries.\\n     * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\\n     */\\n    ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\\n        return this.queryManager.reFetchObservableQueries(includeStandby);\\n    };\\n    /**\\n     * Refetches specified active queries. Similar to \\\"reFetchObservableQueries()\\\" but with a specific list of queries.\\n     *\\n     * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.\\n     *\\n     * It is important to remember that `refetchQueries()` *will* refetch specified active\\n     * queries. This means that any components that might be mounted will execute\\n     * their queries again using your network interface. If you do not want to\\n     * re-execute any queries then you should make sure to stop watching any\\n     * active queries.\\n     */\\n    ApolloClient.prototype.refetchQueries = function (options) {\\n        var map = this.queryManager.refetchQueries(options);\\n        var queries = [];\\n        var results = [];\\n        map.forEach(function (result, obsQuery) {\\n            queries.push(obsQuery);\\n            results.push(result);\\n        });\\n        var result = Promise.all(results);\\n        // In case you need the raw results immediately, without awaiting\\n        // Promise.all(results):\\n        result.queries = queries;\\n        result.results = results;\\n        // If you decide to ignore the result Promise because you're using\\n        // result.queries and result.results instead, you shouldn't have to worry\\n        // about preventing uncaught rejections for the Promise.all result.\\n        result.catch(function (error) {\\n            globalThis.__DEV__ !== false && invariant.debug(17, error);\\n        });\\n        return result;\\n    };\\n    /**\\n     * Get all currently active `ObservableQuery` objects, in a `Map` keyed by\\n     * query ID strings.\\n     *\\n     * An \\\"active\\\" query is one that has observers and a `fetchPolicy` other than\\n     * \\\"standby\\\" or \\\"cache-only\\\".\\n     *\\n     * You can include all `ObservableQuery` objects (including the inactive ones)\\n     * by passing \\\"all\\\" instead of \\\"active\\\", or you can include just a subset of\\n     * active queries by passing an array of query names or DocumentNode objects.\\n     */\\n    ApolloClient.prototype.getObservableQueries = function (include) {\\n        if (include === void 0) { include = \\\"active\\\"; }\\n        return this.queryManager.getObservableQueries(include);\\n    };\\n    /**\\n     * Exposes the cache's complete state, in a serializable format for later restoration.\\n     */\\n    ApolloClient.prototype.extract = function (optimistic) {\\n        return this.cache.extract(optimistic);\\n    };\\n    /**\\n     * Replaces existing state in the cache (if any) with the values expressed by\\n     * `serializedState`.\\n     *\\n     * Called when hydrating a cache (server side rendering, or offline storage),\\n     * and also (potentially) during hot reloads.\\n     */\\n    ApolloClient.prototype.restore = function (serializedState) {\\n        return this.cache.restore(serializedState);\\n    };\\n    /**\\n     * Add additional local resolvers.\\n     */\\n    ApolloClient.prototype.addResolvers = function (resolvers) {\\n        this.localState.addResolvers(resolvers);\\n    };\\n    /**\\n     * Set (override existing) local resolvers.\\n     */\\n    ApolloClient.prototype.setResolvers = function (resolvers) {\\n        this.localState.setResolvers(resolvers);\\n    };\\n    /**\\n     * Get all registered local resolvers.\\n     */\\n    ApolloClient.prototype.getResolvers = function () {\\n        return this.localState.getResolvers();\\n    };\\n    /**\\n     * Set a custom local state fragment matcher.\\n     */\\n    ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\\n        this.localState.setFragmentMatcher(fragmentMatcher);\\n    };\\n    /**\\n     * Define a new ApolloLink (or link chain) that Apollo Client will use.\\n     */\\n    ApolloClient.prototype.setLink = function (newLink) {\\n        this.link = this.queryManager.link = newLink;\\n    };\\n    Object.defineProperty(ApolloClient.prototype, \\\"defaultContext\\\", {\\n        get: function () {\\n            return this.queryManager.defaultContext;\\n        },\\n        enumerable: false,\\n        configurable: true\\n    });\\n    return ApolloClient;\\n}());\\nexport { ApolloClient };\\nif (globalThis.__DEV__ !== false) {\\n    ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;\\n}\\n//# sourceMappingURL=ApolloClient.js.map\"],\n  \"mappings\": \"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\",\n  \"names\": [\"ApolloClient\", \"result\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1716304643184,
      "end": 1716304643184,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1716304643184,
      "end": 1716304643184,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1716304643184,
      "end": 1716304643184,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1716304643184,
      "end": 1716304643184,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1716304643184,
      "end": 1716304643185,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1716304643185,
      "end": 1716304643185,
      "order": "normal"
    }
  ]
}
