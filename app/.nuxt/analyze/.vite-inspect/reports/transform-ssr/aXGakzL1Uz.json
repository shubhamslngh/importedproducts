{
  "resolvedId": "/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/react/hooks/useQuery.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { __assign, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { canUseWeakMap, compact, isNonEmptyArray, maybeDeepFreeze, } from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n * ```jsx\n * import { gql, useQuery } from '@apollo/client';\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: 'english' },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n * @since 3.0.0\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery(query, options) {\n    if (options === void 0) { options = Object.create(null); }\n    return wrapHook(\"useQuery\", _useQuery, useApolloClient(options && options.client))(query, options);\n}\nfunction _useQuery(query, options) {\n    return useInternalState(useApolloClient(options.client), query).useQuery(options);\n}\nexport function useInternalState(client, query) {\n    var stateRef = React.useRef();\n    if (!stateRef.current ||\n        client !== stateRef.current.client ||\n        query !== stateRef.current.query) {\n        stateRef.current = new InternalState(client, query, stateRef.current);\n    }\n    var state = stateRef.current;\n    // By default, InternalState.prototype.forceUpdate is an empty function, but\n    // we replace it here (before anyone has had a chance to see this state yet)\n    // with a function that unconditionally forces an update, using the latest\n    // setTick function. Updating this state by calling state.forceUpdate is the\n    // only way we trigger React component updates (no other useState calls within\n    // the InternalState class).\n    state.forceUpdateState = React.useReducer(function (tick) { return tick + 1; }, 0)[1];\n    return state;\n}\nvar InternalState = /** @class */ (function () {\n    function InternalState(client, query, previous) {\n        var _this = this;\n        this.client = client;\n        this.query = query;\n        /**\n         * Will be overwritten by the `useSyncExternalStore` \"force update\" method\n         * whenever it is available and reset to `forceUpdateState` when it isn't.\n         */\n        this.forceUpdate = function () { return _this.forceUpdateState(); };\n        this.ssrDisabledResult = maybeDeepFreeze({\n            loading: true,\n            data: void 0,\n            error: void 0,\n            networkStatus: NetworkStatus.loading,\n        });\n        this.skipStandbyResult = maybeDeepFreeze({\n            loading: false,\n            data: void 0,\n            error: void 0,\n            networkStatus: NetworkStatus.ready,\n        });\n        // This cache allows the referential stability of this.result (as returned by\n        // getCurrentResult) to translate into referential stability of the resulting\n        // QueryResult object returned by toQueryResult.\n        this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();\n        verifyDocumentType(query, DocumentType.Query);\n        // Reuse previousData from previous InternalState (if any) to provide\n        // continuity of previousData even if/when the query or client changes.\n        var previousResult = previous && previous.result;\n        var previousData = previousResult && previousResult.data;\n        if (previousData) {\n            this.previousData = previousData;\n        }\n    }\n    /**\n     * Forces an update using local component state.\n     * As this is not batched with `useSyncExternalStore` updates,\n     * this is only used as a fallback if the `useSyncExternalStore` \"force update\"\n     * method is not registered at the moment.\n     * See https://github.com/facebook/react/issues/25191\n     *  */\n    InternalState.prototype.forceUpdateState = function () {\n        // Replaced (in useInternalState) with a method that triggers an update.\n        globalThis.__DEV__ !== false && invariant.warn(51);\n    };\n    InternalState.prototype.executeQuery = function (options) {\n        var _this = this;\n        var _a;\n        if (options.query) {\n            Object.assign(this, { query: options.query });\n        }\n        this.watchQueryOptions = this.createWatchQueryOptions((this.queryHookOptions = options));\n        var concast = this.observable.reobserveAsConcast(this.getObsQueryOptions());\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n        this.result = void 0;\n        this.forceUpdate();\n        return new Promise(function (resolve) {\n            var result;\n            // Subscribe to the concast independently of the ObservableQuery in case\n            // the component gets unmounted before the promise resolves. This prevents\n            // the concast from terminating early and resolving with `undefined` when\n            // there are no more subscribers for the concast.\n            concast.subscribe({\n                next: function (value) {\n                    result = value;\n                },\n                error: function () {\n                    resolve(_this.toQueryResult(_this.observable.getCurrentResult()));\n                },\n                complete: function () {\n                    resolve(_this.toQueryResult(result));\n                },\n            });\n        });\n    };\n    // Methods beginning with use- should be called according to the standard\n    // rules of React hooks: only at the top level of the calling function, and\n    // without any dynamic conditional logic.\n    InternalState.prototype.useQuery = function (options) {\n        var _this = this;\n        // The renderPromises field gets initialized here in the useQuery method, at\n        // the beginning of everything (for a given component rendering, at least),\n        // so we can safely use this.renderPromises in other/later InternalState\n        // methods without worrying it might be uninitialized. Even after\n        // initialization, this.renderPromises is usually undefined (unless SSR is\n        // happening), but that's fine as long as it has been initialized that way,\n        // rather than left uninitialized.\n        this.renderPromises = React.useContext(getApolloContext()).renderPromises;\n        this.useOptions(options);\n        var obsQuery = this.useObservableQuery();\n        var result = useSyncExternalStore(React.useCallback(function (handleStoreChange) {\n            if (_this.renderPromises) {\n                return function () { };\n            }\n            _this.forceUpdate = handleStoreChange;\n            var onNext = function () {\n                var previousResult = _this.result;\n                // We use `getCurrentResult()` instead of the onNext argument because\n                // the values differ slightly. Specifically, loading results will have\n                // an empty object for data instead of `undefined` for some reason.\n                var result = obsQuery.getCurrentResult();\n                // Make sure we're not attempting to re-render similar results\n                if (previousResult &&\n                    previousResult.loading === result.loading &&\n                    previousResult.networkStatus === result.networkStatus &&\n                    equal(previousResult.data, result.data)) {\n                    return;\n                }\n                _this.setResult(result);\n            };\n            var onError = function (error) {\n                subscription.unsubscribe();\n                subscription = obsQuery.resubscribeAfterError(onNext, onError);\n                if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n                    // The error is not a GraphQL error\n                    throw error;\n                }\n                var previousResult = _this.result;\n                if (!previousResult ||\n                    (previousResult && previousResult.loading) ||\n                    !equal(error, previousResult.error)) {\n                    _this.setResult({\n                        data: (previousResult && previousResult.data),\n                        error: error,\n                        loading: false,\n                        networkStatus: NetworkStatus.error,\n                    });\n                }\n            };\n            var subscription = obsQuery.subscribe(onNext, onError);\n            // Do the \"unsubscribe\" with a short delay.\n            // This way, an existing subscription can be reused without an additional\n            // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n            // happen in very fast succession.\n            return function () {\n                setTimeout(function () { return subscription.unsubscribe(); });\n                _this.forceUpdate = function () { return _this.forceUpdateState(); };\n            };\n        }, [\n            // We memoize the subscribe function using useCallback and the following\n            // dependency keys, because the subscribe function reference is all that\n            // useSyncExternalStore uses internally as a dependency key for the\n            // useEffect ultimately responsible for the subscription, so we are\n            // effectively passing this dependency array to that useEffect buried\n            // inside useSyncExternalStore, as desired.\n            obsQuery,\n            this.renderPromises,\n            this.client.disableNetworkFetches,\n        ]), function () { return _this.getCurrentResult(); }, function () { return _this.getCurrentResult(); });\n        // TODO Remove this method when we remove support for options.partialRefetch.\n        this.unsafeHandlePartialRefetch(result);\n        return this.toQueryResult(result);\n    };\n    InternalState.prototype.useOptions = function (options) {\n        var _a;\n        var watchQueryOptions = this.createWatchQueryOptions((this.queryHookOptions = options));\n        // Update this.watchQueryOptions, but only when they have changed, which\n        // allows us to depend on the referential stability of\n        // this.watchQueryOptions elsewhere.\n        var currentWatchQueryOptions = this.watchQueryOptions;\n        if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n            this.watchQueryOptions = watchQueryOptions;\n            if (currentWatchQueryOptions && this.observable) {\n                // Though it might be tempting to postpone this reobserve call to the\n                // useEffect block, we need getCurrentResult to return an appropriate\n                // loading:true result synchronously (later within the same call to\n                // useQuery). Since we already have this.observable here (not true for\n                // the very first call to useQuery), we are not initiating any new\n                // subscriptions, though it does feel less than ideal that reobserve\n                // (potentially) kicks off a network request (for example, when the\n                // variables have changed), which is technically a side-effect.\n                this.observable.reobserve(this.getObsQueryOptions());\n                // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n                // but save the current data as this.previousData, just like setResult\n                // usually does.\n                this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n                this.result = void 0;\n            }\n        }\n        // Make sure state.onCompleted and state.onError always reflect the latest\n        // options.onCompleted and options.onError callbacks provided to useQuery,\n        // since those functions are often recreated every time useQuery is called.\n        // Like the forceUpdate method, the versions of these methods inherited from\n        // InternalState.prototype are empty no-ops, but we can override them on the\n        // base state object (without modifying the prototype).\n        this.onCompleted =\n            options.onCompleted || InternalState.prototype.onCompleted;\n        this.onError = options.onError || InternalState.prototype.onError;\n        if ((this.renderPromises || this.client.disableNetworkFetches) &&\n            this.queryHookOptions.ssr === false &&\n            !this.queryHookOptions.skip) {\n            // If SSR has been explicitly disabled, and this function has been called\n            // on the server side, return the default loading state.\n            this.result = this.ssrDisabledResult;\n        }\n        else if (this.queryHookOptions.skip ||\n            this.watchQueryOptions.fetchPolicy === \"standby\") {\n            // When skipping a query (ie. we're not querying for data but still want to\n            // render children), make sure the `data` is cleared out and `loading` is\n            // set to `false` (since we aren't loading anything).\n            //\n            // NOTE: We no longer think this is the correct behavior. Skipping should\n            // not automatically set `data` to `undefined`, but instead leave the\n            // previous data in place. In other words, skipping should not mandate that\n            // previously received data is all of a sudden removed. Unfortunately,\n            // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n            // to address this.\n            this.result = this.skipStandbyResult;\n        }\n        else if (this.result === this.ssrDisabledResult ||\n            this.result === this.skipStandbyResult) {\n            this.result = void 0;\n        }\n    };\n    InternalState.prototype.getObsQueryOptions = function () {\n        var toMerge = [];\n        var globalDefaults = this.client.defaultOptions.watchQuery;\n        if (globalDefaults)\n            toMerge.push(globalDefaults);\n        if (this.queryHookOptions.defaultOptions) {\n            toMerge.push(this.queryHookOptions.defaultOptions);\n        }\n        // We use compact rather than mergeOptions for this part of the merge,\n        // because we want watchQueryOptions.variables (if defined) to replace\n        // this.observable.options.variables whole. This replacement allows\n        // removing variables by removing them from the variables input to\n        // useQuery. If the variables were always merged together (rather than\n        // replaced), there would be no way to remove existing variables.\n        // However, the variables from options.defaultOptions and globalDefaults\n        // (if provided) should be merged, to ensure individual defaulted\n        // variables always have values, if not otherwise defined in\n        // observable.options or watchQueryOptions.\n        toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));\n        return toMerge.reduce(mergeOptions);\n    };\n    // A function to massage options before passing them to ObservableQuery.\n    InternalState.prototype.createWatchQueryOptions = function (_a) {\n        var _b;\n        if (_a === void 0) { _a = {}; }\n        var skip = _a.skip, ssr = _a.ssr, onCompleted = _a.onCompleted, onError = _a.onError, defaultOptions = _a.defaultOptions, \n        // The above options are useQuery-specific, so this ...otherOptions spread\n        // makes otherOptions almost a WatchQueryOptions object, except for the\n        // query property that we add below.\n        otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n        // This Object.assign is safe because otherOptions is a fresh ...rest object\n        // that did not exist until just now, so modifications are still allowed.\n        var watchQueryOptions = Object.assign(otherOptions, { query: this.query });\n        if (this.renderPromises &&\n            (watchQueryOptions.fetchPolicy === \"network-only\" ||\n                watchQueryOptions.fetchPolicy === \"cache-and-network\")) {\n            // this behavior was added to react-apollo without explanation in this PR\n            // https://github.com/apollographql/react-apollo/pull/1579\n            watchQueryOptions.fetchPolicy = \"cache-first\";\n        }\n        if (!watchQueryOptions.variables) {\n            watchQueryOptions.variables = {};\n        }\n        if (skip) {\n            var _c = watchQueryOptions.fetchPolicy, fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c, _d = watchQueryOptions.initialFetchPolicy, initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;\n            // When skipping, we set watchQueryOptions.fetchPolicy initially to\n            // \"standby\", but we also need/want to preserve the initial non-standby\n            // fetchPolicy that would have been used if not skipping.\n            Object.assign(watchQueryOptions, {\n                initialFetchPolicy: initialFetchPolicy,\n                fetchPolicy: \"standby\",\n            });\n        }\n        else if (!watchQueryOptions.fetchPolicy) {\n            watchQueryOptions.fetchPolicy =\n                ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) ||\n                    this.getDefaultFetchPolicy();\n        }\n        return watchQueryOptions;\n    };\n    InternalState.prototype.getDefaultFetchPolicy = function () {\n        var _a, _b;\n        return (((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||\n            ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) ||\n            \"cache-first\");\n    };\n    // Defining these methods as no-ops on the prototype allows us to call\n    // state.onCompleted and/or state.onError without worrying about whether a\n    // callback was provided.\n    InternalState.prototype.onCompleted = function (data) { };\n    InternalState.prototype.onError = function (error) { };\n    InternalState.prototype.useObservableQuery = function () {\n        // See if there is an existing observable that was used to fetch the same\n        // data and if so, use it instead since it will contain the proper queryId\n        // to fetch the result set. This is used during SSR.\n        var obsQuery = (this.observable =\n            (this.renderPromises &&\n                this.renderPromises.getSSRObservable(this.watchQueryOptions)) ||\n                this.observable || // Reuse this.observable if possible (and not SSR)\n                this.client.watchQuery(this.getObsQueryOptions()));\n        this.obsQueryFields = React.useMemo(function () { return ({\n            refetch: obsQuery.refetch.bind(obsQuery),\n            reobserve: obsQuery.reobserve.bind(obsQuery),\n            fetchMore: obsQuery.fetchMore.bind(obsQuery),\n            updateQuery: obsQuery.updateQuery.bind(obsQuery),\n            startPolling: obsQuery.startPolling.bind(obsQuery),\n            stopPolling: obsQuery.stopPolling.bind(obsQuery),\n            subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n        }); }, [obsQuery]);\n        var ssrAllowed = !(this.queryHookOptions.ssr === false || this.queryHookOptions.skip);\n        if (this.renderPromises && ssrAllowed) {\n            this.renderPromises.registerSSRObservable(obsQuery);\n            if (obsQuery.getCurrentResult().loading) {\n                // TODO: This is a legacy API which could probably be cleaned up\n                this.renderPromises.addObservableQueryPromise(obsQuery);\n            }\n        }\n        return obsQuery;\n    };\n    InternalState.prototype.setResult = function (nextResult) {\n        var previousResult = this.result;\n        if (previousResult && previousResult.data) {\n            this.previousData = previousResult.data;\n        }\n        this.result = nextResult;\n        // Calling state.setResult always triggers an update, though some call sites\n        // perform additional equality checks before committing to an update.\n        this.forceUpdate();\n        this.handleErrorOrCompleted(nextResult, previousResult);\n    };\n    InternalState.prototype.handleErrorOrCompleted = function (result, previousResult) {\n        var _this = this;\n        if (!result.loading) {\n            var error_1 = this.toApolloError(result);\n            // wait a tick in case we are in the middle of rendering a component\n            Promise.resolve()\n                .then(function () {\n                if (error_1) {\n                    _this.onError(error_1);\n                }\n                else if (result.data &&\n                    (previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus) !== result.networkStatus &&\n                    result.networkStatus === NetworkStatus.ready) {\n                    _this.onCompleted(result.data);\n                }\n            })\n                .catch(function (error) {\n                globalThis.__DEV__ !== false && invariant.warn(error);\n            });\n        }\n    };\n    InternalState.prototype.toApolloError = function (result) {\n        return isNonEmptyArray(result.errors) ?\n            new ApolloError({ graphQLErrors: result.errors })\n            : result.error;\n    };\n    InternalState.prototype.getCurrentResult = function () {\n        // Using this.result as a cache ensures getCurrentResult continues returning\n        // the same (===) result object, unless state.setResult has been called, or\n        // we're doing server rendering and therefore override the result below.\n        if (!this.result) {\n            this.handleErrorOrCompleted((this.result = this.observable.getCurrentResult()));\n        }\n        return this.result;\n    };\n    InternalState.prototype.toQueryResult = function (result) {\n        var queryResult = this.toQueryResultCache.get(result);\n        if (queryResult)\n            return queryResult;\n        var data = result.data, partial = result.partial, resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n        this.toQueryResultCache.set(result, (queryResult = __assign(__assign(__assign({ data: data }, resultWithoutPartial), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData })));\n        if (!queryResult.error && isNonEmptyArray(result.errors)) {\n            // Until a set naming convention for networkError and graphQLErrors is\n            // decided upon, we map errors (graphQLErrors) to the error options.\n            // TODO: Is it possible for both result.error and result.errors to be\n            // defined here?\n            queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n        }\n        return queryResult;\n    };\n    InternalState.prototype.unsafeHandlePartialRefetch = function (result) {\n        // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n        //\n        // TODO: This code should be removed when the partialRefetch option is\n        // removed. I was unable to get this hook to behave reasonably in certain\n        // edge cases when this block was put in an effect.\n        if (result.partial &&\n            this.queryHookOptions.partialRefetch &&\n            !result.loading &&\n            (!result.data || Object.keys(result.data).length === 0) &&\n            this.observable.options.fetchPolicy !== \"cache-only\") {\n            Object.assign(result, {\n                loading: true,\n                networkStatus: NetworkStatus.refetch,\n            });\n            this.observable.refetch();\n        }\n    };\n    return InternalState;\n}());\n//# sourceMappingURL=useQuery.js.map",
      "start": 1716304642815,
      "end": 1716304642840,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "graphql",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1716304642840,
      "end": 1716304642840,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { __assign, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport * as React from \"rehackt\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from \"@wry/equality\";\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { canUseWeakMap, compact, isNonEmptyArray, maybeDeepFreeze } from \"../../utilities/index.js\";\nimport { wrapHook } from \"./internal/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function useQuery(query, options) {\n  if (options === void 0) {\n    options = /* @__PURE__ */ Object.create(null);\n  }\n  return wrapHook(\"useQuery\", _useQuery, useApolloClient(options && options.client))(query, options);\n}\nfunction _useQuery(query, options) {\n  return useInternalState(useApolloClient(options.client), query).useQuery(options);\n}\nexport function useInternalState(client, query) {\n  var stateRef = React.useRef();\n  if (!stateRef.current || client !== stateRef.current.client || query !== stateRef.current.query) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  var state = stateRef.current;\n  state.forceUpdateState = React.useReducer(function(tick) {\n    return tick + 1;\n  }, 0)[1];\n  return state;\n}\nvar InternalState = (\n  /** @class */\n  function() {\n    function InternalState2(client, query, previous) {\n      var _this = this;\n      this.client = client;\n      this.query = query;\n      this.forceUpdate = function() {\n        return _this.forceUpdateState();\n      };\n      this.ssrDisabledResult = maybeDeepFreeze({\n        loading: true,\n        data: void 0,\n        error: void 0,\n        networkStatus: NetworkStatus.loading\n      });\n      this.skipStandbyResult = maybeDeepFreeze({\n        loading: false,\n        data: void 0,\n        error: void 0,\n        networkStatus: NetworkStatus.ready\n      });\n      this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();\n      verifyDocumentType(query, DocumentType.Query);\n      var previousResult = previous && previous.result;\n      var previousData = previousResult && previousResult.data;\n      if (previousData) {\n        this.previousData = previousData;\n      }\n    }\n    InternalState2.prototype.forceUpdateState = function() {\n      globalThis.__DEV__ !== false && invariant.warn(51);\n    };\n    InternalState2.prototype.executeQuery = function(options) {\n      var _this = this;\n      var _a;\n      if (options.query) {\n        Object.assign(this, { query: options.query });\n      }\n      this.watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n      var concast = this.observable.reobserveAsConcast(this.getObsQueryOptions());\n      this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n      this.result = void 0;\n      this.forceUpdate();\n      return new Promise(function(resolve) {\n        var result;\n        concast.subscribe({\n          next: function(value) {\n            result = value;\n          },\n          error: function() {\n            resolve(_this.toQueryResult(_this.observable.getCurrentResult()));\n          },\n          complete: function() {\n            resolve(_this.toQueryResult(result));\n          }\n        });\n      });\n    };\n    InternalState2.prototype.useQuery = function(options) {\n      var _this = this;\n      this.renderPromises = React.useContext(getApolloContext()).renderPromises;\n      this.useOptions(options);\n      var obsQuery = this.useObservableQuery();\n      var result = useSyncExternalStore(React.useCallback(function(handleStoreChange) {\n        if (_this.renderPromises) {\n          return function() {\n          };\n        }\n        _this.forceUpdate = handleStoreChange;\n        var onNext = function() {\n          var previousResult = _this.result;\n          var result2 = obsQuery.getCurrentResult();\n          if (previousResult && previousResult.loading === result2.loading && previousResult.networkStatus === result2.networkStatus && equal(previousResult.data, result2.data)) {\n            return;\n          }\n          _this.setResult(result2);\n        };\n        var onError = function(error) {\n          subscription.unsubscribe();\n          subscription = obsQuery.resubscribeAfterError(onNext, onError);\n          if (!hasOwnProperty.call(error, \"graphQLErrors\")) {\n            throw error;\n          }\n          var previousResult = _this.result;\n          if (!previousResult || previousResult && previousResult.loading || !equal(error, previousResult.error)) {\n            _this.setResult({\n              data: previousResult && previousResult.data,\n              error,\n              loading: false,\n              networkStatus: NetworkStatus.error\n            });\n          }\n        };\n        var subscription = obsQuery.subscribe(onNext, onError);\n        return function() {\n          setTimeout(function() {\n            return subscription.unsubscribe();\n          });\n          _this.forceUpdate = function() {\n            return _this.forceUpdateState();\n          };\n        };\n      }, [\n        // We memoize the subscribe function using useCallback and the following\n        // dependency keys, because the subscribe function reference is all that\n        // useSyncExternalStore uses internally as a dependency key for the\n        // useEffect ultimately responsible for the subscription, so we are\n        // effectively passing this dependency array to that useEffect buried\n        // inside useSyncExternalStore, as desired.\n        obsQuery,\n        this.renderPromises,\n        this.client.disableNetworkFetches\n      ]), function() {\n        return _this.getCurrentResult();\n      }, function() {\n        return _this.getCurrentResult();\n      });\n      this.unsafeHandlePartialRefetch(result);\n      return this.toQueryResult(result);\n    };\n    InternalState2.prototype.useOptions = function(options) {\n      var _a;\n      var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n      var currentWatchQueryOptions = this.watchQueryOptions;\n      if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\n        this.watchQueryOptions = watchQueryOptions;\n        if (currentWatchQueryOptions && this.observable) {\n          this.observable.reobserve(this.getObsQueryOptions());\n          this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n          this.result = void 0;\n        }\n      }\n      this.onCompleted = options.onCompleted || InternalState2.prototype.onCompleted;\n      this.onError = options.onError || InternalState2.prototype.onError;\n      if ((this.renderPromises || this.client.disableNetworkFetches) && this.queryHookOptions.ssr === false && !this.queryHookOptions.skip) {\n        this.result = this.ssrDisabledResult;\n      } else if (this.queryHookOptions.skip || this.watchQueryOptions.fetchPolicy === \"standby\") {\n        this.result = this.skipStandbyResult;\n      } else if (this.result === this.ssrDisabledResult || this.result === this.skipStandbyResult) {\n        this.result = void 0;\n      }\n    };\n    InternalState2.prototype.getObsQueryOptions = function() {\n      var toMerge = [];\n      var globalDefaults = this.client.defaultOptions.watchQuery;\n      if (globalDefaults)\n        toMerge.push(globalDefaults);\n      if (this.queryHookOptions.defaultOptions) {\n        toMerge.push(this.queryHookOptions.defaultOptions);\n      }\n      toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));\n      return toMerge.reduce(mergeOptions);\n    };\n    InternalState2.prototype.createWatchQueryOptions = function(_a) {\n      var _b;\n      if (_a === void 0) {\n        _a = {};\n      }\n      var skip = _a.skip, ssr = _a.ssr, onCompleted = _a.onCompleted, onError = _a.onError, defaultOptions = _a.defaultOptions, otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n      var watchQueryOptions = Object.assign(otherOptions, { query: this.query });\n      if (this.renderPromises && (watchQueryOptions.fetchPolicy === \"network-only\" || watchQueryOptions.fetchPolicy === \"cache-and-network\")) {\n        watchQueryOptions.fetchPolicy = \"cache-first\";\n      }\n      if (!watchQueryOptions.variables) {\n        watchQueryOptions.variables = {};\n      }\n      if (skip) {\n        var _c = watchQueryOptions.fetchPolicy, fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c, _d = watchQueryOptions.initialFetchPolicy, initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;\n        Object.assign(watchQueryOptions, {\n          initialFetchPolicy,\n          fetchPolicy: \"standby\"\n        });\n      } else if (!watchQueryOptions.fetchPolicy) {\n        watchQueryOptions.fetchPolicy = ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) || this.getDefaultFetchPolicy();\n      }\n      return watchQueryOptions;\n    };\n    InternalState2.prototype.getDefaultFetchPolicy = function() {\n      var _a, _b;\n      return ((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) || ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \"cache-first\";\n    };\n    InternalState2.prototype.onCompleted = function(data) {\n    };\n    InternalState2.prototype.onError = function(error) {\n    };\n    InternalState2.prototype.useObservableQuery = function() {\n      var obsQuery = this.observable = this.renderPromises && this.renderPromises.getSSRObservable(this.watchQueryOptions) || this.observable || // Reuse this.observable if possible (and not SSR)\n      this.client.watchQuery(this.getObsQueryOptions());\n      this.obsQueryFields = React.useMemo(function() {\n        return {\n          refetch: obsQuery.refetch.bind(obsQuery),\n          reobserve: obsQuery.reobserve.bind(obsQuery),\n          fetchMore: obsQuery.fetchMore.bind(obsQuery),\n          updateQuery: obsQuery.updateQuery.bind(obsQuery),\n          startPolling: obsQuery.startPolling.bind(obsQuery),\n          stopPolling: obsQuery.stopPolling.bind(obsQuery),\n          subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)\n        };\n      }, [obsQuery]);\n      var ssrAllowed = !(this.queryHookOptions.ssr === false || this.queryHookOptions.skip);\n      if (this.renderPromises && ssrAllowed) {\n        this.renderPromises.registerSSRObservable(obsQuery);\n        if (obsQuery.getCurrentResult().loading) {\n          this.renderPromises.addObservableQueryPromise(obsQuery);\n        }\n      }\n      return obsQuery;\n    };\n    InternalState2.prototype.setResult = function(nextResult) {\n      var previousResult = this.result;\n      if (previousResult && previousResult.data) {\n        this.previousData = previousResult.data;\n      }\n      this.result = nextResult;\n      this.forceUpdate();\n      this.handleErrorOrCompleted(nextResult, previousResult);\n    };\n    InternalState2.prototype.handleErrorOrCompleted = function(result, previousResult) {\n      var _this = this;\n      if (!result.loading) {\n        var error_1 = this.toApolloError(result);\n        Promise.resolve().then(function() {\n          if (error_1) {\n            _this.onError(error_1);\n          } else if (result.data && (previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus) !== result.networkStatus && result.networkStatus === NetworkStatus.ready) {\n            _this.onCompleted(result.data);\n          }\n        }).catch(function(error) {\n          globalThis.__DEV__ !== false && invariant.warn(error);\n        });\n      }\n    };\n    InternalState2.prototype.toApolloError = function(result) {\n      return isNonEmptyArray(result.errors) ? new ApolloError({ graphQLErrors: result.errors }) : result.error;\n    };\n    InternalState2.prototype.getCurrentResult = function() {\n      if (!this.result) {\n        this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());\n      }\n      return this.result;\n    };\n    InternalState2.prototype.toQueryResult = function(result) {\n      var queryResult = this.toQueryResultCache.get(result);\n      if (queryResult)\n        return queryResult;\n      var data = result.data, partial = result.partial, resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n      this.toQueryResultCache.set(result, queryResult = __assign(__assign(__assign({ data }, resultWithoutPartial), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData }));\n      if (!queryResult.error && isNonEmptyArray(result.errors)) {\n        queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n      }\n      return queryResult;\n    };\n    InternalState2.prototype.unsafeHandlePartialRefetch = function(result) {\n      if (result.partial && this.queryHookOptions.partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && this.observable.options.fetchPolicy !== \"cache-only\") {\n        Object.assign(result, {\n          loading: true,\n          networkStatus: NetworkStatus.refetch\n        });\n        this.observable.refetch();\n      }\n    };\n    return InternalState2;\n  }()\n);\n",
      "start": 1716304642840,
      "end": 1716304643239,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/react/hooks/useQuery.js\"],\n  \"sourcesContent\": [\"import { __assign, __rest } from \\\"tslib\\\";\\nimport { invariant } from \\\"../../utilities/globals/index.js\\\";\\nimport * as React from \\\"rehackt\\\";\\nimport { useSyncExternalStore } from \\\"./useSyncExternalStore.js\\\";\\nimport { equal } from \\\"@wry/equality\\\";\\nimport { mergeOptions } from \\\"../../utilities/index.js\\\";\\nimport { getApolloContext } from \\\"../context/index.js\\\";\\nimport { ApolloError } from \\\"../../errors/index.js\\\";\\nimport { NetworkStatus } from \\\"../../core/index.js\\\";\\nimport { DocumentType, verifyDocumentType } from \\\"../parser/index.js\\\";\\nimport { useApolloClient } from \\\"./useApolloClient.js\\\";\\nimport { canUseWeakMap, compact, isNonEmptyArray, maybeDeepFreeze, } from \\\"../../utilities/index.js\\\";\\nimport { wrapHook } from \\\"./internal/index.js\\\";\\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\\n/**\\n * A hook for executing queries in an Apollo application.\\n *\\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\\n *\\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, and `data` properties you can use to render your UI.\\n *\\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\\n *\\n * @example\\n * ```jsx\\n * import { gql, useQuery } from '@apollo/client';\\n *\\n * const GET_GREETING = gql`\\n *   query GetGreeting($language: String!) {\\n *     greeting(language: $language) {\\n *       message\\n *     }\\n *   }\\n * `;\\n *\\n * function Hello() {\\n *   const { loading, error, data } = useQuery(GET_GREETING, {\\n *     variables: { language: 'english' },\\n *   });\\n *   if (loading) return <p>Loading ...</p>;\\n *   return <h1>Hello {data.greeting.message}!</h1>;\\n * }\\n * ```\\n * @since 3.0.0\\n * @param query - A GraphQL query document parsed into an AST by `gql`.\\n * @param options - Options to control how the query is executed.\\n * @returns Query result object\\n */\\nexport function useQuery(query, options) {\\n    if (options === void 0) { options = Object.create(null); }\\n    return wrapHook(\\\"useQuery\\\", _useQuery, useApolloClient(options && options.client))(query, options);\\n}\\nfunction _useQuery(query, options) {\\n    return useInternalState(useApolloClient(options.client), query).useQuery(options);\\n}\\nexport function useInternalState(client, query) {\\n    var stateRef = React.useRef();\\n    if (!stateRef.current ||\\n        client !== stateRef.current.client ||\\n        query !== stateRef.current.query) {\\n        stateRef.current = new InternalState(client, query, stateRef.current);\\n    }\\n    var state = stateRef.current;\\n    // By default, InternalState.prototype.forceUpdate is an empty function, but\\n    // we replace it here (before anyone has had a chance to see this state yet)\\n    // with a function that unconditionally forces an update, using the latest\\n    // setTick function. Updating this state by calling state.forceUpdate is the\\n    // only way we trigger React component updates (no other useState calls within\\n    // the InternalState class).\\n    state.forceUpdateState = React.useReducer(function (tick) { return tick + 1; }, 0)[1];\\n    return state;\\n}\\nvar InternalState = /** @class */ (function () {\\n    function InternalState(client, query, previous) {\\n        var _this = this;\\n        this.client = client;\\n        this.query = query;\\n        /**\\n         * Will be overwritten by the `useSyncExternalStore` \\\"force update\\\" method\\n         * whenever it is available and reset to `forceUpdateState` when it isn't.\\n         */\\n        this.forceUpdate = function () { return _this.forceUpdateState(); };\\n        this.ssrDisabledResult = maybeDeepFreeze({\\n            loading: true,\\n            data: void 0,\\n            error: void 0,\\n            networkStatus: NetworkStatus.loading,\\n        });\\n        this.skipStandbyResult = maybeDeepFreeze({\\n            loading: false,\\n            data: void 0,\\n            error: void 0,\\n            networkStatus: NetworkStatus.ready,\\n        });\\n        // This cache allows the referential stability of this.result (as returned by\\n        // getCurrentResult) to translate into referential stability of the resulting\\n        // QueryResult object returned by toQueryResult.\\n        this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();\\n        verifyDocumentType(query, DocumentType.Query);\\n        // Reuse previousData from previous InternalState (if any) to provide\\n        // continuity of previousData even if/when the query or client changes.\\n        var previousResult = previous && previous.result;\\n        var previousData = previousResult && previousResult.data;\\n        if (previousData) {\\n            this.previousData = previousData;\\n        }\\n    }\\n    /**\\n     * Forces an update using local component state.\\n     * As this is not batched with `useSyncExternalStore` updates,\\n     * this is only used as a fallback if the `useSyncExternalStore` \\\"force update\\\"\\n     * method is not registered at the moment.\\n     * See https://github.com/facebook/react/issues/25191\\n     *  */\\n    InternalState.prototype.forceUpdateState = function () {\\n        // Replaced (in useInternalState) with a method that triggers an update.\\n        globalThis.__DEV__ !== false && invariant.warn(51);\\n    };\\n    InternalState.prototype.executeQuery = function (options) {\\n        var _this = this;\\n        var _a;\\n        if (options.query) {\\n            Object.assign(this, { query: options.query });\\n        }\\n        this.watchQueryOptions = this.createWatchQueryOptions((this.queryHookOptions = options));\\n        var concast = this.observable.reobserveAsConcast(this.getObsQueryOptions());\\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\\n        // but save the current data as this.previousData, just like setResult\\n        // usually does.\\n        this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\\n        this.result = void 0;\\n        this.forceUpdate();\\n        return new Promise(function (resolve) {\\n            var result;\\n            // Subscribe to the concast independently of the ObservableQuery in case\\n            // the component gets unmounted before the promise resolves. This prevents\\n            // the concast from terminating early and resolving with `undefined` when\\n            // there are no more subscribers for the concast.\\n            concast.subscribe({\\n                next: function (value) {\\n                    result = value;\\n                },\\n                error: function () {\\n                    resolve(_this.toQueryResult(_this.observable.getCurrentResult()));\\n                },\\n                complete: function () {\\n                    resolve(_this.toQueryResult(result));\\n                },\\n            });\\n        });\\n    };\\n    // Methods beginning with use- should be called according to the standard\\n    // rules of React hooks: only at the top level of the calling function, and\\n    // without any dynamic conditional logic.\\n    InternalState.prototype.useQuery = function (options) {\\n        var _this = this;\\n        // The renderPromises field gets initialized here in the useQuery method, at\\n        // the beginning of everything (for a given component rendering, at least),\\n        // so we can safely use this.renderPromises in other/later InternalState\\n        // methods without worrying it might be uninitialized. Even after\\n        // initialization, this.renderPromises is usually undefined (unless SSR is\\n        // happening), but that's fine as long as it has been initialized that way,\\n        // rather than left uninitialized.\\n        this.renderPromises = React.useContext(getApolloContext()).renderPromises;\\n        this.useOptions(options);\\n        var obsQuery = this.useObservableQuery();\\n        var result = useSyncExternalStore(React.useCallback(function (handleStoreChange) {\\n            if (_this.renderPromises) {\\n                return function () { };\\n            }\\n            _this.forceUpdate = handleStoreChange;\\n            var onNext = function () {\\n                var previousResult = _this.result;\\n                // We use `getCurrentResult()` instead of the onNext argument because\\n                // the values differ slightly. Specifically, loading results will have\\n                // an empty object for data instead of `undefined` for some reason.\\n                var result = obsQuery.getCurrentResult();\\n                // Make sure we're not attempting to re-render similar results\\n                if (previousResult &&\\n                    previousResult.loading === result.loading &&\\n                    previousResult.networkStatus === result.networkStatus &&\\n                    equal(previousResult.data, result.data)) {\\n                    return;\\n                }\\n                _this.setResult(result);\\n            };\\n            var onError = function (error) {\\n                subscription.unsubscribe();\\n                subscription = obsQuery.resubscribeAfterError(onNext, onError);\\n                if (!hasOwnProperty.call(error, \\\"graphQLErrors\\\")) {\\n                    // The error is not a GraphQL error\\n                    throw error;\\n                }\\n                var previousResult = _this.result;\\n                if (!previousResult ||\\n                    (previousResult && previousResult.loading) ||\\n                    !equal(error, previousResult.error)) {\\n                    _this.setResult({\\n                        data: (previousResult && previousResult.data),\\n                        error: error,\\n                        loading: false,\\n                        networkStatus: NetworkStatus.error,\\n                    });\\n                }\\n            };\\n            var subscription = obsQuery.subscribe(onNext, onError);\\n            // Do the \\\"unsubscribe\\\" with a short delay.\\n            // This way, an existing subscription can be reused without an additional\\n            // request if \\\"unsubscribe\\\"  and \\\"resubscribe\\\" to the same ObservableQuery\\n            // happen in very fast succession.\\n            return function () {\\n                setTimeout(function () { return subscription.unsubscribe(); });\\n                _this.forceUpdate = function () { return _this.forceUpdateState(); };\\n            };\\n        }, [\\n            // We memoize the subscribe function using useCallback and the following\\n            // dependency keys, because the subscribe function reference is all that\\n            // useSyncExternalStore uses internally as a dependency key for the\\n            // useEffect ultimately responsible for the subscription, so we are\\n            // effectively passing this dependency array to that useEffect buried\\n            // inside useSyncExternalStore, as desired.\\n            obsQuery,\\n            this.renderPromises,\\n            this.client.disableNetworkFetches,\\n        ]), function () { return _this.getCurrentResult(); }, function () { return _this.getCurrentResult(); });\\n        // TODO Remove this method when we remove support for options.partialRefetch.\\n        this.unsafeHandlePartialRefetch(result);\\n        return this.toQueryResult(result);\\n    };\\n    InternalState.prototype.useOptions = function (options) {\\n        var _a;\\n        var watchQueryOptions = this.createWatchQueryOptions((this.queryHookOptions = options));\\n        // Update this.watchQueryOptions, but only when they have changed, which\\n        // allows us to depend on the referential stability of\\n        // this.watchQueryOptions elsewhere.\\n        var currentWatchQueryOptions = this.watchQueryOptions;\\n        if (!equal(watchQueryOptions, currentWatchQueryOptions)) {\\n            this.watchQueryOptions = watchQueryOptions;\\n            if (currentWatchQueryOptions && this.observable) {\\n                // Though it might be tempting to postpone this reobserve call to the\\n                // useEffect block, we need getCurrentResult to return an appropriate\\n                // loading:true result synchronously (later within the same call to\\n                // useQuery). Since we already have this.observable here (not true for\\n                // the very first call to useQuery), we are not initiating any new\\n                // subscriptions, though it does feel less than ideal that reobserve\\n                // (potentially) kicks off a network request (for example, when the\\n                // variables have changed), which is technically a side-effect.\\n                this.observable.reobserve(this.getObsQueryOptions());\\n                // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\\n                // but save the current data as this.previousData, just like setResult\\n                // usually does.\\n                this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\\n                this.result = void 0;\\n            }\\n        }\\n        // Make sure state.onCompleted and state.onError always reflect the latest\\n        // options.onCompleted and options.onError callbacks provided to useQuery,\\n        // since those functions are often recreated every time useQuery is called.\\n        // Like the forceUpdate method, the versions of these methods inherited from\\n        // InternalState.prototype are empty no-ops, but we can override them on the\\n        // base state object (without modifying the prototype).\\n        this.onCompleted =\\n            options.onCompleted || InternalState.prototype.onCompleted;\\n        this.onError = options.onError || InternalState.prototype.onError;\\n        if ((this.renderPromises || this.client.disableNetworkFetches) &&\\n            this.queryHookOptions.ssr === false &&\\n            !this.queryHookOptions.skip) {\\n            // If SSR has been explicitly disabled, and this function has been called\\n            // on the server side, return the default loading state.\\n            this.result = this.ssrDisabledResult;\\n        }\\n        else if (this.queryHookOptions.skip ||\\n            this.watchQueryOptions.fetchPolicy === \\\"standby\\\") {\\n            // When skipping a query (ie. we're not querying for data but still want to\\n            // render children), make sure the `data` is cleared out and `loading` is\\n            // set to `false` (since we aren't loading anything).\\n            //\\n            // NOTE: We no longer think this is the correct behavior. Skipping should\\n            // not automatically set `data` to `undefined`, but instead leave the\\n            // previous data in place. In other words, skipping should not mandate that\\n            // previously received data is all of a sudden removed. Unfortunately,\\n            // changing this is breaking, so we'll have to wait until Apollo Client 4.0\\n            // to address this.\\n            this.result = this.skipStandbyResult;\\n        }\\n        else if (this.result === this.ssrDisabledResult ||\\n            this.result === this.skipStandbyResult) {\\n            this.result = void 0;\\n        }\\n    };\\n    InternalState.prototype.getObsQueryOptions = function () {\\n        var toMerge = [];\\n        var globalDefaults = this.client.defaultOptions.watchQuery;\\n        if (globalDefaults)\\n            toMerge.push(globalDefaults);\\n        if (this.queryHookOptions.defaultOptions) {\\n            toMerge.push(this.queryHookOptions.defaultOptions);\\n        }\\n        // We use compact rather than mergeOptions for this part of the merge,\\n        // because we want watchQueryOptions.variables (if defined) to replace\\n        // this.observable.options.variables whole. This replacement allows\\n        // removing variables by removing them from the variables input to\\n        // useQuery. If the variables were always merged together (rather than\\n        // replaced), there would be no way to remove existing variables.\\n        // However, the variables from options.defaultOptions and globalDefaults\\n        // (if provided) should be merged, to ensure individual defaulted\\n        // variables always have values, if not otherwise defined in\\n        // observable.options or watchQueryOptions.\\n        toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));\\n        return toMerge.reduce(mergeOptions);\\n    };\\n    // A function to massage options before passing them to ObservableQuery.\\n    InternalState.prototype.createWatchQueryOptions = function (_a) {\\n        var _b;\\n        if (_a === void 0) { _a = {}; }\\n        var skip = _a.skip, ssr = _a.ssr, onCompleted = _a.onCompleted, onError = _a.onError, defaultOptions = _a.defaultOptions, \\n        // The above options are useQuery-specific, so this ...otherOptions spread\\n        // makes otherOptions almost a WatchQueryOptions object, except for the\\n        // query property that we add below.\\n        otherOptions = __rest(_a, [\\\"skip\\\", \\\"ssr\\\", \\\"onCompleted\\\", \\\"onError\\\", \\\"defaultOptions\\\"]);\\n        // This Object.assign is safe because otherOptions is a fresh ...rest object\\n        // that did not exist until just now, so modifications are still allowed.\\n        var watchQueryOptions = Object.assign(otherOptions, { query: this.query });\\n        if (this.renderPromises &&\\n            (watchQueryOptions.fetchPolicy === \\\"network-only\\\" ||\\n                watchQueryOptions.fetchPolicy === \\\"cache-and-network\\\")) {\\n            // this behavior was added to react-apollo without explanation in this PR\\n            // https://github.com/apollographql/react-apollo/pull/1579\\n            watchQueryOptions.fetchPolicy = \\\"cache-first\\\";\\n        }\\n        if (!watchQueryOptions.variables) {\\n            watchQueryOptions.variables = {};\\n        }\\n        if (skip) {\\n            var _c = watchQueryOptions.fetchPolicy, fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c, _d = watchQueryOptions.initialFetchPolicy, initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;\\n            // When skipping, we set watchQueryOptions.fetchPolicy initially to\\n            // \\\"standby\\\", but we also need/want to preserve the initial non-standby\\n            // fetchPolicy that would have been used if not skipping.\\n            Object.assign(watchQueryOptions, {\\n                initialFetchPolicy: initialFetchPolicy,\\n                fetchPolicy: \\\"standby\\\",\\n            });\\n        }\\n        else if (!watchQueryOptions.fetchPolicy) {\\n            watchQueryOptions.fetchPolicy =\\n                ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) ||\\n                    this.getDefaultFetchPolicy();\\n        }\\n        return watchQueryOptions;\\n    };\\n    InternalState.prototype.getDefaultFetchPolicy = function () {\\n        var _a, _b;\\n        return (((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||\\n            ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) ||\\n            \\\"cache-first\\\");\\n    };\\n    // Defining these methods as no-ops on the prototype allows us to call\\n    // state.onCompleted and/or state.onError without worrying about whether a\\n    // callback was provided.\\n    InternalState.prototype.onCompleted = function (data) { };\\n    InternalState.prototype.onError = function (error) { };\\n    InternalState.prototype.useObservableQuery = function () {\\n        // See if there is an existing observable that was used to fetch the same\\n        // data and if so, use it instead since it will contain the proper queryId\\n        // to fetch the result set. This is used during SSR.\\n        var obsQuery = (this.observable =\\n            (this.renderPromises &&\\n                this.renderPromises.getSSRObservable(this.watchQueryOptions)) ||\\n                this.observable || // Reuse this.observable if possible (and not SSR)\\n                this.client.watchQuery(this.getObsQueryOptions()));\\n        this.obsQueryFields = React.useMemo(function () { return ({\\n            refetch: obsQuery.refetch.bind(obsQuery),\\n            reobserve: obsQuery.reobserve.bind(obsQuery),\\n            fetchMore: obsQuery.fetchMore.bind(obsQuery),\\n            updateQuery: obsQuery.updateQuery.bind(obsQuery),\\n            startPolling: obsQuery.startPolling.bind(obsQuery),\\n            stopPolling: obsQuery.stopPolling.bind(obsQuery),\\n            subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\\n        }); }, [obsQuery]);\\n        var ssrAllowed = !(this.queryHookOptions.ssr === false || this.queryHookOptions.skip);\\n        if (this.renderPromises && ssrAllowed) {\\n            this.renderPromises.registerSSRObservable(obsQuery);\\n            if (obsQuery.getCurrentResult().loading) {\\n                // TODO: This is a legacy API which could probably be cleaned up\\n                this.renderPromises.addObservableQueryPromise(obsQuery);\\n            }\\n        }\\n        return obsQuery;\\n    };\\n    InternalState.prototype.setResult = function (nextResult) {\\n        var previousResult = this.result;\\n        if (previousResult && previousResult.data) {\\n            this.previousData = previousResult.data;\\n        }\\n        this.result = nextResult;\\n        // Calling state.setResult always triggers an update, though some call sites\\n        // perform additional equality checks before committing to an update.\\n        this.forceUpdate();\\n        this.handleErrorOrCompleted(nextResult, previousResult);\\n    };\\n    InternalState.prototype.handleErrorOrCompleted = function (result, previousResult) {\\n        var _this = this;\\n        if (!result.loading) {\\n            var error_1 = this.toApolloError(result);\\n            // wait a tick in case we are in the middle of rendering a component\\n            Promise.resolve()\\n                .then(function () {\\n                if (error_1) {\\n                    _this.onError(error_1);\\n                }\\n                else if (result.data &&\\n                    (previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus) !== result.networkStatus &&\\n                    result.networkStatus === NetworkStatus.ready) {\\n                    _this.onCompleted(result.data);\\n                }\\n            })\\n                .catch(function (error) {\\n                globalThis.__DEV__ !== false && invariant.warn(error);\\n            });\\n        }\\n    };\\n    InternalState.prototype.toApolloError = function (result) {\\n        return isNonEmptyArray(result.errors) ?\\n            new ApolloError({ graphQLErrors: result.errors })\\n            : result.error;\\n    };\\n    InternalState.prototype.getCurrentResult = function () {\\n        // Using this.result as a cache ensures getCurrentResult continues returning\\n        // the same (===) result object, unless state.setResult has been called, or\\n        // we're doing server rendering and therefore override the result below.\\n        if (!this.result) {\\n            this.handleErrorOrCompleted((this.result = this.observable.getCurrentResult()));\\n        }\\n        return this.result;\\n    };\\n    InternalState.prototype.toQueryResult = function (result) {\\n        var queryResult = this.toQueryResultCache.get(result);\\n        if (queryResult)\\n            return queryResult;\\n        var data = result.data, partial = result.partial, resultWithoutPartial = __rest(result, [\\\"data\\\", \\\"partial\\\"]);\\n        this.toQueryResultCache.set(result, (queryResult = __assign(__assign(__assign({ data: data }, resultWithoutPartial), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData })));\\n        if (!queryResult.error && isNonEmptyArray(result.errors)) {\\n            // Until a set naming convention for networkError and graphQLErrors is\\n            // decided upon, we map errors (graphQLErrors) to the error options.\\n            // TODO: Is it possible for both result.error and result.errors to be\\n            // defined here?\\n            queryResult.error = new ApolloError({ graphQLErrors: result.errors });\\n        }\\n        return queryResult;\\n    };\\n    InternalState.prototype.unsafeHandlePartialRefetch = function (result) {\\n        // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\\n        //\\n        // TODO: This code should be removed when the partialRefetch option is\\n        // removed. I was unable to get this hook to behave reasonably in certain\\n        // edge cases when this block was put in an effect.\\n        if (result.partial &&\\n            this.queryHookOptions.partialRefetch &&\\n            !result.loading &&\\n            (!result.data || Object.keys(result.data).length === 0) &&\\n            this.observable.options.fetchPolicy !== \\\"cache-only\\\") {\\n            Object.assign(result, {\\n                loading: true,\\n                networkStatus: NetworkStatus.refetch,\\n            });\\n            this.observable.refetch();\\n        }\\n    };\\n    return InternalState;\\n}());\\n//# sourceMappingURL=useQuery.js.map\"],\n  \"mappings\": \"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\",\n  \"names\": [\"InternalState\", \"result\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1716304643239,
      "end": 1716304643239,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1716304643239,
      "end": 1716304643239,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1716304643239,
      "end": 1716304643239,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1716304643239,
      "end": 1716304643239,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1716304643239,
      "end": 1716304643240,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1716304643240,
      "end": 1716304643240,
      "order": "normal"
    }
  ]
}
