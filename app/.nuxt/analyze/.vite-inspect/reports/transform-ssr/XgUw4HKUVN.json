{
  "resolvedId": "/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/cache/inmemory/writeToStore.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { Kind } from \"graphql\";\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField, canonicalStringify, } from \"../../utilities/index.js\";\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext, } from \"./helpers.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\n// Since there are only four possible combinations of context.clientOnly and\n// context.deferred values, we should need at most four \"flavors\" of any given\n// WriteContext. To avoid creating multiple copies of the same context, we cache\n// the contexts in the context.flavors Map (shared by all flavors) according to\n// their clientOnly and deferred values (always in that order).\nfunction getContextFlavor(context, clientOnly, deferred) {\n    var key = \"\".concat(clientOnly).concat(deferred);\n    var flavored = context.flavors.get(key);\n    if (!flavored) {\n        context.flavors.set(key, (flavored =\n            context.clientOnly === clientOnly && context.deferred === deferred ?\n                context\n                : __assign(__assign({}, context), { clientOnly: clientOnly, deferred: deferred })));\n    }\n    return flavored;\n}\nvar StoreWriter = /** @class */ (function () {\n    function StoreWriter(cache, reader, fragments) {\n        this.cache = cache;\n        this.reader = reader;\n        this.fragments = fragments;\n    }\n    StoreWriter.prototype.writeToStore = function (store, _a) {\n        var _this = this;\n        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;\n        var operationDefinition = getOperationDefinition(query);\n        var merger = makeProcessedFieldsMerger();\n        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n        var context = __assign(__assign({ store: store, written: Object.create(null), merge: function (existing, incoming) {\n                return merger.merge(existing, incoming);\n            }, variables: variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: new Map(), clientOnly: false, deferred: false, flavors: new Map() });\n        var ref = this.processSelectionSet({\n            result: result || Object.create(null),\n            dataId: dataId,\n            selectionSet: operationDefinition.selectionSet,\n            mergeTree: { map: new Map() },\n            context: context,\n        });\n        if (!isReference(ref)) {\n            throw newInvariantError(11, result);\n        }\n        // So far, the store has not been modified, so now it's time to process\n        // context.incomingById and merge those incoming fields into context.store.\n        context.incomingById.forEach(function (_a, dataId) {\n            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;\n            var entityRef = makeReference(dataId);\n            if (mergeTree && mergeTree.map.size) {\n                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n                if (isReference(applied)) {\n                    // Assume References returned by applyMerges have already been merged\n                    // into the store. See makeMergeObjectsFunction in policies.ts for an\n                    // example of how this can happen.\n                    return;\n                }\n                // Otherwise, applyMerges returned a StoreObject, whose fields we should\n                // merge into the store (see store.merge statement below).\n                storeObject = applied;\n            }\n            if (globalThis.__DEV__ !== false && !context.overwrite) {\n                var fieldsWithSelectionSets_1 = Object.create(null);\n                fieldNodeSet.forEach(function (field) {\n                    if (field.selectionSet) {\n                        fieldsWithSelectionSets_1[field.name.value] = true;\n                    }\n                });\n                var hasSelectionSet_1 = function (storeFieldName) {\n                    return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] ===\n                        true;\n                };\n                var hasMergeFunction_1 = function (storeFieldName) {\n                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n                    return Boolean(childTree && childTree.info && childTree.info.merge);\n                };\n                Object.keys(storeObject).forEach(function (storeFieldName) {\n                    // If a merge function was defined for this field, trust that it\n                    // did the right thing about (not) clobbering data. If the field\n                    // has no selection set, it's a scalar field, so it doesn't need\n                    // a merge function (even if it's an object, like JSON data).\n                    if (hasSelectionSet_1(storeFieldName) &&\n                        !hasMergeFunction_1(storeFieldName)) {\n                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n                    }\n                });\n            }\n            store.merge(dataId, storeObject);\n        });\n        // Any IDs written explicitly to the cache will be retained as\n        // reachable root IDs for garbage collection purposes. Although this\n        // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\n        // retainment counts are effectively ignored because cache.gc() always\n        // includes them in its root ID set.\n        store.retain(ref.__ref);\n        return ref;\n    };\n    StoreWriter.prototype.processSelectionSet = function (_a) {\n        var _this = this;\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, \n        // This object allows processSelectionSet to report useful information\n        // to its callers without explicitly returning that information.\n        mergeTree = _a.mergeTree;\n        var policies = this.cache.policies;\n        // This variable will be repeatedly updated using context.merge to\n        // accumulate all fields that need to be written into the store.\n        var incoming = Object.create(null);\n        // If typename was not passed in, infer it. Note that typename is\n        // always passed in for tricky-to-infer cases such as \"Query\" for\n        // ROOT_QUERY.\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n            (dataId && context.store.get(dataId, \"__typename\"));\n        if (\"string\" === typeof typename) {\n            incoming.__typename = typename;\n        }\n        // This readField function will be passed as context.readField in the\n        // KeyFieldsContext object created within policies.identify (called below).\n        // In addition to reading from the existing context.store (thanks to the\n        // policies.readField(options, context) line at the very bottom), this\n        // version of readField can read from Reference objects that are currently\n        // pending in context.incomingById, which is important whenever keyFields\n        // need to be extracted from a child object that processSelectionSet has\n        // turned into a Reference.\n        var readField = function () {\n            var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n            if (isReference(options.from)) {\n                var info = context.incomingById.get(options.from.__ref);\n                if (info) {\n                    var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);\n                    if (result_1 !== void 0) {\n                        return result_1;\n                    }\n                }\n            }\n            return policies.readField(options, context);\n        };\n        var fieldNodeSet = new Set();\n        this.flattenFields(selectionSet, result, \n        // This WriteContext will be the default context value for fields returned\n        // by the flattenFields method, but some fields may be assigned a modified\n        // context, depending on the presence of @client and other directives.\n        context, typename).forEach(function (context, field) {\n            var _a;\n            var resultFieldKey = resultKeyNameFromField(field);\n            var value = result[resultFieldKey];\n            fieldNodeSet.add(field);\n            if (value !== void 0) {\n                var storeFieldName = policies.getStoreFieldName({\n                    typename: typename,\n                    fieldName: field.name.value,\n                    field: field,\n                    variables: context.variables,\n                });\n                var childTree = getChildMergeTree(mergeTree, storeFieldName);\n                var incomingValue = _this.processFieldValue(value, field, \n                // Reset context.clientOnly and context.deferred to their default\n                // values before processing nested selection sets.\n                field.selectionSet ?\n                    getContextFlavor(context, false, false)\n                    : context, childTree);\n                // To determine if this field holds a child object with a merge function\n                // defined in its type policy (see PR #7070), we need to figure out the\n                // child object's __typename.\n                var childTypename = void 0;\n                // The field's value can be an object that has a __typename only if the\n                // field has a selection set. Otherwise incomingValue is scalar.\n                if (field.selectionSet &&\n                    (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n                    childTypename = readField(\"__typename\", incomingValue);\n                }\n                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n                if (merge) {\n                    childTree.info = {\n                        // TODO Check compatibility against any existing childTree.field?\n                        field: field,\n                        typename: typename,\n                        merge: merge,\n                    };\n                }\n                else {\n                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n                }\n                incoming = context.merge(incoming, (_a = {},\n                    _a[storeFieldName] = incomingValue,\n                    _a));\n            }\n            else if (globalThis.__DEV__ !== false &&\n                !context.clientOnly &&\n                !context.deferred &&\n                !addTypenameToDocument.added(field) &&\n                // If the field has a read function, it may be a synthetic field or\n                // provide a default value, so its absence from the written data should\n                // not be cause for alarm.\n                !policies.getReadFunction(typename, field.name.value)) {\n                globalThis.__DEV__ !== false && invariant.error(12, resultKeyNameFromField(field), result);\n            }\n        });\n        // Identify the result object, even if dataId was already provided,\n        // since we always need keyObject below.\n        try {\n            var _b = policies.identify(result, {\n                typename: typename,\n                selectionSet: selectionSet,\n                fragmentMap: context.fragmentMap,\n                storeObject: incoming,\n                readField: readField,\n            }), id = _b[0], keyObject = _b[1];\n            // If dataId was not provided, fall back to the id just generated by\n            // policies.identify.\n            dataId = dataId || id;\n            // Write any key fields that were used during identification, even if\n            // they were not mentioned in the original query.\n            if (keyObject) {\n                // TODO Reverse the order of the arguments?\n                incoming = context.merge(incoming, keyObject);\n            }\n        }\n        catch (e) {\n            // If dataId was provided, tolerate failure of policies.identify.\n            if (!dataId)\n                throw e;\n        }\n        if (\"string\" === typeof dataId) {\n            var dataRef = makeReference(dataId);\n            // Avoid processing the same entity object using the same selection\n            // set more than once. We use an array instead of a Set since most\n            // entity IDs will be written using only one selection set, so the\n            // size of this array is likely to be very small, meaning indexOf is\n            // likely to be faster than Set.prototype.has.\n            var sets = context.written[dataId] || (context.written[dataId] = []);\n            if (sets.indexOf(selectionSet) >= 0)\n                return dataRef;\n            sets.push(selectionSet);\n            // If we're about to write a result object into the store, but we\n            // happen to know that the exact same (===) result object would be\n            // returned if we were to reread the result with the same inputs,\n            // then we can skip the rest of the processSelectionSet work for\n            // this object, and immediately return a Reference to it.\n            if (this.reader &&\n                this.reader.isFresh(result, dataRef, selectionSet, context)) {\n                return dataRef;\n            }\n            var previous_1 = context.incomingById.get(dataId);\n            if (previous_1) {\n                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n                fieldNodeSet.forEach(function (field) { return previous_1.fieldNodeSet.add(field); });\n            }\n            else {\n                context.incomingById.set(dataId, {\n                    storeObject: incoming,\n                    // Save a reference to mergeTree only if it is not empty, because\n                    // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n                    // reused for entirely different parts of the result tree.\n                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n                    fieldNodeSet: fieldNodeSet,\n                });\n            }\n            return dataRef;\n        }\n        return incoming;\n    };\n    StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n        var _this = this;\n        if (!field.selectionSet || value === null) {\n            // In development, we need to clone scalar values so that they can be\n            // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\n            // it's cheaper to store the scalar values directly in the cache.\n            return globalThis.__DEV__ !== false ? cloneDeep(value) : value;\n        }\n        if (isArray(value)) {\n            return value.map(function (item, i) {\n                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n                maybeRecycleChildMergeTree(mergeTree, i);\n                return value;\n            });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context: context,\n            mergeTree: mergeTree,\n        });\n    };\n    // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\n    // some additions for tracking @client and @defer directives.\n    StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n        if (typename === void 0) { typename = getTypenameFromResult(result, selectionSet, context.fragmentMap); }\n        var fieldMap = new Map();\n        var policies = this.cache.policies;\n        var limitingTrie = new Trie(false); // No need for WeakMap, since limitingTrie does not escape.\n        (function flatten(selectionSet, inheritedContext) {\n            var visitedNode = limitingTrie.lookup(selectionSet, \n            // Because we take inheritedClientOnly and inheritedDeferred into\n            // consideration here (in addition to selectionSet), it's possible for\n            // the same selection set to be flattened more than once, if it appears\n            // in the query with different @client and/or @directive configurations.\n            inheritedContext.clientOnly, inheritedContext.deferred);\n            if (visitedNode.visited)\n                return;\n            visitedNode.visited = true;\n            selectionSet.selections.forEach(function (selection) {\n                if (!shouldInclude(selection, context.variables))\n                    return;\n                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;\n                if (\n                // Since the presence of @client or @defer on this field can only\n                // cause clientOnly or deferred to become true, we can skip the\n                // forEach loop if both clientOnly and deferred are already true.\n                !(clientOnly && deferred) &&\n                    isNonEmptyArray(selection.directives)) {\n                    selection.directives.forEach(function (dir) {\n                        var name = dir.name.value;\n                        if (name === \"client\")\n                            clientOnly = true;\n                        if (name === \"defer\") {\n                            var args = argumentsObjectFromField(dir, context.variables);\n                            // The @defer directive takes an optional args.if boolean\n                            // argument, similar to @include(if: boolean). Note that\n                            // @defer(if: false) does not make context.deferred false, but\n                            // instead behaves as if there was no @defer directive.\n                            if (!args || args.if !== false) {\n                                deferred = true;\n                            }\n                            // TODO In the future, we may want to record args.label using\n                            // context.deferred, if a label is specified.\n                        }\n                    });\n                }\n                if (isField(selection)) {\n                    var existing = fieldMap.get(selection);\n                    if (existing) {\n                        // If this field has been visited along another recursive path\n                        // before, the final context should have clientOnly or deferred set\n                        // to true only if *all* paths have the directive (hence the &&).\n                        clientOnly = clientOnly && existing.clientOnly;\n                        deferred = deferred && existing.deferred;\n                    }\n                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n                }\n                else {\n                    var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n                    if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n                        throw newInvariantError(13, selection.name.value);\n                    }\n                    if (fragment &&\n                        policies.fragmentMatches(fragment, typename, result, context.variables)) {\n                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n                    }\n                }\n            });\n        })(selectionSet, context);\n        return fieldMap;\n    };\n    StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n        var _a;\n        var _this = this;\n        if (mergeTree.map.size && !isReference(incoming)) {\n            var e_1 = \n            // Items in the same position in different arrays are not\n            // necessarily related to each other, so when incoming is an array\n            // we process its elements as if there was no existing data.\n            (!isArray(incoming) &&\n                // Likewise, existing must be either a Reference or a StoreObject\n                // in order for its fields to be safe to merge with the fields of\n                // the incoming object.\n                (isReference(existing) || storeValueIsStoreObject(existing))) ?\n                existing\n                : void 0;\n            // This narrowing is implied by mergeTree.map.size > 0 and\n            // !isReference(incoming), though TypeScript understandably cannot\n            // hope to infer this type.\n            var i_1 = incoming;\n            // The options.storage objects provided to read and merge functions\n            // are derived from the identity of the parent object plus a\n            // sequence of storeFieldName strings/numbers identifying the nested\n            // field name path of each field value to be merged.\n            if (e_1 && !getStorageArgs) {\n                getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n            }\n            // It's possible that applying merge functions to this subtree will\n            // not change the incoming data, so this variable tracks the fields\n            // that did change, so we can create a new incoming object when (and\n            // only when) at least one incoming field has changed. We use a Map\n            // to preserve the type of numeric keys.\n            var changedFields_1;\n            var getValue_1 = function (from, name) {\n                return (isArray(from) ?\n                    typeof name === \"number\" ?\n                        from[name]\n                        : void 0\n                    : context.store.getFieldValue(from, String(name)));\n            };\n            mergeTree.map.forEach(function (childTree, storeFieldName) {\n                var eVal = getValue_1(e_1, storeFieldName);\n                var iVal = getValue_1(i_1, storeFieldName);\n                // If we have no incoming data, leave any existing data untouched.\n                if (void 0 === iVal)\n                    return;\n                if (getStorageArgs) {\n                    getStorageArgs.push(storeFieldName);\n                }\n                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n                if (aVal !== iVal) {\n                    changedFields_1 = changedFields_1 || new Map();\n                    changedFields_1.set(storeFieldName, aVal);\n                }\n                if (getStorageArgs) {\n                    invariant(getStorageArgs.pop() === storeFieldName);\n                }\n            });\n            if (changedFields_1) {\n                // Shallow clone i so we can add changed fields to it.\n                incoming = (isArray(i_1) ? i_1.slice(0) : __assign({}, i_1));\n                changedFields_1.forEach(function (value, name) {\n                    incoming[name] = value;\n                });\n            }\n        }\n        if (mergeTree.info) {\n            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n        }\n        return incoming;\n    };\n    return StoreWriter;\n}());\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n    var map = _a.map;\n    if (!map.has(name)) {\n        map.set(name, emptyMergeTreePool.pop() || { map: new Map() });\n    }\n    return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n    if (left === right || !right || mergeTreeIsEmpty(right))\n        return left;\n    if (!left || mergeTreeIsEmpty(left))\n        return right;\n    var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n    var needToMergeMaps = left.map.size && right.map.size;\n    var map = needToMergeMaps ? new Map()\n        : left.map.size ? left.map\n            : right.map;\n    var merged = { info: info, map: map };\n    if (needToMergeMaps) {\n        var remainingRightKeys_1 = new Set(right.map.keys());\n        left.map.forEach(function (leftTree, key) {\n            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n            remainingRightKeys_1.delete(key);\n        });\n        remainingRightKeys_1.forEach(function (key) {\n            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n        });\n    }\n    return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n    return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n    var map = _a.map;\n    var childTree = map.get(name);\n    if (childTree && mergeTreeIsEmpty(childTree)) {\n        emptyMergeTreePool.push(childTree);\n        map.delete(name);\n    }\n}\nvar warnings = new Set();\n// Note that this function is unused in production, and thus should be\n// pruned by any well-configured minifier.\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    var getChild = function (objOrRef) {\n        var child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    var existing = getChild(existingRef);\n    if (!existing)\n        return;\n    var incoming = getChild(incomingObj);\n    if (!incoming)\n        return;\n    // It's always safe to replace a reference, since it refers to data\n    // safely stored elsewhere.\n    if (isReference(existing))\n        return;\n    // If the values are structurally equivalent, we do not need to worry\n    // about incoming replacing existing.\n    if (equal(existing, incoming))\n        return;\n    // If we're replacing every key of the existing object, then the\n    // existing data would be overwritten even if the objects were\n    // normalized, so warning would not be helpful here.\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\n        return;\n    }\n    var parentType = store.getFieldValue(existingRef, \"__typename\") ||\n        store.getFieldValue(incomingObj, \"__typename\");\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n    // Avoid warning more than once for the same type and field name.\n    if (warnings.has(typeDotName))\n        return;\n    warnings.add(typeDotName);\n    var childTypenames = [];\n    // Arrays do not have __typename fields, and always need a custom merge\n    // function, even if their elements are normalized entities.\n    if (!isArray(existing) && !isArray(incoming)) {\n        [existing, incoming].forEach(function (child) {\n            var typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    globalThis.__DEV__ !== false && invariant.warn(14, fieldName, parentType, childTypenames.length ?\n        \"either ensure all objects of type \" +\n            childTypenames.join(\" and \") +\n            \" have an ID or a custom merge function, or \"\n        : \"\", typeDotName, existing, incoming);\n}\n//# sourceMappingURL=writeToStore.js.map",
      "start": 1746507072436,
      "end": 1746507072438,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "graphql",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1746507072438,
      "end": 1746507072438,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1746507072438,
      "end": 1746507072439,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { Kind } from \"graphql\";\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField, canonicalStringify } from \"../../utilities/index.js\";\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext } from \"./helpers.js\";\nimport { normalizeReadFieldOptions } from \"./policies.js\";\nfunction getContextFlavor(context, clientOnly, deferred) {\n  var key = \"\".concat(clientOnly).concat(deferred);\n  var flavored = context.flavors.get(key);\n  if (!flavored) {\n    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), { clientOnly, deferred }));\n  }\n  return flavored;\n}\nvar StoreWriter = (\n  /** @class */\n  function() {\n    function StoreWriter2(cache, reader, fragments) {\n      this.cache = cache;\n      this.reader = reader;\n      this.fragments = fragments;\n    }\n    StoreWriter2.prototype.writeToStore = function(store, _a) {\n      var _this = this;\n      var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;\n      var operationDefinition = getOperationDefinition(query);\n      var merger = makeProcessedFieldsMerger();\n      variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\n      var context = __assign(__assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {\n        return merger.merge(existing, incoming);\n      }, variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });\n      var ref = this.processSelectionSet({\n        result: result || /* @__PURE__ */ Object.create(null),\n        dataId,\n        selectionSet: operationDefinition.selectionSet,\n        mergeTree: { map: /* @__PURE__ */ new Map() },\n        context\n      });\n      if (!isReference(ref)) {\n        throw newInvariantError(11, result);\n      }\n      context.incomingById.forEach(function(_a2, dataId2) {\n        var storeObject = _a2.storeObject, mergeTree = _a2.mergeTree, fieldNodeSet = _a2.fieldNodeSet;\n        var entityRef = makeReference(dataId2);\n        if (mergeTree && mergeTree.map.size) {\n          var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n          if (isReference(applied)) {\n            return;\n          }\n          storeObject = applied;\n        }\n        if (globalThis.__DEV__ !== false && !context.overwrite) {\n          var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);\n          fieldNodeSet.forEach(function(field) {\n            if (field.selectionSet) {\n              fieldsWithSelectionSets_1[field.name.value] = true;\n            }\n          });\n          var hasSelectionSet_1 = function(storeFieldName) {\n            return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;\n          };\n          var hasMergeFunction_1 = function(storeFieldName) {\n            var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n            return Boolean(childTree && childTree.info && childTree.info.merge);\n          };\n          Object.keys(storeObject).forEach(function(storeFieldName) {\n            if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {\n              warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n            }\n          });\n        }\n        store.merge(dataId2, storeObject);\n      });\n      store.retain(ref.__ref);\n      return ref;\n    };\n    StoreWriter2.prototype.processSelectionSet = function(_a) {\n      var _this = this;\n      var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, mergeTree = _a.mergeTree;\n      var policies = this.cache.policies;\n      var incoming = /* @__PURE__ */ Object.create(null);\n      var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, \"__typename\");\n      if (\"string\" === typeof typename) {\n        incoming.__typename = typename;\n      }\n      var readField = function() {\n        var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n        if (isReference(options.from)) {\n          var info = context.incomingById.get(options.from.__ref);\n          if (info) {\n            var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);\n            if (result_1 !== void 0) {\n              return result_1;\n            }\n          }\n        }\n        return policies.readField(options, context);\n      };\n      var fieldNodeSet = /* @__PURE__ */ new Set();\n      this.flattenFields(\n        selectionSet,\n        result,\n        // This WriteContext will be the default context value for fields returned\n        // by the flattenFields method, but some fields may be assigned a modified\n        // context, depending on the presence of @client and other directives.\n        context,\n        typename\n      ).forEach(function(context2, field) {\n        var _a2;\n        var resultFieldKey = resultKeyNameFromField(field);\n        var value = result[resultFieldKey];\n        fieldNodeSet.add(field);\n        if (value !== void 0) {\n          var storeFieldName = policies.getStoreFieldName({\n            typename,\n            fieldName: field.name.value,\n            field,\n            variables: context2.variables\n          });\n          var childTree = getChildMergeTree(mergeTree, storeFieldName);\n          var incomingValue = _this.processFieldValue(\n            value,\n            field,\n            // Reset context.clientOnly and context.deferred to their default\n            // values before processing nested selection sets.\n            field.selectionSet ? getContextFlavor(context2, false, false) : context2,\n            childTree\n          );\n          var childTypename = void 0;\n          if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\n            childTypename = readField(\"__typename\", incomingValue);\n          }\n          var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n          if (merge) {\n            childTree.info = {\n              // TODO Check compatibility against any existing childTree.field?\n              field,\n              typename,\n              merge\n            };\n          } else {\n            maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n          }\n          incoming = context2.merge(incoming, (_a2 = {}, _a2[storeFieldName] = incomingValue, _a2));\n        } else if (globalThis.__DEV__ !== false && !context2.clientOnly && !context2.deferred && !addTypenameToDocument.added(field) && // If the field has a read function, it may be a synthetic field or\n        // provide a default value, so its absence from the written data should\n        // not be cause for alarm.\n        !policies.getReadFunction(typename, field.name.value)) {\n          globalThis.__DEV__ !== false && invariant.error(12, resultKeyNameFromField(field), result);\n        }\n      });\n      try {\n        var _b = policies.identify(result, {\n          typename,\n          selectionSet,\n          fragmentMap: context.fragmentMap,\n          storeObject: incoming,\n          readField\n        }), id = _b[0], keyObject = _b[1];\n        dataId = dataId || id;\n        if (keyObject) {\n          incoming = context.merge(incoming, keyObject);\n        }\n      } catch (e) {\n        if (!dataId)\n          throw e;\n      }\n      if (\"string\" === typeof dataId) {\n        var dataRef = makeReference(dataId);\n        var sets = context.written[dataId] || (context.written[dataId] = []);\n        if (sets.indexOf(selectionSet) >= 0)\n          return dataRef;\n        sets.push(selectionSet);\n        if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n          return dataRef;\n        }\n        var previous_1 = context.incomingById.get(dataId);\n        if (previous_1) {\n          previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n          previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n          fieldNodeSet.forEach(function(field) {\n            return previous_1.fieldNodeSet.add(field);\n          });\n        } else {\n          context.incomingById.set(dataId, {\n            storeObject: incoming,\n            // Save a reference to mergeTree only if it is not empty, because\n            // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\n            // reused for entirely different parts of the result tree.\n            mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n            fieldNodeSet\n          });\n        }\n        return dataRef;\n      }\n      return incoming;\n    };\n    StoreWriter2.prototype.processFieldValue = function(value, field, context, mergeTree) {\n      var _this = this;\n      if (!field.selectionSet || value === null) {\n        return globalThis.__DEV__ !== false ? cloneDeep(value) : value;\n      }\n      if (isArray(value)) {\n        return value.map(function(item, i) {\n          var value2 = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n          maybeRecycleChildMergeTree(mergeTree, i);\n          return value2;\n        });\n      }\n      return this.processSelectionSet({\n        result: value,\n        selectionSet: field.selectionSet,\n        context,\n        mergeTree\n      });\n    };\n    StoreWriter2.prototype.flattenFields = function(selectionSet, result, context, typename) {\n      if (typename === void 0) {\n        typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);\n      }\n      var fieldMap = /* @__PURE__ */ new Map();\n      var policies = this.cache.policies;\n      var limitingTrie = new Trie(false);\n      (function flatten(selectionSet2, inheritedContext) {\n        var visitedNode = limitingTrie.lookup(\n          selectionSet2,\n          // Because we take inheritedClientOnly and inheritedDeferred into\n          // consideration here (in addition to selectionSet), it's possible for\n          // the same selection set to be flattened more than once, if it appears\n          // in the query with different @client and/or @directive configurations.\n          inheritedContext.clientOnly,\n          inheritedContext.deferred\n        );\n        if (visitedNode.visited)\n          return;\n        visitedNode.visited = true;\n        selectionSet2.selections.forEach(function(selection) {\n          if (!shouldInclude(selection, context.variables))\n            return;\n          var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;\n          if (\n            // Since the presence of @client or @defer on this field can only\n            // cause clientOnly or deferred to become true, we can skip the\n            // forEach loop if both clientOnly and deferred are already true.\n            !(clientOnly && deferred) && isNonEmptyArray(selection.directives)\n          ) {\n            selection.directives.forEach(function(dir) {\n              var name = dir.name.value;\n              if (name === \"client\")\n                clientOnly = true;\n              if (name === \"defer\") {\n                var args = argumentsObjectFromField(dir, context.variables);\n                if (!args || args.if !== false) {\n                  deferred = true;\n                }\n              }\n            });\n          }\n          if (isField(selection)) {\n            var existing = fieldMap.get(selection);\n            if (existing) {\n              clientOnly = clientOnly && existing.clientOnly;\n              deferred = deferred && existing.deferred;\n            }\n            fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n          } else {\n            var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n            if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n              throw newInvariantError(13, selection.name.value);\n            }\n            if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {\n              flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n            }\n          }\n        });\n      })(selectionSet, context);\n      return fieldMap;\n    };\n    StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {\n      var _a;\n      var _this = this;\n      if (mergeTree.map.size && !isReference(incoming)) {\n        var e_1 = (\n          // Items in the same position in different arrays are not\n          // necessarily related to each other, so when incoming is an array\n          // we process its elements as if there was no existing data.\n          !isArray(incoming) && // Likewise, existing must be either a Reference or a StoreObject\n          // in order for its fields to be safe to merge with the fields of\n          // the incoming object.\n          (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0\n        );\n        var i_1 = incoming;\n        if (e_1 && !getStorageArgs) {\n          getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\n        }\n        var changedFields_1;\n        var getValue_1 = function(from, name) {\n          return isArray(from) ? typeof name === \"number\" ? from[name] : void 0 : context.store.getFieldValue(from, String(name));\n        };\n        mergeTree.map.forEach(function(childTree, storeFieldName) {\n          var eVal = getValue_1(e_1, storeFieldName);\n          var iVal = getValue_1(i_1, storeFieldName);\n          if (void 0 === iVal)\n            return;\n          if (getStorageArgs) {\n            getStorageArgs.push(storeFieldName);\n          }\n          var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n          if (aVal !== iVal) {\n            changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();\n            changedFields_1.set(storeFieldName, aVal);\n          }\n          if (getStorageArgs) {\n            invariant(getStorageArgs.pop() === storeFieldName);\n          }\n        });\n        if (changedFields_1) {\n          incoming = isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);\n          changedFields_1.forEach(function(value, name) {\n            incoming[name] = value;\n          });\n        }\n      }\n      if (mergeTree.info) {\n        return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n      }\n      return incoming;\n    };\n    return StoreWriter2;\n  }()\n);\nexport { StoreWriter };\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n  var map = _a.map;\n  if (!map.has(name)) {\n    map.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });\n  }\n  return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n  if (left === right || !right || mergeTreeIsEmpty(right))\n    return left;\n  if (!left || mergeTreeIsEmpty(left))\n    return right;\n  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\n  var needToMergeMaps = left.map.size && right.map.size;\n  var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;\n  var merged = { info, map };\n  if (needToMergeMaps) {\n    var remainingRightKeys_1 = new Set(right.map.keys());\n    left.map.forEach(function(leftTree, key) {\n      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n      remainingRightKeys_1.delete(key);\n    });\n    remainingRightKeys_1.forEach(function(key) {\n      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n    });\n  }\n  return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n  return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n  var map = _a.map;\n  var childTree = map.get(name);\n  if (childTree && mergeTreeIsEmpty(childTree)) {\n    emptyMergeTreePool.push(childTree);\n    map.delete(name);\n  }\n}\nvar warnings = /* @__PURE__ */ new Set();\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n  var getChild = function(objOrRef) {\n    var child = store.getFieldValue(objOrRef, storeFieldName);\n    return typeof child === \"object\" && child;\n  };\n  var existing = getChild(existingRef);\n  if (!existing)\n    return;\n  var incoming = getChild(incomingObj);\n  if (!incoming)\n    return;\n  if (isReference(existing))\n    return;\n  if (equal(existing, incoming))\n    return;\n  if (Object.keys(existing).every(function(key) {\n    return store.getFieldValue(incoming, key) !== void 0;\n  })) {\n    return;\n  }\n  var parentType = store.getFieldValue(existingRef, \"__typename\") || store.getFieldValue(incomingObj, \"__typename\");\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n  if (warnings.has(typeDotName))\n    return;\n  warnings.add(typeDotName);\n  var childTypenames = [];\n  if (!isArray(existing) && !isArray(incoming)) {\n    [existing, incoming].forEach(function(child) {\n      var typename = store.getFieldValue(child, \"__typename\");\n      if (typeof typename === \"string\" && !childTypenames.includes(typename)) {\n        childTypenames.push(typename);\n      }\n    });\n  }\n  globalThis.__DEV__ !== false && invariant.warn(14, fieldName, parentType, childTypenames.length ? \"either ensure all objects of type \" + childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \" : \"\", typeDotName, existing, incoming);\n}\n",
      "start": 1746507072439,
      "end": 1746507072875,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/cache/inmemory/writeToStore.js\"],\n  \"sourcesContent\": [\"import { __assign } from \\\"tslib\\\";\\nimport { invariant, newInvariantError } from \\\"../../utilities/globals/index.js\\\";\\nimport { equal } from \\\"@wry/equality\\\";\\nimport { Trie } from \\\"@wry/trie\\\";\\nimport { Kind } from \\\"graphql\\\";\\nimport { getFragmentFromSelection, getDefaultValues, getOperationDefinition, getTypenameFromResult, makeReference, isField, resultKeyNameFromField, isReference, shouldInclude, cloneDeep, addTypenameToDocument, isNonEmptyArray, argumentsObjectFromField, canonicalStringify, } from \\\"../../utilities/index.js\\\";\\nimport { isArray, makeProcessedFieldsMerger, fieldNameFromStoreName, storeValueIsStoreObject, extractFragmentContext, } from \\\"./helpers.js\\\";\\nimport { normalizeReadFieldOptions } from \\\"./policies.js\\\";\\n// Since there are only four possible combinations of context.clientOnly and\\n// context.deferred values, we should need at most four \\\"flavors\\\" of any given\\n// WriteContext. To avoid creating multiple copies of the same context, we cache\\n// the contexts in the context.flavors Map (shared by all flavors) according to\\n// their clientOnly and deferred values (always in that order).\\nfunction getContextFlavor(context, clientOnly, deferred) {\\n    var key = \\\"\\\".concat(clientOnly).concat(deferred);\\n    var flavored = context.flavors.get(key);\\n    if (!flavored) {\\n        context.flavors.set(key, (flavored =\\n            context.clientOnly === clientOnly && context.deferred === deferred ?\\n                context\\n                : __assign(__assign({}, context), { clientOnly: clientOnly, deferred: deferred })));\\n    }\\n    return flavored;\\n}\\nvar StoreWriter = /** @class */ (function () {\\n    function StoreWriter(cache, reader, fragments) {\\n        this.cache = cache;\\n        this.reader = reader;\\n        this.fragments = fragments;\\n    }\\n    StoreWriter.prototype.writeToStore = function (store, _a) {\\n        var _this = this;\\n        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;\\n        var operationDefinition = getOperationDefinition(query);\\n        var merger = makeProcessedFieldsMerger();\\n        variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);\\n        var context = __assign(__assign({ store: store, written: Object.create(null), merge: function (existing, incoming) {\\n                return merger.merge(existing, incoming);\\n            }, variables: variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: new Map(), clientOnly: false, deferred: false, flavors: new Map() });\\n        var ref = this.processSelectionSet({\\n            result: result || Object.create(null),\\n            dataId: dataId,\\n            selectionSet: operationDefinition.selectionSet,\\n            mergeTree: { map: new Map() },\\n            context: context,\\n        });\\n        if (!isReference(ref)) {\\n            throw newInvariantError(11, result);\\n        }\\n        // So far, the store has not been modified, so now it's time to process\\n        // context.incomingById and merge those incoming fields into context.store.\\n        context.incomingById.forEach(function (_a, dataId) {\\n            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;\\n            var entityRef = makeReference(dataId);\\n            if (mergeTree && mergeTree.map.size) {\\n                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\\n                if (isReference(applied)) {\\n                    // Assume References returned by applyMerges have already been merged\\n                    // into the store. See makeMergeObjectsFunction in policies.ts for an\\n                    // example of how this can happen.\\n                    return;\\n                }\\n                // Otherwise, applyMerges returned a StoreObject, whose fields we should\\n                // merge into the store (see store.merge statement below).\\n                storeObject = applied;\\n            }\\n            if (globalThis.__DEV__ !== false && !context.overwrite) {\\n                var fieldsWithSelectionSets_1 = Object.create(null);\\n                fieldNodeSet.forEach(function (field) {\\n                    if (field.selectionSet) {\\n                        fieldsWithSelectionSets_1[field.name.value] = true;\\n                    }\\n                });\\n                var hasSelectionSet_1 = function (storeFieldName) {\\n                    return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] ===\\n                        true;\\n                };\\n                var hasMergeFunction_1 = function (storeFieldName) {\\n                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);\\n                    return Boolean(childTree && childTree.info && childTree.info.merge);\\n                };\\n                Object.keys(storeObject).forEach(function (storeFieldName) {\\n                    // If a merge function was defined for this field, trust that it\\n                    // did the right thing about (not) clobbering data. If the field\\n                    // has no selection set, it's a scalar field, so it doesn't need\\n                    // a merge function (even if it's an object, like JSON data).\\n                    if (hasSelectionSet_1(storeFieldName) &&\\n                        !hasMergeFunction_1(storeFieldName)) {\\n                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\\n                    }\\n                });\\n            }\\n            store.merge(dataId, storeObject);\\n        });\\n        // Any IDs written explicitly to the cache will be retained as\\n        // reachable root IDs for garbage collection purposes. Although this\\n        // logic includes root IDs like ROOT_QUERY and ROOT_MUTATION, their\\n        // retainment counts are effectively ignored because cache.gc() always\\n        // includes them in its root ID set.\\n        store.retain(ref.__ref);\\n        return ref;\\n    };\\n    StoreWriter.prototype.processSelectionSet = function (_a) {\\n        var _this = this;\\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, \\n        // This object allows processSelectionSet to report useful information\\n        // to its callers without explicitly returning that information.\\n        mergeTree = _a.mergeTree;\\n        var policies = this.cache.policies;\\n        // This variable will be repeatedly updated using context.merge to\\n        // accumulate all fields that need to be written into the store.\\n        var incoming = Object.create(null);\\n        // If typename was not passed in, infer it. Note that typename is\\n        // always passed in for tricky-to-infer cases such as \\\"Query\\\" for\\n        // ROOT_QUERY.\\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\\n            getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\\n            (dataId && context.store.get(dataId, \\\"__typename\\\"));\\n        if (\\\"string\\\" === typeof typename) {\\n            incoming.__typename = typename;\\n        }\\n        // This readField function will be passed as context.readField in the\\n        // KeyFieldsContext object created within policies.identify (called below).\\n        // In addition to reading from the existing context.store (thanks to the\\n        // policies.readField(options, context) line at the very bottom), this\\n        // version of readField can read from Reference objects that are currently\\n        // pending in context.incomingById, which is important whenever keyFields\\n        // need to be extracted from a child object that processSelectionSet has\\n        // turned into a Reference.\\n        var readField = function () {\\n            var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\\n            if (isReference(options.from)) {\\n                var info = context.incomingById.get(options.from.__ref);\\n                if (info) {\\n                    var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);\\n                    if (result_1 !== void 0) {\\n                        return result_1;\\n                    }\\n                }\\n            }\\n            return policies.readField(options, context);\\n        };\\n        var fieldNodeSet = new Set();\\n        this.flattenFields(selectionSet, result, \\n        // This WriteContext will be the default context value for fields returned\\n        // by the flattenFields method, but some fields may be assigned a modified\\n        // context, depending on the presence of @client and other directives.\\n        context, typename).forEach(function (context, field) {\\n            var _a;\\n            var resultFieldKey = resultKeyNameFromField(field);\\n            var value = result[resultFieldKey];\\n            fieldNodeSet.add(field);\\n            if (value !== void 0) {\\n                var storeFieldName = policies.getStoreFieldName({\\n                    typename: typename,\\n                    fieldName: field.name.value,\\n                    field: field,\\n                    variables: context.variables,\\n                });\\n                var childTree = getChildMergeTree(mergeTree, storeFieldName);\\n                var incomingValue = _this.processFieldValue(value, field, \\n                // Reset context.clientOnly and context.deferred to their default\\n                // values before processing nested selection sets.\\n                field.selectionSet ?\\n                    getContextFlavor(context, false, false)\\n                    : context, childTree);\\n                // To determine if this field holds a child object with a merge function\\n                // defined in its type policy (see PR #7070), we need to figure out the\\n                // child object's __typename.\\n                var childTypename = void 0;\\n                // The field's value can be an object that has a __typename only if the\\n                // field has a selection set. Otherwise incomingValue is scalar.\\n                if (field.selectionSet &&\\n                    (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {\\n                    childTypename = readField(\\\"__typename\\\", incomingValue);\\n                }\\n                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\\n                if (merge) {\\n                    childTree.info = {\\n                        // TODO Check compatibility against any existing childTree.field?\\n                        field: field,\\n                        typename: typename,\\n                        merge: merge,\\n                    };\\n                }\\n                else {\\n                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);\\n                }\\n                incoming = context.merge(incoming, (_a = {},\\n                    _a[storeFieldName] = incomingValue,\\n                    _a));\\n            }\\n            else if (globalThis.__DEV__ !== false &&\\n                !context.clientOnly &&\\n                !context.deferred &&\\n                !addTypenameToDocument.added(field) &&\\n                // If the field has a read function, it may be a synthetic field or\\n                // provide a default value, so its absence from the written data should\\n                // not be cause for alarm.\\n                !policies.getReadFunction(typename, field.name.value)) {\\n                globalThis.__DEV__ !== false && invariant.error(12, resultKeyNameFromField(field), result);\\n            }\\n        });\\n        // Identify the result object, even if dataId was already provided,\\n        // since we always need keyObject below.\\n        try {\\n            var _b = policies.identify(result, {\\n                typename: typename,\\n                selectionSet: selectionSet,\\n                fragmentMap: context.fragmentMap,\\n                storeObject: incoming,\\n                readField: readField,\\n            }), id = _b[0], keyObject = _b[1];\\n            // If dataId was not provided, fall back to the id just generated by\\n            // policies.identify.\\n            dataId = dataId || id;\\n            // Write any key fields that were used during identification, even if\\n            // they were not mentioned in the original query.\\n            if (keyObject) {\\n                // TODO Reverse the order of the arguments?\\n                incoming = context.merge(incoming, keyObject);\\n            }\\n        }\\n        catch (e) {\\n            // If dataId was provided, tolerate failure of policies.identify.\\n            if (!dataId)\\n                throw e;\\n        }\\n        if (\\\"string\\\" === typeof dataId) {\\n            var dataRef = makeReference(dataId);\\n            // Avoid processing the same entity object using the same selection\\n            // set more than once. We use an array instead of a Set since most\\n            // entity IDs will be written using only one selection set, so the\\n            // size of this array is likely to be very small, meaning indexOf is\\n            // likely to be faster than Set.prototype.has.\\n            var sets = context.written[dataId] || (context.written[dataId] = []);\\n            if (sets.indexOf(selectionSet) >= 0)\\n                return dataRef;\\n            sets.push(selectionSet);\\n            // If we're about to write a result object into the store, but we\\n            // happen to know that the exact same (===) result object would be\\n            // returned if we were to reread the result with the same inputs,\\n            // then we can skip the rest of the processSelectionSet work for\\n            // this object, and immediately return a Reference to it.\\n            if (this.reader &&\\n                this.reader.isFresh(result, dataRef, selectionSet, context)) {\\n                return dataRef;\\n            }\\n            var previous_1 = context.incomingById.get(dataId);\\n            if (previous_1) {\\n                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\\n                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\\n                fieldNodeSet.forEach(function (field) { return previous_1.fieldNodeSet.add(field); });\\n            }\\n            else {\\n                context.incomingById.set(dataId, {\\n                    storeObject: incoming,\\n                    // Save a reference to mergeTree only if it is not empty, because\\n                    // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and\\n                    // reused for entirely different parts of the result tree.\\n                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\\n                    fieldNodeSet: fieldNodeSet,\\n                });\\n            }\\n            return dataRef;\\n        }\\n        return incoming;\\n    };\\n    StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\\n        var _this = this;\\n        if (!field.selectionSet || value === null) {\\n            // In development, we need to clone scalar values so that they can be\\n            // safely frozen with maybeDeepFreeze in readFromStore.ts. In production,\\n            // it's cheaper to store the scalar values directly in the cache.\\n            return globalThis.__DEV__ !== false ? cloneDeep(value) : value;\\n        }\\n        if (isArray(value)) {\\n            return value.map(function (item, i) {\\n                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\\n                maybeRecycleChildMergeTree(mergeTree, i);\\n                return value;\\n            });\\n        }\\n        return this.processSelectionSet({\\n            result: value,\\n            selectionSet: field.selectionSet,\\n            context: context,\\n            mergeTree: mergeTree,\\n        });\\n    };\\n    // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with\\n    // some additions for tracking @client and @defer directives.\\n    StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\\n        if (typename === void 0) { typename = getTypenameFromResult(result, selectionSet, context.fragmentMap); }\\n        var fieldMap = new Map();\\n        var policies = this.cache.policies;\\n        var limitingTrie = new Trie(false); // No need for WeakMap, since limitingTrie does not escape.\\n        (function flatten(selectionSet, inheritedContext) {\\n            var visitedNode = limitingTrie.lookup(selectionSet, \\n            // Because we take inheritedClientOnly and inheritedDeferred into\\n            // consideration here (in addition to selectionSet), it's possible for\\n            // the same selection set to be flattened more than once, if it appears\\n            // in the query with different @client and/or @directive configurations.\\n            inheritedContext.clientOnly, inheritedContext.deferred);\\n            if (visitedNode.visited)\\n                return;\\n            visitedNode.visited = true;\\n            selectionSet.selections.forEach(function (selection) {\\n                if (!shouldInclude(selection, context.variables))\\n                    return;\\n                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;\\n                if (\\n                // Since the presence of @client or @defer on this field can only\\n                // cause clientOnly or deferred to become true, we can skip the\\n                // forEach loop if both clientOnly and deferred are already true.\\n                !(clientOnly && deferred) &&\\n                    isNonEmptyArray(selection.directives)) {\\n                    selection.directives.forEach(function (dir) {\\n                        var name = dir.name.value;\\n                        if (name === \\\"client\\\")\\n                            clientOnly = true;\\n                        if (name === \\\"defer\\\") {\\n                            var args = argumentsObjectFromField(dir, context.variables);\\n                            // The @defer directive takes an optional args.if boolean\\n                            // argument, similar to @include(if: boolean). Note that\\n                            // @defer(if: false) does not make context.deferred false, but\\n                            // instead behaves as if there was no @defer directive.\\n                            if (!args || args.if !== false) {\\n                                deferred = true;\\n                            }\\n                            // TODO In the future, we may want to record args.label using\\n                            // context.deferred, if a label is specified.\\n                        }\\n                    });\\n                }\\n                if (isField(selection)) {\\n                    var existing = fieldMap.get(selection);\\n                    if (existing) {\\n                        // If this field has been visited along another recursive path\\n                        // before, the final context should have clientOnly or deferred set\\n                        // to true only if *all* paths have the directive (hence the &&).\\n                        clientOnly = clientOnly && existing.clientOnly;\\n                        deferred = deferred && existing.deferred;\\n                    }\\n                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\\n                }\\n                else {\\n                    var fragment = getFragmentFromSelection(selection, context.lookupFragment);\\n                    if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\\n                        throw newInvariantError(13, selection.name.value);\\n                    }\\n                    if (fragment &&\\n                        policies.fragmentMatches(fragment, typename, result, context.variables)) {\\n                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\\n                    }\\n                }\\n            });\\n        })(selectionSet, context);\\n        return fieldMap;\\n    };\\n    StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\\n        var _a;\\n        var _this = this;\\n        if (mergeTree.map.size && !isReference(incoming)) {\\n            var e_1 = \\n            // Items in the same position in different arrays are not\\n            // necessarily related to each other, so when incoming is an array\\n            // we process its elements as if there was no existing data.\\n            (!isArray(incoming) &&\\n                // Likewise, existing must be either a Reference or a StoreObject\\n                // in order for its fields to be safe to merge with the fields of\\n                // the incoming object.\\n                (isReference(existing) || storeValueIsStoreObject(existing))) ?\\n                existing\\n                : void 0;\\n            // This narrowing is implied by mergeTree.map.size > 0 and\\n            // !isReference(incoming), though TypeScript understandably cannot\\n            // hope to infer this type.\\n            var i_1 = incoming;\\n            // The options.storage objects provided to read and merge functions\\n            // are derived from the identity of the parent object plus a\\n            // sequence of storeFieldName strings/numbers identifying the nested\\n            // field name path of each field value to be merged.\\n            if (e_1 && !getStorageArgs) {\\n                getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];\\n            }\\n            // It's possible that applying merge functions to this subtree will\\n            // not change the incoming data, so this variable tracks the fields\\n            // that did change, so we can create a new incoming object when (and\\n            // only when) at least one incoming field has changed. We use a Map\\n            // to preserve the type of numeric keys.\\n            var changedFields_1;\\n            var getValue_1 = function (from, name) {\\n                return (isArray(from) ?\\n                    typeof name === \\\"number\\\" ?\\n                        from[name]\\n                        : void 0\\n                    : context.store.getFieldValue(from, String(name)));\\n            };\\n            mergeTree.map.forEach(function (childTree, storeFieldName) {\\n                var eVal = getValue_1(e_1, storeFieldName);\\n                var iVal = getValue_1(i_1, storeFieldName);\\n                // If we have no incoming data, leave any existing data untouched.\\n                if (void 0 === iVal)\\n                    return;\\n                if (getStorageArgs) {\\n                    getStorageArgs.push(storeFieldName);\\n                }\\n                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\\n                if (aVal !== iVal) {\\n                    changedFields_1 = changedFields_1 || new Map();\\n                    changedFields_1.set(storeFieldName, aVal);\\n                }\\n                if (getStorageArgs) {\\n                    invariant(getStorageArgs.pop() === storeFieldName);\\n                }\\n            });\\n            if (changedFields_1) {\\n                // Shallow clone i so we can add changed fields to it.\\n                incoming = (isArray(i_1) ? i_1.slice(0) : __assign({}, i_1));\\n                changedFields_1.forEach(function (value, name) {\\n                    incoming[name] = value;\\n                });\\n            }\\n        }\\n        if (mergeTree.info) {\\n            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\\n        }\\n        return incoming;\\n    };\\n    return StoreWriter;\\n}());\\nexport { StoreWriter };\\nvar emptyMergeTreePool = [];\\nfunction getChildMergeTree(_a, name) {\\n    var map = _a.map;\\n    if (!map.has(name)) {\\n        map.set(name, emptyMergeTreePool.pop() || { map: new Map() });\\n    }\\n    return map.get(name);\\n}\\nfunction mergeMergeTrees(left, right) {\\n    if (left === right || !right || mergeTreeIsEmpty(right))\\n        return left;\\n    if (!left || mergeTreeIsEmpty(left))\\n        return right;\\n    var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;\\n    var needToMergeMaps = left.map.size && right.map.size;\\n    var map = needToMergeMaps ? new Map()\\n        : left.map.size ? left.map\\n            : right.map;\\n    var merged = { info: info, map: map };\\n    if (needToMergeMaps) {\\n        var remainingRightKeys_1 = new Set(right.map.keys());\\n        left.map.forEach(function (leftTree, key) {\\n            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\\n            remainingRightKeys_1.delete(key);\\n        });\\n        remainingRightKeys_1.forEach(function (key) {\\n            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\\n        });\\n    }\\n    return merged;\\n}\\nfunction mergeTreeIsEmpty(tree) {\\n    return !tree || !(tree.info || tree.map.size);\\n}\\nfunction maybeRecycleChildMergeTree(_a, name) {\\n    var map = _a.map;\\n    var childTree = map.get(name);\\n    if (childTree && mergeTreeIsEmpty(childTree)) {\\n        emptyMergeTreePool.push(childTree);\\n        map.delete(name);\\n    }\\n}\\nvar warnings = new Set();\\n// Note that this function is unused in production, and thus should be\\n// pruned by any well-configured minifier.\\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\\n    var getChild = function (objOrRef) {\\n        var child = store.getFieldValue(objOrRef, storeFieldName);\\n        return typeof child === \\\"object\\\" && child;\\n    };\\n    var existing = getChild(existingRef);\\n    if (!existing)\\n        return;\\n    var incoming = getChild(incomingObj);\\n    if (!incoming)\\n        return;\\n    // It's always safe to replace a reference, since it refers to data\\n    // safely stored elsewhere.\\n    if (isReference(existing))\\n        return;\\n    // If the values are structurally equivalent, we do not need to worry\\n    // about incoming replacing existing.\\n    if (equal(existing, incoming))\\n        return;\\n    // If we're replacing every key of the existing object, then the\\n    // existing data would be overwritten even if the objects were\\n    // normalized, so warning would not be helpful here.\\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\\n        return;\\n    }\\n    var parentType = store.getFieldValue(existingRef, \\\"__typename\\\") ||\\n        store.getFieldValue(incomingObj, \\\"__typename\\\");\\n    var fieldName = fieldNameFromStoreName(storeFieldName);\\n    var typeDotName = \\\"\\\".concat(parentType, \\\".\\\").concat(fieldName);\\n    // Avoid warning more than once for the same type and field name.\\n    if (warnings.has(typeDotName))\\n        return;\\n    warnings.add(typeDotName);\\n    var childTypenames = [];\\n    // Arrays do not have __typename fields, and always need a custom merge\\n    // function, even if their elements are normalized entities.\\n    if (!isArray(existing) && !isArray(incoming)) {\\n        [existing, incoming].forEach(function (child) {\\n            var typename = store.getFieldValue(child, \\\"__typename\\\");\\n            if (typeof typename === \\\"string\\\" && !childTypenames.includes(typename)) {\\n                childTypenames.push(typename);\\n            }\\n        });\\n    }\\n    globalThis.__DEV__ !== false && invariant.warn(14, fieldName, parentType, childTypenames.length ?\\n        \\\"either ensure all objects of type \\\" +\\n            childTypenames.join(\\\" and \\\") +\\n            \\\" have an ID or a custom merge function, or \\\"\\n        : \\\"\\\", typeDotName, existing, incoming);\\n}\\n//# sourceMappingURL=writeToStore.js.map\"],\n  \"mappings\": \"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\",\n  \"names\": [\"StoreWriter\", \"_a\", \"dataId\", \"context\", \"value\", \"selectionSet\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1746507072875,
      "end": 1746507072875,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1746507072875,
      "end": 1746507072875,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1746507072875,
      "end": 1746507072875,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1746507072875,
      "end": 1746507072875,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1746507072875,
      "end": 1746507072876,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1746507072876,
      "end": 1746507072876,
      "order": "normal"
    }
  ]
}
