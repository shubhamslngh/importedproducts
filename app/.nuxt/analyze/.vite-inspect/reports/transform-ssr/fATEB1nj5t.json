{
  "resolvedId": "/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/utilities/graphql/transform.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { __assign, __spreadArray } from \"tslib\";\nimport { invariant } from \"../globals/index.js\";\nimport { visit, Kind } from \"graphql\";\nimport { checkDocument, getOperationDefinition, getFragmentDefinition, getFragmentDefinitions, getMainDefinition, } from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray, isNonEmptyArray } from \"../common/arrays.js\";\nvar TYPENAME_FIELD = {\n    kind: Kind.FIELD,\n    name: {\n        kind: Kind.NAME,\n        value: \"__typename\",\n    },\n};\nfunction isEmpty(op, fragmentMap) {\n    return (!op ||\n        op.selectionSet.selections.every(function (selection) {\n            return selection.kind === Kind.FRAGMENT_SPREAD &&\n                isEmpty(fragmentMap[selection.name.value], fragmentMap);\n        }));\n}\nfunction nullIfDocIsEmpty(doc) {\n    return (isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))) ?\n        null\n        : doc;\n}\nfunction getDirectiveMatcher(configs) {\n    var names = new Map();\n    var tests = new Map();\n    configs.forEach(function (directive) {\n        if (directive) {\n            if (directive.name) {\n                names.set(directive.name, directive);\n            }\n            else if (directive.test) {\n                tests.set(directive.test, directive);\n            }\n        }\n    });\n    return function (directive) {\n        var config = names.get(directive.name.value);\n        if (!config && tests.size) {\n            tests.forEach(function (testConfig, test) {\n                if (test(directive)) {\n                    config = testConfig;\n                }\n            });\n        }\n        return config;\n    };\n}\nfunction makeInUseGetterFunction(defaultKey) {\n    var map = new Map();\n    return function inUseGetterFunction(key) {\n        if (key === void 0) { key = defaultKey; }\n        var inUse = map.get(key);\n        if (!inUse) {\n            map.set(key, (inUse = {\n                // Variable and fragment spread names used directly within this\n                // operation or fragment definition, as identified by key. These sets\n                // will be populated during the first traversal of the document in\n                // removeDirectivesFromDocument below.\n                variables: new Set(),\n                fragmentSpreads: new Set(),\n            }));\n        }\n        return inUse;\n    };\n}\nexport function removeDirectivesFromDocument(directives, doc) {\n    checkDocument(doc);\n    // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n    // operations as if their names were \"\". Anonymous fragment definitions are\n    // not supposed to be possible, but the same default naming strategy seems\n    // appropriate for that case as well.\n    var getInUseByOperationName = makeInUseGetterFunction(\"\");\n    var getInUseByFragmentName = makeInUseGetterFunction(\"\");\n    var getInUse = function (ancestors) {\n        for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {\n            if (isArray(ancestor))\n                continue;\n            if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n                // If an operation is anonymous, we use the empty string as its key.\n                return getInUseByOperationName(ancestor.name && ancestor.name.value);\n            }\n            if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n                return getInUseByFragmentName(ancestor.name.value);\n            }\n        }\n        globalThis.__DEV__ !== false && invariant.error(83);\n        return null;\n    };\n    var operationCount = 0;\n    for (var i = doc.definitions.length - 1; i >= 0; --i) {\n        if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n            ++operationCount;\n        }\n    }\n    var directiveMatcher = getDirectiveMatcher(directives);\n    var shouldRemoveField = function (nodeDirectives) {\n        return isNonEmptyArray(nodeDirectives) &&\n            nodeDirectives\n                .map(directiveMatcher)\n                .some(function (config) { return config && config.remove; });\n    };\n    var originalFragmentDefsByPath = new Map();\n    // Any time the first traversal of the document below makes a change like\n    // removing a fragment (by returning null), this variable should be set to\n    // true. Once it becomes true, it should never be set to false again. If this\n    // variable remains false throughout the traversal, then we can return the\n    // original doc immediately without any modifications.\n    var firstVisitMadeChanges = false;\n    var fieldOrInlineFragmentVisitor = {\n        enter: function (node) {\n            if (shouldRemoveField(node.directives)) {\n                firstVisitMadeChanges = true;\n                return null;\n            }\n        },\n    };\n    var docWithoutDirectiveSubtrees = visit(doc, {\n        // These two AST node types share the same implementation, defined above.\n        Field: fieldOrInlineFragmentVisitor,\n        InlineFragment: fieldOrInlineFragmentVisitor,\n        VariableDefinition: {\n            enter: function () {\n                // VariableDefinition nodes do not count as variables in use, though\n                // they do contain Variable nodes that might be visited below. To avoid\n                // counting variable declarations as usages, we skip visiting the\n                // contents of this VariableDefinition node by returning false.\n                return false;\n            },\n        },\n        Variable: {\n            enter: function (node, _key, _parent, _path, ancestors) {\n                var inUse = getInUse(ancestors);\n                if (inUse) {\n                    inUse.variables.add(node.name.value);\n                }\n            },\n        },\n        FragmentSpread: {\n            enter: function (node, _key, _parent, _path, ancestors) {\n                if (shouldRemoveField(node.directives)) {\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n                var inUse = getInUse(ancestors);\n                if (inUse) {\n                    inUse.fragmentSpreads.add(node.name.value);\n                }\n                // We might like to remove this FragmentSpread by returning null here if\n                // the corresponding FragmentDefinition node is also going to be removed\n                // by the logic below, but we can't control the relative order of those\n                // events, so we have to postpone the removal of dangling FragmentSpread\n                // nodes until after the current visit of the document has finished.\n            },\n        },\n        FragmentDefinition: {\n            enter: function (node, _key, _parent, path) {\n                originalFragmentDefsByPath.set(JSON.stringify(path), node);\n            },\n            leave: function (node, _key, _parent, path) {\n                var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\n                if (node === originalNode) {\n                    // If the FragmentNode received by this leave function is identical to\n                    // the one received by the corresponding enter function (above), then\n                    // the visitor must not have made any changes within this\n                    // FragmentDefinition node. This fragment definition may still be\n                    // removed if there are no ...spread references to it, but it won't be\n                    // removed just because it has only a __typename field.\n                    return node;\n                }\n                if (\n                // This logic applies only if the document contains one or more\n                // operations, since removing all fragments from a document containing\n                // only fragments makes the document useless.\n                operationCount > 0 &&\n                    node.selectionSet.selections.every(function (selection) {\n                        return selection.kind === Kind.FIELD &&\n                            selection.name.value === \"__typename\";\n                    })) {\n                    // This is a somewhat opinionated choice: if a FragmentDefinition ends\n                    // up having no fields other than __typename, we remove the whole\n                    // fragment definition, and later prune ...spread references to it.\n                    getInUseByFragmentName(node.name.value).removed = true;\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n            },\n        },\n        Directive: {\n            leave: function (node) {\n                // If a matching directive is found, remove the directive itself. Note\n                // that this does not remove the target (field, argument, etc) of the\n                // directive, but only the directive itself.\n                if (directiveMatcher(node)) {\n                    firstVisitMadeChanges = true;\n                    return null;\n                }\n            },\n        },\n    });\n    if (!firstVisitMadeChanges) {\n        // If our first pass did not change anything about the document, then there\n        // is no cleanup we need to do, and we can return the original doc.\n        return doc;\n    }\n    // Utility for making sure inUse.transitiveVars is recursively populated.\n    // Because this logic assumes inUse.fragmentSpreads has been completely\n    // populated and inUse.removed has been set if appropriate,\n    // populateTransitiveVars must be called after that information has been\n    // collected by the first traversal of the document.\n    var populateTransitiveVars = function (inUse) {\n        if (!inUse.transitiveVars) {\n            inUse.transitiveVars = new Set(inUse.variables);\n            if (!inUse.removed) {\n                inUse.fragmentSpreads.forEach(function (childFragmentName) {\n                    populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function (varName) {\n                        inUse.transitiveVars.add(varName);\n                    });\n                });\n            }\n        }\n        return inUse;\n    };\n    // Since we've been keeping track of fragment spreads used by particular\n    // operations and fragment definitions, we now need to compute the set of all\n    // spreads used (transitively) by any operations in the document.\n    var allFragmentNamesUsed = new Set();\n    docWithoutDirectiveSubtrees.definitions.forEach(function (def) {\n        if (def.kind === Kind.OPERATION_DEFINITION) {\n            populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function (childFragmentName) {\n                allFragmentNamesUsed.add(childFragmentName);\n            });\n        }\n        else if (def.kind === Kind.FRAGMENT_DEFINITION &&\n            // If there are no operations in the document, then all fragment\n            // definitions count as usages of their own fragment names. This heuristic\n            // prevents accidentally removing all fragment definitions from the\n            // document just because it contains no operations that use the fragments.\n            operationCount === 0 &&\n            !getInUseByFragmentName(def.name.value).removed) {\n            allFragmentNamesUsed.add(def.name.value);\n        }\n    });\n    // Now that we have added all fragment spreads used by operations to the\n    // allFragmentNamesUsed set, we can complete the set by transitively adding\n    // all fragment spreads used by those fragments, and so on.\n    allFragmentNamesUsed.forEach(function (fragmentName) {\n        // Once all the childFragmentName strings added here have been seen already,\n        // the top-level allFragmentNamesUsed.forEach loop will terminate.\n        populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function (childFragmentName) {\n            allFragmentNamesUsed.add(childFragmentName);\n        });\n    });\n    var fragmentWillBeRemoved = function (fragmentName) {\n        return !!(\n        // A fragment definition will be removed if there are no spreads that refer\n        // to it, or the fragment was explicitly removed because it had no fields\n        // other than __typename.\n        (!allFragmentNamesUsed.has(fragmentName) ||\n            getInUseByFragmentName(fragmentName).removed));\n    };\n    var enterVisitor = {\n        enter: function (node) {\n            if (fragmentWillBeRemoved(node.name.value)) {\n                return null;\n            }\n        },\n    };\n    return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {\n        // If the fragment is going to be removed, then leaving any dangling\n        // FragmentSpread nodes with the same name would be a mistake.\n        FragmentSpread: enterVisitor,\n        // This is where the fragment definition is actually removed.\n        FragmentDefinition: enterVisitor,\n        OperationDefinition: {\n            leave: function (node) {\n                // Upon leaving each operation in the depth-first AST traversal, prune\n                // any variables that are declared by the operation but unused within.\n                if (node.variableDefinitions) {\n                    var usedVariableNames_1 = populateTransitiveVars(\n                    // If an operation is anonymous, we use the empty string as its key.\n                    getInUseByOperationName(node.name && node.name.value)).transitiveVars;\n                    // According to the GraphQL spec, all variables declared by an\n                    // operation must either be used by that operation or used by some\n                    // fragment included transitively into that operation:\n                    // https://spec.graphql.org/draft/#sec-All-Variables-Used\n                    //\n                    // To stay on the right side of this validation rule, if/when we\n                    // remove the last $var references from an operation or its fragments,\n                    // we must also remove the corresponding $var declaration from the\n                    // enclosing operation. This pruning applies only to operations and\n                    // not fragment definitions, at the moment. Fragments may be able to\n                    // declare variables eventually, but today they can only consume them.\n                    if (usedVariableNames_1.size < node.variableDefinitions.length) {\n                        return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function (varDef) {\n                                return usedVariableNames_1.has(varDef.variable.name.value);\n                            }) });\n                    }\n                }\n            },\n        },\n    }));\n}\nexport var addTypenameToDocument = Object.assign(function (doc) {\n    return visit(doc, {\n        SelectionSet: {\n            enter: function (node, _key, parent) {\n                // Don't add __typename to OperationDefinitions.\n                if (parent &&\n                    parent.kind ===\n                        Kind.OPERATION_DEFINITION) {\n                    return;\n                }\n                // No changes if no selections.\n                var selections = node.selections;\n                if (!selections) {\n                    return;\n                }\n                // If selections already have a __typename, or are part of an\n                // introspection query, do nothing.\n                var skip = selections.some(function (selection) {\n                    return (isField(selection) &&\n                        (selection.name.value === \"__typename\" ||\n                            selection.name.value.lastIndexOf(\"__\", 0) === 0));\n                });\n                if (skip) {\n                    return;\n                }\n                // If this SelectionSet is @export-ed as an input variable, it should\n                // not have a __typename field (see issue #4691).\n                var field = parent;\n                if (isField(field) &&\n                    field.directives &&\n                    field.directives.some(function (d) { return d.name.value === \"export\"; })) {\n                    return;\n                }\n                // Create and return a new SelectionSet with a __typename Field.\n                return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });\n            },\n        },\n    });\n}, {\n    added: function (field) {\n        return field === TYPENAME_FIELD;\n    },\n});\nvar connectionRemoveConfig = {\n    test: function (directive) {\n        var willRemove = directive.name.value === \"connection\";\n        if (willRemove) {\n            if (!directive.arguments ||\n                !directive.arguments.some(function (arg) { return arg.name.value === \"key\"; })) {\n                globalThis.__DEV__ !== false && invariant.warn(84);\n            }\n        }\n        return willRemove;\n    },\n};\nexport function removeConnectionDirectiveFromDocument(doc) {\n    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    return (!!selectionSet &&\n        selectionSet.selections &&\n        selectionSet.selections.some(function (selection) {\n            return hasDirectivesInSelection(directives, selection, nestedCheck);\n        }));\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n    if (nestedCheck === void 0) { nestedCheck = true; }\n    if (!isField(selection)) {\n        return true;\n    }\n    if (!selection.directives) {\n        return false;\n    }\n    return (selection.directives.some(getDirectiveMatcher(directives)) ||\n        (nestedCheck &&\n            hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck)));\n}\nfunction getArgumentMatcher(config) {\n    return function argumentMatcher(argument) {\n        return config.some(function (aConfig) {\n            return argument.value &&\n                argument.value.kind === Kind.VARIABLE &&\n                argument.value.name &&\n                (aConfig.name === argument.value.name.value ||\n                    (aConfig.test && aConfig.test(argument)));\n        });\n    };\n}\nexport function removeArgumentsFromDocument(config, doc) {\n    var argMatcher = getArgumentMatcher(config);\n    return nullIfDocIsEmpty(visit(doc, {\n        OperationDefinition: {\n            enter: function (node) {\n                return __assign(__assign({}, node), { \n                    // Remove matching top level variables definitions.\n                    variableDefinitions: node.variableDefinitions ?\n                        node.variableDefinitions.filter(function (varDef) {\n                            return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });\n                        })\n                        : [] });\n            },\n        },\n        Field: {\n            enter: function (node) {\n                // If `remove` is set to true for an argument, and an argument match\n                // is found for a field, remove the field as well.\n                var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });\n                if (shouldRemoveField) {\n                    var argMatchCount_1 = 0;\n                    if (node.arguments) {\n                        node.arguments.forEach(function (arg) {\n                            if (argMatcher(arg)) {\n                                argMatchCount_1 += 1;\n                            }\n                        });\n                    }\n                    if (argMatchCount_1 === 1) {\n                        return null;\n                    }\n                }\n            },\n        },\n        Argument: {\n            enter: function (node) {\n                // Remove all matching arguments.\n                if (argMatcher(node)) {\n                    return null;\n                }\n            },\n        },\n    }));\n}\nexport function removeFragmentSpreadFromDocument(config, doc) {\n    function enter(node) {\n        if (config.some(function (def) { return def.name === node.name.value; })) {\n            return null;\n        }\n    }\n    return nullIfDocIsEmpty(visit(doc, {\n        FragmentSpread: { enter: enter },\n        FragmentDefinition: { enter: enter },\n    }));\n}\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(document) {\n    var definition = getMainDefinition(document);\n    var definitionOperation = definition.operation;\n    if (definitionOperation === \"query\") {\n        // Already a query, so return the existing document.\n        return document;\n    }\n    // Build a new query using the selection set of the main operation.\n    var modifiedDoc = visit(document, {\n        OperationDefinition: {\n            enter: function (node) {\n                return __assign(__assign({}, node), { operation: \"query\" });\n            },\n        },\n    });\n    return modifiedDoc;\n}\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(document) {\n    checkDocument(document);\n    var modifiedDoc = removeDirectivesFromDocument([\n        {\n            test: function (directive) { return directive.name.value === \"client\"; },\n            remove: true,\n        },\n    ], document);\n    return modifiedDoc;\n}\n//# sourceMappingURL=transform.js.map",
      "start": 1713269988618,
      "end": 1713269988688,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "graphql",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269988688,
      "end": 1713269988688,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1713269988688,
      "end": 1713269988689,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { __assign, __spreadArray } from \"tslib\";\nimport { invariant } from \"../globals/index.js\";\nimport { visit, Kind } from \"graphql\";\nimport { checkDocument, getOperationDefinition, getFragmentDefinition, getFragmentDefinitions, getMainDefinition } from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray, isNonEmptyArray } from \"../common/arrays.js\";\nvar TYPENAME_FIELD = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: \"__typename\"\n  }\n};\nfunction isEmpty(op, fragmentMap) {\n  return !op || op.selectionSet.selections.every(function(selection) {\n    return selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);\n  });\n}\nfunction nullIfDocIsEmpty(doc) {\n  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;\n}\nfunction getDirectiveMatcher(configs) {\n  var names = /* @__PURE__ */ new Map();\n  var tests = /* @__PURE__ */ new Map();\n  configs.forEach(function(directive) {\n    if (directive) {\n      if (directive.name) {\n        names.set(directive.name, directive);\n      } else if (directive.test) {\n        tests.set(directive.test, directive);\n      }\n    }\n  });\n  return function(directive) {\n    var config = names.get(directive.name.value);\n    if (!config && tests.size) {\n      tests.forEach(function(testConfig, test) {\n        if (test(directive)) {\n          config = testConfig;\n        }\n      });\n    }\n    return config;\n  };\n}\nfunction makeInUseGetterFunction(defaultKey) {\n  var map = /* @__PURE__ */ new Map();\n  return function inUseGetterFunction(key) {\n    if (key === void 0) {\n      key = defaultKey;\n    }\n    var inUse = map.get(key);\n    if (!inUse) {\n      map.set(key, inUse = {\n        // Variable and fragment spread names used directly within this\n        // operation or fragment definition, as identified by key. These sets\n        // will be populated during the first traversal of the document in\n        // removeDirectivesFromDocument below.\n        variables: /* @__PURE__ */ new Set(),\n        fragmentSpreads: /* @__PURE__ */ new Set()\n      });\n    }\n    return inUse;\n  };\n}\nexport function removeDirectivesFromDocument(directives, doc) {\n  checkDocument(doc);\n  var getInUseByOperationName = makeInUseGetterFunction(\"\");\n  var getInUseByFragmentName = makeInUseGetterFunction(\"\");\n  var getInUse = function(ancestors) {\n    for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {\n      if (isArray(ancestor))\n        continue;\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n    globalThis.__DEV__ !== false && invariant.error(83);\n    return null;\n  };\n  var operationCount = 0;\n  for (var i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n  var directiveMatcher = getDirectiveMatcher(directives);\n  var shouldRemoveField = function(nodeDirectives) {\n    return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {\n      return config && config.remove;\n    });\n  };\n  var originalFragmentDefsByPath = /* @__PURE__ */ new Map();\n  var firstVisitMadeChanges = false;\n  var fieldOrInlineFragmentVisitor = {\n    enter: function(node) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    }\n  };\n  var docWithoutDirectiveSubtrees = visit(doc, {\n    // These two AST node types share the same implementation, defined above.\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n    VariableDefinition: {\n      enter: function() {\n        return false;\n      }\n    },\n    Variable: {\n      enter: function(node, _key, _parent, _path, ancestors) {\n        var inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      }\n    },\n    FragmentSpread: {\n      enter: function(node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n        var inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        }\n      }\n    },\n    FragmentDefinition: {\n      enter: function(node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave: function(node, _key, _parent, path) {\n        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\n        if (node === originalNode) {\n          return node;\n        }\n        if (\n          // This logic applies only if the document contains one or more\n          // operations, since removing all fragments from a document containing\n          // only fragments makes the document useless.\n          operationCount > 0 && node.selectionSet.selections.every(function(selection) {\n            return selection.kind === Kind.FIELD && selection.name.value === \"__typename\";\n          })\n        ) {\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      }\n    },\n    Directive: {\n      leave: function(node) {\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      }\n    }\n  });\n  if (!firstVisitMadeChanges) {\n    return doc;\n  }\n  var populateTransitiveVars = function(inUse) {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach(function(childFragmentName) {\n          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {\n            inUse.transitiveVars.add(varName);\n          });\n        });\n      }\n    }\n    return inUse;\n  };\n  var allFragmentNamesUsed = /* @__PURE__ */ new Set();\n  docWithoutDirectiveSubtrees.definitions.forEach(function(def) {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (def.kind === Kind.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment\n    // definitions count as usages of their own fragment names. This heuristic\n    // prevents accidentally removing all fragment definitions from the\n    // document just because it contains no operations that use the fragments.\n    operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  });\n  allFragmentNamesUsed.forEach(function(fragmentName) {\n    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n  var fragmentWillBeRemoved = function(fragmentName) {\n    return !!// A fragment definition will be removed if there are no spreads that refer\n    // to it, or the fragment was explicitly removed because it had no fields\n    // other than __typename.\n    (!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);\n  };\n  var enterVisitor = {\n    enter: function(node) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    }\n  };\n  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {\n    // If the fragment is going to be removed, then leaving any dangling\n    // FragmentSpread nodes with the same name would be a mistake.\n    FragmentSpread: enterVisitor,\n    // This is where the fragment definition is actually removed.\n    FragmentDefinition: enterVisitor,\n    OperationDefinition: {\n      leave: function(node) {\n        if (node.variableDefinitions) {\n          var usedVariableNames_1 = populateTransitiveVars(\n            // If an operation is anonymous, we use the empty string as its key.\n            getInUseByOperationName(node.name && node.name.value)\n          ).transitiveVars;\n          if (usedVariableNames_1.size < node.variableDefinitions.length) {\n            return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function(varDef) {\n              return usedVariableNames_1.has(varDef.variable.name.value);\n            }) });\n          }\n        }\n      }\n    }\n  }));\n}\nexport var addTypenameToDocument = Object.assign(function(doc) {\n  return visit(doc, {\n    SelectionSet: {\n      enter: function(node, _key, parent) {\n        if (parent && parent.kind === Kind.OPERATION_DEFINITION) {\n          return;\n        }\n        var selections = node.selections;\n        if (!selections) {\n          return;\n        }\n        var skip = selections.some(function(selection) {\n          return isField(selection) && (selection.name.value === \"__typename\" || selection.name.value.lastIndexOf(\"__\", 0) === 0);\n        });\n        if (skip) {\n          return;\n        }\n        var field = parent;\n        if (isField(field) && field.directives && field.directives.some(function(d) {\n          return d.name.value === \"export\";\n        })) {\n          return;\n        }\n        return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });\n      }\n    }\n  });\n}, {\n  added: function(field) {\n    return field === TYPENAME_FIELD;\n  }\n});\nvar connectionRemoveConfig = {\n  test: function(directive) {\n    var willRemove = directive.name.value === \"connection\";\n    if (willRemove) {\n      if (!directive.arguments || !directive.arguments.some(function(arg) {\n        return arg.name.value === \"key\";\n      })) {\n        globalThis.__DEV__ !== false && invariant.warn(84);\n      }\n    }\n    return willRemove;\n  }\n};\nexport function removeConnectionDirectiveFromDocument(doc) {\n  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n  return !!selectionSet && selectionSet.selections && selectionSet.selections.some(function(selection) {\n    return hasDirectivesInSelection(directives, selection, nestedCheck);\n  });\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n  if (!isField(selection)) {\n    return true;\n  }\n  if (!selection.directives) {\n    return false;\n  }\n  return selection.directives.some(getDirectiveMatcher(directives)) || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);\n}\nfunction getArgumentMatcher(config) {\n  return function argumentMatcher(argument) {\n    return config.some(function(aConfig) {\n      return argument.value && argument.value.kind === Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));\n    });\n  };\n}\nexport function removeArgumentsFromDocument(config, doc) {\n  var argMatcher = getArgumentMatcher(config);\n  return nullIfDocIsEmpty(visit(doc, {\n    OperationDefinition: {\n      enter: function(node) {\n        return __assign(__assign({}, node), {\n          // Remove matching top level variables definitions.\n          variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {\n            return !config.some(function(arg) {\n              return arg.name === varDef.variable.name.value;\n            });\n          }) : []\n        });\n      }\n    },\n    Field: {\n      enter: function(node) {\n        var shouldRemoveField = config.some(function(argConfig) {\n          return argConfig.remove;\n        });\n        if (shouldRemoveField) {\n          var argMatchCount_1 = 0;\n          if (node.arguments) {\n            node.arguments.forEach(function(arg) {\n              if (argMatcher(arg)) {\n                argMatchCount_1 += 1;\n              }\n            });\n          }\n          if (argMatchCount_1 === 1) {\n            return null;\n          }\n        }\n      }\n    },\n    Argument: {\n      enter: function(node) {\n        if (argMatcher(node)) {\n          return null;\n        }\n      }\n    }\n  }));\n}\nexport function removeFragmentSpreadFromDocument(config, doc) {\n  function enter(node) {\n    if (config.some(function(def) {\n      return def.name === node.name.value;\n    })) {\n      return null;\n    }\n  }\n  return nullIfDocIsEmpty(visit(doc, {\n    FragmentSpread: { enter },\n    FragmentDefinition: { enter }\n  }));\n}\nexport function buildQueryFromSelectionSet(document) {\n  var definition = getMainDefinition(document);\n  var definitionOperation = definition.operation;\n  if (definitionOperation === \"query\") {\n    return document;\n  }\n  var modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter: function(node) {\n        return __assign(__assign({}, node), { operation: \"query\" });\n      }\n    }\n  });\n  return modifiedDoc;\n}\nexport function removeClientSetsFromDocument(document) {\n  checkDocument(document);\n  var modifiedDoc = removeDirectivesFromDocument([\n    {\n      test: function(directive) {\n        return directive.name.value === \"client\";\n      },\n      remove: true\n    }\n  ], document);\n  return modifiedDoc;\n}\n",
      "start": 1713269988689,
      "end": 1713269989232,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/utilities/graphql/transform.js\"],\n  \"sourcesContent\": [\"import { __assign, __spreadArray } from \\\"tslib\\\";\\nimport { invariant } from \\\"../globals/index.js\\\";\\nimport { visit, Kind } from \\\"graphql\\\";\\nimport { checkDocument, getOperationDefinition, getFragmentDefinition, getFragmentDefinitions, getMainDefinition, } from \\\"./getFromAST.js\\\";\\nimport { isField } from \\\"./storeUtils.js\\\";\\nimport { createFragmentMap } from \\\"./fragments.js\\\";\\nimport { isArray, isNonEmptyArray } from \\\"../common/arrays.js\\\";\\nvar TYPENAME_FIELD = {\\n    kind: Kind.FIELD,\\n    name: {\\n        kind: Kind.NAME,\\n        value: \\\"__typename\\\",\\n    },\\n};\\nfunction isEmpty(op, fragmentMap) {\\n    return (!op ||\\n        op.selectionSet.selections.every(function (selection) {\\n            return selection.kind === Kind.FRAGMENT_SPREAD &&\\n                isEmpty(fragmentMap[selection.name.value], fragmentMap);\\n        }));\\n}\\nfunction nullIfDocIsEmpty(doc) {\\n    return (isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))) ?\\n        null\\n        : doc;\\n}\\nfunction getDirectiveMatcher(configs) {\\n    var names = new Map();\\n    var tests = new Map();\\n    configs.forEach(function (directive) {\\n        if (directive) {\\n            if (directive.name) {\\n                names.set(directive.name, directive);\\n            }\\n            else if (directive.test) {\\n                tests.set(directive.test, directive);\\n            }\\n        }\\n    });\\n    return function (directive) {\\n        var config = names.get(directive.name.value);\\n        if (!config && tests.size) {\\n            tests.forEach(function (testConfig, test) {\\n                if (test(directive)) {\\n                    config = testConfig;\\n                }\\n            });\\n        }\\n        return config;\\n    };\\n}\\nfunction makeInUseGetterFunction(defaultKey) {\\n    var map = new Map();\\n    return function inUseGetterFunction(key) {\\n        if (key === void 0) { key = defaultKey; }\\n        var inUse = map.get(key);\\n        if (!inUse) {\\n            map.set(key, (inUse = {\\n                // Variable and fragment spread names used directly within this\\n                // operation or fragment definition, as identified by key. These sets\\n                // will be populated during the first traversal of the document in\\n                // removeDirectivesFromDocument below.\\n                variables: new Set(),\\n                fragmentSpreads: new Set(),\\n            }));\\n        }\\n        return inUse;\\n    };\\n}\\nexport function removeDirectivesFromDocument(directives, doc) {\\n    checkDocument(doc);\\n    // Passing empty strings to makeInUseGetterFunction means we handle anonymous\\n    // operations as if their names were \\\"\\\". Anonymous fragment definitions are\\n    // not supposed to be possible, but the same default naming strategy seems\\n    // appropriate for that case as well.\\n    var getInUseByOperationName = makeInUseGetterFunction(\\\"\\\");\\n    var getInUseByFragmentName = makeInUseGetterFunction(\\\"\\\");\\n    var getInUse = function (ancestors) {\\n        for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {\\n            if (isArray(ancestor))\\n                continue;\\n            if (ancestor.kind === Kind.OPERATION_DEFINITION) {\\n                // If an operation is anonymous, we use the empty string as its key.\\n                return getInUseByOperationName(ancestor.name && ancestor.name.value);\\n            }\\n            if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\\n                return getInUseByFragmentName(ancestor.name.value);\\n            }\\n        }\\n        globalThis.__DEV__ !== false && invariant.error(83);\\n        return null;\\n    };\\n    var operationCount = 0;\\n    for (var i = doc.definitions.length - 1; i >= 0; --i) {\\n        if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\\n            ++operationCount;\\n        }\\n    }\\n    var directiveMatcher = getDirectiveMatcher(directives);\\n    var shouldRemoveField = function (nodeDirectives) {\\n        return isNonEmptyArray(nodeDirectives) &&\\n            nodeDirectives\\n                .map(directiveMatcher)\\n                .some(function (config) { return config && config.remove; });\\n    };\\n    var originalFragmentDefsByPath = new Map();\\n    // Any time the first traversal of the document below makes a change like\\n    // removing a fragment (by returning null), this variable should be set to\\n    // true. Once it becomes true, it should never be set to false again. If this\\n    // variable remains false throughout the traversal, then we can return the\\n    // original doc immediately without any modifications.\\n    var firstVisitMadeChanges = false;\\n    var fieldOrInlineFragmentVisitor = {\\n        enter: function (node) {\\n            if (shouldRemoveField(node.directives)) {\\n                firstVisitMadeChanges = true;\\n                return null;\\n            }\\n        },\\n    };\\n    var docWithoutDirectiveSubtrees = visit(doc, {\\n        // These two AST node types share the same implementation, defined above.\\n        Field: fieldOrInlineFragmentVisitor,\\n        InlineFragment: fieldOrInlineFragmentVisitor,\\n        VariableDefinition: {\\n            enter: function () {\\n                // VariableDefinition nodes do not count as variables in use, though\\n                // they do contain Variable nodes that might be visited below. To avoid\\n                // counting variable declarations as usages, we skip visiting the\\n                // contents of this VariableDefinition node by returning false.\\n                return false;\\n            },\\n        },\\n        Variable: {\\n            enter: function (node, _key, _parent, _path, ancestors) {\\n                var inUse = getInUse(ancestors);\\n                if (inUse) {\\n                    inUse.variables.add(node.name.value);\\n                }\\n            },\\n        },\\n        FragmentSpread: {\\n            enter: function (node, _key, _parent, _path, ancestors) {\\n                if (shouldRemoveField(node.directives)) {\\n                    firstVisitMadeChanges = true;\\n                    return null;\\n                }\\n                var inUse = getInUse(ancestors);\\n                if (inUse) {\\n                    inUse.fragmentSpreads.add(node.name.value);\\n                }\\n                // We might like to remove this FragmentSpread by returning null here if\\n                // the corresponding FragmentDefinition node is also going to be removed\\n                // by the logic below, but we can't control the relative order of those\\n                // events, so we have to postpone the removal of dangling FragmentSpread\\n                // nodes until after the current visit of the document has finished.\\n            },\\n        },\\n        FragmentDefinition: {\\n            enter: function (node, _key, _parent, path) {\\n                originalFragmentDefsByPath.set(JSON.stringify(path), node);\\n            },\\n            leave: function (node, _key, _parent, path) {\\n                var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\\n                if (node === originalNode) {\\n                    // If the FragmentNode received by this leave function is identical to\\n                    // the one received by the corresponding enter function (above), then\\n                    // the visitor must not have made any changes within this\\n                    // FragmentDefinition node. This fragment definition may still be\\n                    // removed if there are no ...spread references to it, but it won't be\\n                    // removed just because it has only a __typename field.\\n                    return node;\\n                }\\n                if (\\n                // This logic applies only if the document contains one or more\\n                // operations, since removing all fragments from a document containing\\n                // only fragments makes the document useless.\\n                operationCount > 0 &&\\n                    node.selectionSet.selections.every(function (selection) {\\n                        return selection.kind === Kind.FIELD &&\\n                            selection.name.value === \\\"__typename\\\";\\n                    })) {\\n                    // This is a somewhat opinionated choice: if a FragmentDefinition ends\\n                    // up having no fields other than __typename, we remove the whole\\n                    // fragment definition, and later prune ...spread references to it.\\n                    getInUseByFragmentName(node.name.value).removed = true;\\n                    firstVisitMadeChanges = true;\\n                    return null;\\n                }\\n            },\\n        },\\n        Directive: {\\n            leave: function (node) {\\n                // If a matching directive is found, remove the directive itself. Note\\n                // that this does not remove the target (field, argument, etc) of the\\n                // directive, but only the directive itself.\\n                if (directiveMatcher(node)) {\\n                    firstVisitMadeChanges = true;\\n                    return null;\\n                }\\n            },\\n        },\\n    });\\n    if (!firstVisitMadeChanges) {\\n        // If our first pass did not change anything about the document, then there\\n        // is no cleanup we need to do, and we can return the original doc.\\n        return doc;\\n    }\\n    // Utility for making sure inUse.transitiveVars is recursively populated.\\n    // Because this logic assumes inUse.fragmentSpreads has been completely\\n    // populated and inUse.removed has been set if appropriate,\\n    // populateTransitiveVars must be called after that information has been\\n    // collected by the first traversal of the document.\\n    var populateTransitiveVars = function (inUse) {\\n        if (!inUse.transitiveVars) {\\n            inUse.transitiveVars = new Set(inUse.variables);\\n            if (!inUse.removed) {\\n                inUse.fragmentSpreads.forEach(function (childFragmentName) {\\n                    populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function (varName) {\\n                        inUse.transitiveVars.add(varName);\\n                    });\\n                });\\n            }\\n        }\\n        return inUse;\\n    };\\n    // Since we've been keeping track of fragment spreads used by particular\\n    // operations and fragment definitions, we now need to compute the set of all\\n    // spreads used (transitively) by any operations in the document.\\n    var allFragmentNamesUsed = new Set();\\n    docWithoutDirectiveSubtrees.definitions.forEach(function (def) {\\n        if (def.kind === Kind.OPERATION_DEFINITION) {\\n            populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function (childFragmentName) {\\n                allFragmentNamesUsed.add(childFragmentName);\\n            });\\n        }\\n        else if (def.kind === Kind.FRAGMENT_DEFINITION &&\\n            // If there are no operations in the document, then all fragment\\n            // definitions count as usages of their own fragment names. This heuristic\\n            // prevents accidentally removing all fragment definitions from the\\n            // document just because it contains no operations that use the fragments.\\n            operationCount === 0 &&\\n            !getInUseByFragmentName(def.name.value).removed) {\\n            allFragmentNamesUsed.add(def.name.value);\\n        }\\n    });\\n    // Now that we have added all fragment spreads used by operations to the\\n    // allFragmentNamesUsed set, we can complete the set by transitively adding\\n    // all fragment spreads used by those fragments, and so on.\\n    allFragmentNamesUsed.forEach(function (fragmentName) {\\n        // Once all the childFragmentName strings added here have been seen already,\\n        // the top-level allFragmentNamesUsed.forEach loop will terminate.\\n        populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function (childFragmentName) {\\n            allFragmentNamesUsed.add(childFragmentName);\\n        });\\n    });\\n    var fragmentWillBeRemoved = function (fragmentName) {\\n        return !!(\\n        // A fragment definition will be removed if there are no spreads that refer\\n        // to it, or the fragment was explicitly removed because it had no fields\\n        // other than __typename.\\n        (!allFragmentNamesUsed.has(fragmentName) ||\\n            getInUseByFragmentName(fragmentName).removed));\\n    };\\n    var enterVisitor = {\\n        enter: function (node) {\\n            if (fragmentWillBeRemoved(node.name.value)) {\\n                return null;\\n            }\\n        },\\n    };\\n    return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {\\n        // If the fragment is going to be removed, then leaving any dangling\\n        // FragmentSpread nodes with the same name would be a mistake.\\n        FragmentSpread: enterVisitor,\\n        // This is where the fragment definition is actually removed.\\n        FragmentDefinition: enterVisitor,\\n        OperationDefinition: {\\n            leave: function (node) {\\n                // Upon leaving each operation in the depth-first AST traversal, prune\\n                // any variables that are declared by the operation but unused within.\\n                if (node.variableDefinitions) {\\n                    var usedVariableNames_1 = populateTransitiveVars(\\n                    // If an operation is anonymous, we use the empty string as its key.\\n                    getInUseByOperationName(node.name && node.name.value)).transitiveVars;\\n                    // According to the GraphQL spec, all variables declared by an\\n                    // operation must either be used by that operation or used by some\\n                    // fragment included transitively into that operation:\\n                    // https://spec.graphql.org/draft/#sec-All-Variables-Used\\n                    //\\n                    // To stay on the right side of this validation rule, if/when we\\n                    // remove the last $var references from an operation or its fragments,\\n                    // we must also remove the corresponding $var declaration from the\\n                    // enclosing operation. This pruning applies only to operations and\\n                    // not fragment definitions, at the moment. Fragments may be able to\\n                    // declare variables eventually, but today they can only consume them.\\n                    if (usedVariableNames_1.size < node.variableDefinitions.length) {\\n                        return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function (varDef) {\\n                                return usedVariableNames_1.has(varDef.variable.name.value);\\n                            }) });\\n                    }\\n                }\\n            },\\n        },\\n    }));\\n}\\nexport var addTypenameToDocument = Object.assign(function (doc) {\\n    return visit(doc, {\\n        SelectionSet: {\\n            enter: function (node, _key, parent) {\\n                // Don't add __typename to OperationDefinitions.\\n                if (parent &&\\n                    parent.kind ===\\n                        Kind.OPERATION_DEFINITION) {\\n                    return;\\n                }\\n                // No changes if no selections.\\n                var selections = node.selections;\\n                if (!selections) {\\n                    return;\\n                }\\n                // If selections already have a __typename, or are part of an\\n                // introspection query, do nothing.\\n                var skip = selections.some(function (selection) {\\n                    return (isField(selection) &&\\n                        (selection.name.value === \\\"__typename\\\" ||\\n                            selection.name.value.lastIndexOf(\\\"__\\\", 0) === 0));\\n                });\\n                if (skip) {\\n                    return;\\n                }\\n                // If this SelectionSet is @export-ed as an input variable, it should\\n                // not have a __typename field (see issue #4691).\\n                var field = parent;\\n                if (isField(field) &&\\n                    field.directives &&\\n                    field.directives.some(function (d) { return d.name.value === \\\"export\\\"; })) {\\n                    return;\\n                }\\n                // Create and return a new SelectionSet with a __typename Field.\\n                return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });\\n            },\\n        },\\n    });\\n}, {\\n    added: function (field) {\\n        return field === TYPENAME_FIELD;\\n    },\\n});\\nvar connectionRemoveConfig = {\\n    test: function (directive) {\\n        var willRemove = directive.name.value === \\\"connection\\\";\\n        if (willRemove) {\\n            if (!directive.arguments ||\\n                !directive.arguments.some(function (arg) { return arg.name.value === \\\"key\\\"; })) {\\n                globalThis.__DEV__ !== false && invariant.warn(84);\\n            }\\n        }\\n        return willRemove;\\n    },\\n};\\nexport function removeConnectionDirectiveFromDocument(doc) {\\n    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\\n}\\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\\n    if (nestedCheck === void 0) { nestedCheck = true; }\\n    return (!!selectionSet &&\\n        selectionSet.selections &&\\n        selectionSet.selections.some(function (selection) {\\n            return hasDirectivesInSelection(directives, selection, nestedCheck);\\n        }));\\n}\\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\\n    if (nestedCheck === void 0) { nestedCheck = true; }\\n    if (!isField(selection)) {\\n        return true;\\n    }\\n    if (!selection.directives) {\\n        return false;\\n    }\\n    return (selection.directives.some(getDirectiveMatcher(directives)) ||\\n        (nestedCheck &&\\n            hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck)));\\n}\\nfunction getArgumentMatcher(config) {\\n    return function argumentMatcher(argument) {\\n        return config.some(function (aConfig) {\\n            return argument.value &&\\n                argument.value.kind === Kind.VARIABLE &&\\n                argument.value.name &&\\n                (aConfig.name === argument.value.name.value ||\\n                    (aConfig.test && aConfig.test(argument)));\\n        });\\n    };\\n}\\nexport function removeArgumentsFromDocument(config, doc) {\\n    var argMatcher = getArgumentMatcher(config);\\n    return nullIfDocIsEmpty(visit(doc, {\\n        OperationDefinition: {\\n            enter: function (node) {\\n                return __assign(__assign({}, node), { \\n                    // Remove matching top level variables definitions.\\n                    variableDefinitions: node.variableDefinitions ?\\n                        node.variableDefinitions.filter(function (varDef) {\\n                            return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });\\n                        })\\n                        : [] });\\n            },\\n        },\\n        Field: {\\n            enter: function (node) {\\n                // If `remove` is set to true for an argument, and an argument match\\n                // is found for a field, remove the field as well.\\n                var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });\\n                if (shouldRemoveField) {\\n                    var argMatchCount_1 = 0;\\n                    if (node.arguments) {\\n                        node.arguments.forEach(function (arg) {\\n                            if (argMatcher(arg)) {\\n                                argMatchCount_1 += 1;\\n                            }\\n                        });\\n                    }\\n                    if (argMatchCount_1 === 1) {\\n                        return null;\\n                    }\\n                }\\n            },\\n        },\\n        Argument: {\\n            enter: function (node) {\\n                // Remove all matching arguments.\\n                if (argMatcher(node)) {\\n                    return null;\\n                }\\n            },\\n        },\\n    }));\\n}\\nexport function removeFragmentSpreadFromDocument(config, doc) {\\n    function enter(node) {\\n        if (config.some(function (def) { return def.name === node.name.value; })) {\\n            return null;\\n        }\\n    }\\n    return nullIfDocIsEmpty(visit(doc, {\\n        FragmentSpread: { enter: enter },\\n        FragmentDefinition: { enter: enter },\\n    }));\\n}\\n// If the incoming document is a query, return it as is. Otherwise, build a\\n// new document containing a query operation based on the selection set\\n// of the previous main operation.\\nexport function buildQueryFromSelectionSet(document) {\\n    var definition = getMainDefinition(document);\\n    var definitionOperation = definition.operation;\\n    if (definitionOperation === \\\"query\\\") {\\n        // Already a query, so return the existing document.\\n        return document;\\n    }\\n    // Build a new query using the selection set of the main operation.\\n    var modifiedDoc = visit(document, {\\n        OperationDefinition: {\\n            enter: function (node) {\\n                return __assign(__assign({}, node), { operation: \\\"query\\\" });\\n            },\\n        },\\n    });\\n    return modifiedDoc;\\n}\\n// Remove fields / selection sets that include an @client directive.\\nexport function removeClientSetsFromDocument(document) {\\n    checkDocument(document);\\n    var modifiedDoc = removeDirectivesFromDocument([\\n        {\\n            test: function (directive) { return directive.name.value === \\\"client\\\"; },\\n            remove: true,\\n        },\\n    ], document);\\n    return modifiedDoc;\\n}\\n//# sourceMappingURL=transform.js.map\"],\n  \"mappings\": \"AAAA,SAAS,UAAU,qBAAqB;AACxC,SAAS,iBAAiB;AAC1B,SAAS,OAAO,YAAY;AAC5B,SAAS,eAAe,wBAAwB,uBAAuB,wBAAwB,yBAA0B;AACzH,SAAS,eAAe;AACxB,SAAS,yBAAyB;AAClC,SAAS,SAAS,uBAAuB;AACzC,IAAI,iBAAiB;AAAA,EACjB,MAAM,KAAK;AAAA,EACX,MAAM;AAAA,IACF,MAAM,KAAK;AAAA,IACX,OAAO;AAAA,EACX;AACJ;AACA,SAAS,QAAQ,IAAI,aAAa;AAC9B,SAAQ,CAAC,MACL,GAAG,aAAa,WAAW,MAAM,SAAU,WAAW;AAClD,WAAO,UAAU,SAAS,KAAK,mBAC3B,QAAQ,YAAY,UAAU,KAAK,KAAK,GAAG,WAAW;AAAA,EAC9D,CAAC;AACT;AACA,SAAS,iBAAiB,KAAK;AAC3B,SAAQ,QAAQ,uBAAuB,GAAG,KAAK,sBAAsB,GAAG,GAAG,kBAAkB,uBAAuB,GAAG,CAAC,CAAC,IACrH,OACE;AACV;AACA,SAAS,oBAAoB,SAAS;AAClC,MAAI,QAAQ,oBAAI,IAAI;AACpB,MAAI,QAAQ,oBAAI,IAAI;AACpB,UAAQ,QAAQ,SAAU,WAAW;AACjC,QAAI,WAAW;AACX,UAAI,UAAU,MAAM;AAChB,cAAM,IAAI,UAAU,MAAM,SAAS;AAAA,MACvC,WACS,UAAU,MAAM;AACrB,cAAM,IAAI,UAAU,MAAM,SAAS;AAAA,MACvC;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,SAAO,SAAU,WAAW;AACxB,QAAI,SAAS,MAAM,IAAI,UAAU,KAAK,KAAK;AAC3C,QAAI,CAAC,UAAU,MAAM,MAAM;AACvB,YAAM,QAAQ,SAAU,YAAY,MAAM;AACtC,YAAI,KAAK,SAAS,GAAG;AACjB,mBAAS;AAAA,QACb;AAAA,MACJ,CAAC;AAAA,IACL;AACA,WAAO;AAAA,EACX;AACJ;AACA,SAAS,wBAAwB,YAAY;AACzC,MAAI,MAAM,oBAAI,IAAI;AAClB,SAAO,SAAS,oBAAoB,KAAK;AACrC,QAAI,QAAQ,QAAQ;AAAE,YAAM;AAAA,IAAY;AACxC,QAAI,QAAQ,IAAI,IAAI,GAAG;AACvB,QAAI,CAAC,OAAO;AACR,UAAI,IAAI,KAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,QAKlB,WAAW,oBAAI,IAAI;AAAA,QACnB,iBAAiB,oBAAI,IAAI;AAAA,MAC7B,CAAE;AAAA,IACN;AACA,WAAO;AAAA,EACX;AACJ;AACO,gBAAS,6BAA6B,YAAY,KAAK;AAC1D,gBAAc,GAAG;AAKjB,MAAI,0BAA0B,wBAAwB,EAAE;AACxD,MAAI,yBAAyB,wBAAwB,EAAE;AACvD,MAAI,WAAW,SAAU,WAAW;AAChC,aAAS,IAAI,GAAG,WAAW,QAAQ,IAAI,UAAU,WAAW,WAAW,UAAU,CAAC,IAAI,EAAE,GAAG;AACvF,UAAI,QAAQ,QAAQ;AAChB;AACJ,UAAI,SAAS,SAAS,KAAK,sBAAsB;AAE7C,eAAO,wBAAwB,SAAS,QAAQ,SAAS,KAAK,KAAK;AAAA,MACvE;AACA,UAAI,SAAS,SAAS,KAAK,qBAAqB;AAC5C,eAAO,uBAAuB,SAAS,KAAK,KAAK;AAAA,MACrD;AAAA,IACJ;AACA,eAAW,YAAY,SAAS,UAAU,MAAM,EAAE;AAClD,WAAO;AAAA,EACX;AACA,MAAI,iBAAiB;AACrB,WAAS,IAAI,IAAI,YAAY,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AAClD,QAAI,IAAI,YAAY,CAAC,EAAE,SAAS,KAAK,sBAAsB;AACvD,QAAE;AAAA,IACN;AAAA,EACJ;AACA,MAAI,mBAAmB,oBAAoB,UAAU;AACrD,MAAI,oBAAoB,SAAU,gBAAgB;AAC9C,WAAO,gBAAgB,cAAc,KACjC,eACK,IAAI,gBAAgB,EACpB,KAAK,SAAU,QAAQ;AAAE,aAAO,UAAU,OAAO;AAAA,IAAQ,CAAC;AAAA,EACvE;AACA,MAAI,6BAA6B,oBAAI,IAAI;AAMzC,MAAI,wBAAwB;AAC5B,MAAI,+BAA+B;AAAA,IAC/B,OAAO,SAAU,MAAM;AACnB,UAAI,kBAAkB,KAAK,UAAU,GAAG;AACpC,gCAAwB;AACxB,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AACA,MAAI,8BAA8B,MAAM,KAAK;AAAA;AAAA,IAEzC,OAAO;AAAA,IACP,gBAAgB;AAAA,IAChB,oBAAoB;AAAA,MAChB,OAAO,WAAY;AAKf,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,IACA,UAAU;AAAA,MACN,OAAO,SAAU,MAAM,MAAM,SAAS,OAAO,WAAW;AACpD,YAAI,QAAQ,SAAS,SAAS;AAC9B,YAAI,OAAO;AACP,gBAAM,UAAU,IAAI,KAAK,KAAK,KAAK;AAAA,QACvC;AAAA,MACJ;AAAA,IACJ;AAAA,IACA,gBAAgB;AAAA,MACZ,OAAO,SAAU,MAAM,MAAM,SAAS,OAAO,WAAW;AACpD,YAAI,kBAAkB,KAAK,UAAU,GAAG;AACpC,kCAAwB;AACxB,iBAAO;AAAA,QACX;AACA,YAAI,QAAQ,SAAS,SAAS;AAC9B,YAAI,OAAO;AACP,gBAAM,gBAAgB,IAAI,KAAK,KAAK,KAAK;AAAA,QAC7C;AAAA,MAMJ;AAAA,IACJ;AAAA,IACA,oBAAoB;AAAA,MAChB,OAAO,SAAU,MAAM,MAAM,SAAS,MAAM;AACxC,mCAA2B,IAAI,KAAK,UAAU,IAAI,GAAG,IAAI;AAAA,MAC7D;AAAA,MACA,OAAO,SAAU,MAAM,MAAM,SAAS,MAAM;AACxC,YAAI,eAAe,2BAA2B,IAAI,KAAK,UAAU,IAAI,CAAC;AACtE,YAAI,SAAS,cAAc;AAOvB,iBAAO;AAAA,QACX;AACA;AAAA;AAAA;AAAA;AAAA,UAIA,iBAAiB,KACb,KAAK,aAAa,WAAW,MAAM,SAAU,WAAW;AACpD,mBAAO,UAAU,SAAS,KAAK,SAC3B,UAAU,KAAK,UAAU;AAAA,UACjC,CAAC;AAAA,UAAG;AAIJ,iCAAuB,KAAK,KAAK,KAAK,EAAE,UAAU;AAClD,kCAAwB;AACxB,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAAA,IACA,WAAW;AAAA,MACP,OAAO,SAAU,MAAM;AAInB,YAAI,iBAAiB,IAAI,GAAG;AACxB,kCAAwB;AACxB,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,MAAI,CAAC,uBAAuB;AAGxB,WAAO;AAAA,EACX;AAMA,MAAI,yBAAyB,SAAU,OAAO;AAC1C,QAAI,CAAC,MAAM,gBAAgB;AACvB,YAAM,iBAAiB,IAAI,IAAI,MAAM,SAAS;AAC9C,UAAI,CAAC,MAAM,SAAS;AAChB,cAAM,gBAAgB,QAAQ,SAAU,mBAAmB;AACvD,iCAAuB,uBAAuB,iBAAiB,CAAC,EAAE,eAAe,QAAQ,SAAU,SAAS;AACxG,kBAAM,eAAe,IAAI,OAAO;AAAA,UACpC,CAAC;AAAA,QACL,CAAC;AAAA,MACL;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAIA,MAAI,uBAAuB,oBAAI,IAAI;AACnC,8BAA4B,YAAY,QAAQ,SAAU,KAAK;AAC3D,QAAI,IAAI,SAAS,KAAK,sBAAsB;AACxC,6BAAuB,wBAAwB,IAAI,QAAQ,IAAI,KAAK,KAAK,CAAC,EAAE,gBAAgB,QAAQ,SAAU,mBAAmB;AAC7H,6BAAqB,IAAI,iBAAiB;AAAA,MAC9C,CAAC;AAAA,IACL,WACS,IAAI,SAAS,KAAK;AAAA;AAAA;AAAA;AAAA,IAKvB,mBAAmB,KACnB,CAAC,uBAAuB,IAAI,KAAK,KAAK,EAAE,SAAS;AACjD,2BAAqB,IAAI,IAAI,KAAK,KAAK;AAAA,IAC3C;AAAA,EACJ,CAAC;AAID,uBAAqB,QAAQ,SAAU,cAAc;AAGjD,2BAAuB,uBAAuB,YAAY,CAAC,EAAE,gBAAgB,QAAQ,SAAU,mBAAmB;AAC9G,2BAAqB,IAAI,iBAAiB;AAAA,IAC9C,CAAC;AAAA,EACL,CAAC;AACD,MAAI,wBAAwB,SAAU,cAAc;AAChD,WAAO,CAAC;AAAA;AAAA;AAAA,KAIP,CAAC,qBAAqB,IAAI,YAAY,KACnC,uBAAuB,YAAY,EAAE;AAAA,EAC7C;AACA,MAAI,eAAe;AAAA,IACf,OAAO,SAAU,MAAM;AACnB,UAAI,sBAAsB,KAAK,KAAK,KAAK,GAAG;AACxC,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AACA,SAAO,iBAAiB,MAAM,6BAA6B;AAAA;AAAA;AAAA,IAGvD,gBAAgB;AAAA;AAAA,IAEhB,oBAAoB;AAAA,IACpB,qBAAqB;AAAA,MACjB,OAAO,SAAU,MAAM;AAGnB,YAAI,KAAK,qBAAqB;AAC1B,cAAI,sBAAsB;AAAA;AAAA,YAE1B,wBAAwB,KAAK,QAAQ,KAAK,KAAK,KAAK;AAAA,UAAC,EAAE;AAYvD,cAAI,oBAAoB,OAAO,KAAK,oBAAoB,QAAQ;AAC5D,mBAAO,SAAS,SAAS,CAAC,GAAG,IAAI,GAAG,EAAE,qBAAqB,KAAK,oBAAoB,OAAO,SAAU,QAAQ;AACrG,qBAAO,oBAAoB,IAAI,OAAO,SAAS,KAAK,KAAK;AAAA,YAC7D,CAAC,EAAE,CAAC;AAAA,UACZ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,CAAC,CAAC;AACN;AACO,WAAI,wBAAwB,OAAO,OAAO,SAAU,KAAK;AAC5D,SAAO,MAAM,KAAK;AAAA,IACd,cAAc;AAAA,MACV,OAAO,SAAU,MAAM,MAAM,QAAQ;AAEjC,YAAI,UACA,OAAO,SACH,KAAK,sBAAsB;AAC/B;AAAA,QACJ;AAEA,YAAI,aAAa,KAAK;AACtB,YAAI,CAAC,YAAY;AACb;AAAA,QACJ;AAGA,YAAI,OAAO,WAAW,KAAK,SAAU,WAAW;AAC5C,iBAAQ,QAAQ,SAAS,MACpB,UAAU,KAAK,UAAU,gBACtB,UAAU,KAAK,MAAM,YAAY,MAAM,CAAC,MAAM;AAAA,QAC1D,CAAC;AACD,YAAI,MAAM;AACN;AAAA,QACJ;AAGA,YAAI,QAAQ;AACZ,YAAI,QAAQ,KAAK,KACb,MAAM,cACN,MAAM,WAAW,KAAK,SAAU,GAAG;AAAE,iBAAO,EAAE,KAAK,UAAU;AAAA,QAAU,CAAC,GAAG;AAC3E;AAAA,QACJ;AAEA,eAAO,SAAS,SAAS,CAAC,GAAG,IAAI,GAAG,EAAE,YAAY,cAAc,cAAc,CAAC,GAAG,YAAY,IAAI,GAAG,CAAC,cAAc,GAAG,KAAK,EAAE,CAAC;AAAA,MACnI;AAAA,IACJ;AAAA,EACJ,CAAC;AACL,GAAG;AAAA,EACC,OAAO,SAAU,OAAO;AACpB,WAAO,UAAU;AAAA,EACrB;AACJ,CAAC;AACD,IAAI,yBAAyB;AAAA,EACzB,MAAM,SAAU,WAAW;AACvB,QAAI,aAAa,UAAU,KAAK,UAAU;AAC1C,QAAI,YAAY;AACZ,UAAI,CAAC,UAAU,aACX,CAAC,UAAU,UAAU,KAAK,SAAU,KAAK;AAAE,eAAO,IAAI,KAAK,UAAU;AAAA,MAAO,CAAC,GAAG;AAChF,mBAAW,YAAY,SAAS,UAAU,KAAK,EAAE;AAAA,MACrD;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AACJ;AACO,gBAAS,sCAAsC,KAAK;AACvD,SAAO,6BAA6B,CAAC,sBAAsB,GAAG,cAAc,GAAG,CAAC;AACpF;AACA,SAAS,4BAA4B,YAAY,cAAc,aAAa;AACxE,MAAI,gBAAgB,QAAQ;AAAE,kBAAc;AAAA,EAAM;AAClD,SAAQ,CAAC,CAAC,gBACN,aAAa,cACb,aAAa,WAAW,KAAK,SAAU,WAAW;AAC9C,WAAO,yBAAyB,YAAY,WAAW,WAAW;AAAA,EACtE,CAAC;AACT;AACA,SAAS,yBAAyB,YAAY,WAAW,aAAa;AAClE,MAAI,gBAAgB,QAAQ;AAAE,kBAAc;AAAA,EAAM;AAClD,MAAI,CAAC,QAAQ,SAAS,GAAG;AACrB,WAAO;AAAA,EACX;AACA,MAAI,CAAC,UAAU,YAAY;AACvB,WAAO;AAAA,EACX;AACA,SAAQ,UAAU,WAAW,KAAK,oBAAoB,UAAU,CAAC,KAC5D,eACG,4BAA4B,YAAY,UAAU,cAAc,WAAW;AACvF;AACA,SAAS,mBAAmB,QAAQ;AAChC,SAAO,SAAS,gBAAgB,UAAU;AACtC,WAAO,OAAO,KAAK,SAAU,SAAS;AAClC,aAAO,SAAS,SACZ,SAAS,MAAM,SAAS,KAAK,YAC7B,SAAS,MAAM,SACd,QAAQ,SAAS,SAAS,MAAM,KAAK,SACjC,QAAQ,QAAQ,QAAQ,KAAK,QAAQ;AAAA,IAClD,CAAC;AAAA,EACL;AACJ;AACO,gBAAS,4BAA4B,QAAQ,KAAK;AACrD,MAAI,aAAa,mBAAmB,MAAM;AAC1C,SAAO,iBAAiB,MAAM,KAAK;AAAA,IAC/B,qBAAqB;AAAA,MACjB,OAAO,SAAU,MAAM;AACnB,eAAO,SAAS,SAAS,CAAC,GAAG,IAAI,GAAG;AAAA;AAAA,UAEhC,qBAAqB,KAAK,sBACtB,KAAK,oBAAoB,OAAO,SAAU,QAAQ;AAC9C,mBAAO,CAAC,OAAO,KAAK,SAAU,KAAK;AAAE,qBAAO,IAAI,SAAS,OAAO,SAAS,KAAK;AAAA,YAAO,CAAC;AAAA,UAC1F,CAAC,IACC,CAAC;AAAA,QAAE,CAAC;AAAA,MAClB;AAAA,IACJ;AAAA,IACA,OAAO;AAAA,MACH,OAAO,SAAU,MAAM;AAGnB,YAAI,oBAAoB,OAAO,KAAK,SAAU,WAAW;AAAE,iBAAO,UAAU;AAAA,QAAQ,CAAC;AACrF,YAAI,mBAAmB;AACnB,cAAI,kBAAkB;AACtB,cAAI,KAAK,WAAW;AAChB,iBAAK,UAAU,QAAQ,SAAU,KAAK;AAClC,kBAAI,WAAW,GAAG,GAAG;AACjB,mCAAmB;AAAA,cACvB;AAAA,YACJ,CAAC;AAAA,UACL;AACA,cAAI,oBAAoB,GAAG;AACvB,mBAAO;AAAA,UACX;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,IACA,UAAU;AAAA,MACN,OAAO,SAAU,MAAM;AAEnB,YAAI,WAAW,IAAI,GAAG;AAClB,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,CAAC,CAAC;AACN;AACO,gBAAS,iCAAiC,QAAQ,KAAK;AAC1D,WAAS,MAAM,MAAM;AACjB,QAAI,OAAO,KAAK,SAAU,KAAK;AAAE,aAAO,IAAI,SAAS,KAAK,KAAK;AAAA,IAAO,CAAC,GAAG;AACtE,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO,iBAAiB,MAAM,KAAK;AAAA,IAC/B,gBAAgB,EAAE,MAAa;AAAA,IAC/B,oBAAoB,EAAE,MAAa;AAAA,EACvC,CAAC,CAAC;AACN;AAIO,gBAAS,2BAA2B,UAAU;AACjD,MAAI,aAAa,kBAAkB,QAAQ;AAC3C,MAAI,sBAAsB,WAAW;AACrC,MAAI,wBAAwB,SAAS;AAEjC,WAAO;AAAA,EACX;AAEA,MAAI,cAAc,MAAM,UAAU;AAAA,IAC9B,qBAAqB;AAAA,MACjB,OAAO,SAAU,MAAM;AACnB,eAAO,SAAS,SAAS,CAAC,GAAG,IAAI,GAAG,EAAE,WAAW,QAAQ,CAAC;AAAA,MAC9D;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,SAAO;AACX;AAEO,gBAAS,6BAA6B,UAAU;AACnD,gBAAc,QAAQ;AACtB,MAAI,cAAc,6BAA6B;AAAA,IAC3C;AAAA,MACI,MAAM,SAAU,WAAW;AAAE,eAAO,UAAU,KAAK,UAAU;AAAA,MAAU;AAAA,MACvE,QAAQ;AAAA,IACZ;AAAA,EACJ,GAAG,QAAQ;AACX,SAAO;AACX;\",\n  \"names\": []\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1713269989232,
      "end": 1713269989232,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1713269989232,
      "end": 1713269989232,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1713269989232,
      "end": 1713269989232,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1713269989232,
      "end": 1713269989232,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1713269989232,
      "end": 1713269989233,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1713269989233,
      "end": 1713269989233,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1713269989233,
      "end": 1713269989234,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1713269989234,
      "end": 1713269989234,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1713269989234,
      "end": 1713269989234,
      "order": "normal"
    }
  ]
}
