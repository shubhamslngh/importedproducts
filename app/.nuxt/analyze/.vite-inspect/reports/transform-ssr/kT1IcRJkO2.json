{
  "resolvedId": "/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/cache/inmemory/readFromStore.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { Kind } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { isField, resultKeyNameFromField, isReference, makeReference, shouldInclude, addTypenameToDocument, getDefaultValues, getMainDefinition, getQueryDefinition, getFragmentFromSelection, maybeDeepFreeze, mergeDeepArray, DeepMerger, isNonNullObject, canUseWeakMap, compact, canonicalStringify, cacheSizes, } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching, } from \"./entityStore.js\";\nimport { isArray, extractFragmentContext, getTypenameFromStoreObject, shouldCanonizeResults, } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\nfunction execSelectionSetKeyArgs(options) {\n    return [\n        options.selectionSet,\n        options.objectOrReference,\n        options.context,\n        // We split out this property so we can pass different values\n        // independently without modifying options.context itself.\n        options.context.canonizeResults,\n    ];\n}\nvar StoreReader = /** @class */ (function () {\n    function StoreReader(config) {\n        var _this = this;\n        this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n        this.config = compact(config, {\n            addTypename: config.addTypename !== false,\n            canonizeResults: shouldCanonizeResults(config),\n        });\n        this.canon = config.canon || new ObjectCanon();\n        // memoized functions in this class will be \"garbage-collected\"\n        // by recreating the whole `StoreReader` in\n        // `InMemoryCache.resetResultsCache`\n        // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\n        this.executeSelectionSet = wrap(function (options) {\n            var _a;\n            var canonizeResults = options.context.canonizeResults;\n            var peekArgs = execSelectionSetKeyArgs(options);\n            // Negate this boolean option so we can find out if we've already read\n            // this result using the other boolean value.\n            peekArgs[3] = !canonizeResults;\n            var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n            if (other) {\n                if (canonizeResults) {\n                    return __assign(__assign({}, other), { \n                        // If we previously read this result without canonizing it, we can\n                        // reuse that result simply by canonizing it now.\n                        result: _this.canon.admit(other.result) });\n                }\n                // If we previously read this result with canonization enabled, we can\n                // return that canonized result as-is.\n                return other;\n            }\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            // Finally, if we didn't find any useful previous results, run the real\n            // execSelectionSetImpl method with the given options.\n            return _this.execSelectionSetImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize ||\n                cacheSizes[\"inMemoryCache.executeSelectionSet\"] ||\n                50000 /* defaultCacheSizes[\"inMemoryCache.executeSelectionSet\"] */,\n            keyArgs: execSelectionSetKeyArgs,\n            // Note that the parameters of makeCacheKey are determined by the\n            // array returned by keyArgs.\n            makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n                }\n            },\n        });\n        this.executeSubSelectedArray = wrap(function (options) {\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            return _this.execSubSelectedArrayImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize ||\n                cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] ||\n                10000 /* defaultCacheSizes[\"inMemoryCache.executeSubSelectedArray\"] */,\n            makeCacheKey: function (_a) {\n                var field = _a.field, array = _a.array, context = _a.context;\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(field, array, context.varString);\n                }\n            },\n        });\n    }\n    StoreReader.prototype.resetCanon = function () {\n        this.canon = new ObjectCanon();\n    };\n    /**\n     * Given a store and a query, return as much of the result as possible and\n     * identify if any data was missing from the store.\n     */\n    StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n        var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? \"ROOT_QUERY\" : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n        var policies = this.config.cache.policies;\n        variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n        var rootRef = makeReference(rootId);\n        var execResult = this.executeSelectionSet({\n            selectionSet: getMainDefinition(query).selectionSet,\n            objectOrReference: rootRef,\n            enclosingRef: rootRef,\n            context: __assign({ store: store, query: query, policies: policies, variables: variables, varString: canonicalStringify(variables), canonizeResults: canonizeResults }, extractFragmentContext(query, this.config.fragments)),\n        });\n        var missing;\n        if (execResult.missing) {\n            // For backwards compatibility we still report an array of\n            // MissingFieldError objects, even though there will only ever be at most\n            // one of them, now that all missing field error messages are grouped\n            // together in the execResult.missing tree.\n            missing = [\n                new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables),\n            ];\n            if (!returnPartialData) {\n                throw missing[0];\n            }\n        }\n        return {\n            result: execResult.result,\n            complete: !missing,\n            missing: missing,\n        };\n    };\n    StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n        if (supportsResultCaching(context.store) &&\n            this.knownResults.get(result) === selectionSet) {\n            var latest = this.executeSelectionSet.peek(selectionSet, parent, context, \n            // If result is canonical, then it could only have been previously\n            // cached by the canonizing version of executeSelectionSet, so we can\n            // avoid checking both possibilities here.\n            this.canon.isKnown(result));\n            if (latest && result === latest.result) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // Uncached version of executeSelectionSet.\n    StoreReader.prototype.execSelectionSetImpl = function (_a) {\n        var _this = this;\n        var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;\n        if (isReference(objectOrReference) &&\n            !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n            !context.store.has(objectOrReference.__ref)) {\n            return {\n                result: this.canon.empty,\n                missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\"),\n            };\n        }\n        var variables = context.variables, policies = context.policies, store = context.store;\n        var typename = store.getFieldValue(objectOrReference, \"__typename\");\n        var objectsToMerge = [];\n        var missing;\n        var missingMerger = new DeepMerger();\n        if (this.config.addTypename &&\n            typeof typename === \"string\" &&\n            !policies.rootIdsByTypename[typename]) {\n            // Ensure we always include a default value for the __typename\n            // field, if we have one, and this.config.addTypename is true. Note\n            // that this field can be overridden by other merged objects.\n            objectsToMerge.push({ __typename: typename });\n        }\n        function handleMissing(result, resultName) {\n            var _a;\n            if (result.missing) {\n                missing = missingMerger.merge(missing, (_a = {},\n                    _a[resultName] = result.missing,\n                    _a));\n            }\n            return result.result;\n        }\n        var workSet = new Set(selectionSet.selections);\n        workSet.forEach(function (selection) {\n            var _a, _b;\n            // Omit fields with directives @skip(if: <truthy value>) or\n            // @include(if: <falsy value>).\n            if (!shouldInclude(selection, variables))\n                return;\n            if (isField(selection)) {\n                var fieldValue = policies.readField({\n                    fieldName: selection.name.value,\n                    field: selection,\n                    variables: context.variables,\n                    from: objectOrReference,\n                }, context);\n                var resultName = resultKeyNameFromField(selection);\n                if (fieldValue === void 0) {\n                    if (!addTypenameToDocument.added(selection)) {\n                        missing = missingMerger.merge(missing, (_a = {},\n                            _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat(isReference(objectOrReference) ?\n                                objectOrReference.__ref + \" object\"\n                                : \"object \" + JSON.stringify(objectOrReference, null, 2)),\n                            _a));\n                    }\n                }\n                else if (isArray(fieldValue)) {\n                    fieldValue = handleMissing(_this.executeSubSelectedArray({\n                        field: selection,\n                        array: fieldValue,\n                        enclosingRef: enclosingRef,\n                        context: context,\n                    }), resultName);\n                }\n                else if (!selection.selectionSet) {\n                    // If the field does not have a selection set, then we handle it\n                    // as a scalar value. To keep this.canon from canonicalizing\n                    // this value, we use this.canon.pass to wrap fieldValue in a\n                    // Pass object that this.canon.admit will later unwrap as-is.\n                    if (context.canonizeResults) {\n                        fieldValue = _this.canon.pass(fieldValue);\n                    }\n                }\n                else if (fieldValue != null) {\n                    // In this case, because we know the field has a selection set,\n                    // it must be trying to query a GraphQLObjectType, which is why\n                    // fieldValue must be != null.\n                    fieldValue = handleMissing(_this.executeSelectionSet({\n                        selectionSet: selection.selectionSet,\n                        objectOrReference: fieldValue,\n                        enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n                        context: context,\n                    }), resultName);\n                }\n                if (fieldValue !== void 0) {\n                    objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n                }\n            }\n            else {\n                var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n                if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n                    throw newInvariantError(9, selection.name.value);\n                }\n                if (fragment && policies.fragmentMatches(fragment, typename)) {\n                    fragment.selectionSet.selections.forEach(workSet.add, workSet);\n                }\n            }\n        });\n        var result = mergeDeepArray(objectsToMerge);\n        var finalResult = { result: result, missing: missing };\n        var frozen = context.canonizeResults ?\n            this.canon.admit(finalResult)\n            // Since this.canon is normally responsible for freezing results (only in\n            // development), freeze them manually if canonization is disabled.\n            : maybeDeepFreeze(finalResult);\n        // Store this result with its selection set so that we can quickly\n        // recognize it again in the StoreReader#isFresh method.\n        if (frozen.result) {\n            this.knownResults.set(frozen.result, selectionSet);\n        }\n        return frozen;\n    };\n    // Uncached version of executeSubSelectedArray.\n    StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n        var _this = this;\n        var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;\n        var missing;\n        var missingMerger = new DeepMerger();\n        function handleMissing(childResult, i) {\n            var _a;\n            if (childResult.missing) {\n                missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n            }\n            return childResult.result;\n        }\n        if (field.selectionSet) {\n            array = array.filter(context.store.canRead);\n        }\n        array = array.map(function (item, i) {\n            // null value in array\n            if (item === null) {\n                return null;\n            }\n            // This is a nested array, recurse\n            if (isArray(item)) {\n                return handleMissing(_this.executeSubSelectedArray({\n                    field: field,\n                    array: item,\n                    enclosingRef: enclosingRef,\n                    context: context,\n                }), i);\n            }\n            // This is an object, run the selection set on it\n            if (field.selectionSet) {\n                return handleMissing(_this.executeSelectionSet({\n                    selectionSet: field.selectionSet,\n                    objectOrReference: item,\n                    enclosingRef: isReference(item) ? item : enclosingRef,\n                    context: context,\n                }), i);\n            }\n            if (globalThis.__DEV__ !== false) {\n                assertSelectionSetForIdValue(context.store, field, item);\n            }\n            return item;\n        });\n        return {\n            result: context.canonizeResults ? this.canon.admit(array) : array,\n            missing: missing,\n        };\n    };\n    return StoreReader;\n}());\nexport { StoreReader };\nfunction firstMissing(tree) {\n    try {\n        JSON.stringify(tree, function (_, value) {\n            if (typeof value === \"string\")\n                throw value;\n            return value;\n        });\n    }\n    catch (result) {\n        return result;\n    }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n    if (!field.selectionSet) {\n        var workSet_1 = new Set([fieldValue]);\n        workSet_1.forEach(function (value) {\n            if (isNonNullObject(value)) {\n                invariant(\n                    !isReference(value),\n                    10,\n                    getTypenameFromStoreObject(store, value),\n                    field.name.value\n                );\n                Object.values(value).forEach(workSet_1.add, workSet_1);\n            }\n        });\n    }\n}\n//# sourceMappingURL=readFromStore.js.map",
      "start": 1713269989318,
      "end": 1713269989325,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "graphql",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1713269989325,
      "end": 1713269989325,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { __assign } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { Kind } from \"graphql\";\nimport { wrap } from \"optimism\";\nimport { isField, resultKeyNameFromField, isReference, makeReference, shouldInclude, addTypenameToDocument, getDefaultValues, getMainDefinition, getQueryDefinition, getFragmentFromSelection, maybeDeepFreeze, mergeDeepArray, DeepMerger, isNonNullObject, canUseWeakMap, compact, canonicalStringify, cacheSizes } from \"../../utilities/index.js\";\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching } from \"./entityStore.js\";\nimport { isArray, extractFragmentContext, getTypenameFromStoreObject, shouldCanonizeResults } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { ObjectCanon } from \"./object-canon.js\";\nfunction execSelectionSetKeyArgs(options) {\n  return [\n    options.selectionSet,\n    options.objectOrReference,\n    options.context,\n    // We split out this property so we can pass different values\n    // independently without modifying options.context itself.\n    options.context.canonizeResults\n  ];\n}\nvar StoreReader = (\n  /** @class */\n  function() {\n    function StoreReader2(config) {\n      var _this = this;\n      this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\n      this.config = compact(config, {\n        addTypename: config.addTypename !== false,\n        canonizeResults: shouldCanonizeResults(config)\n      });\n      this.canon = config.canon || new ObjectCanon();\n      this.executeSelectionSet = wrap(function(options) {\n        var _a;\n        var canonizeResults = options.context.canonizeResults;\n        var peekArgs = execSelectionSetKeyArgs(options);\n        peekArgs[3] = !canonizeResults;\n        var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n        if (other) {\n          if (canonizeResults) {\n            return __assign(__assign({}, other), {\n              // If we previously read this result without canonizing it, we can\n              // reuse that result simply by canonizing it now.\n              result: _this.canon.admit(other.result)\n            });\n          }\n          return other;\n        }\n        maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n        return _this.execSelectionSetImpl(options);\n      }, {\n        max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.executeSelectionSet\"] || 5e4,\n        keyArgs: execSelectionSetKeyArgs,\n        // Note that the parameters of makeCacheKey are determined by the\n        // array returned by keyArgs.\n        makeCacheKey: function(selectionSet, parent, context, canonizeResults) {\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n          }\n        }\n      });\n      this.executeSubSelectedArray = wrap(function(options) {\n        maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n        return _this.execSubSelectedArrayImpl(options);\n      }, {\n        max: this.config.resultCacheMaxSize || cacheSizes[\"inMemoryCache.executeSubSelectedArray\"] || 1e4,\n        makeCacheKey: function(_a) {\n          var field = _a.field, array = _a.array, context = _a.context;\n          if (supportsResultCaching(context.store)) {\n            return context.store.makeCacheKey(field, array, context.varString);\n          }\n        }\n      });\n    }\n    StoreReader2.prototype.resetCanon = function() {\n      this.canon = new ObjectCanon();\n    };\n    StoreReader2.prototype.diffQueryAgainstStore = function(_a) {\n      var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? \"ROOT_QUERY\" : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n      var policies = this.config.cache.policies;\n      variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n      var rootRef = makeReference(rootId);\n      var execResult = this.executeSelectionSet({\n        selectionSet: getMainDefinition(query).selectionSet,\n        objectOrReference: rootRef,\n        enclosingRef: rootRef,\n        context: __assign({ store, query, policies, variables, varString: canonicalStringify(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))\n      });\n      var missing;\n      if (execResult.missing) {\n        missing = [\n          new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)\n        ];\n        if (!returnPartialData) {\n          throw missing[0];\n        }\n      }\n      return {\n        result: execResult.result,\n        complete: !missing,\n        missing\n      };\n    };\n    StoreReader2.prototype.isFresh = function(result, parent, selectionSet, context) {\n      if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {\n        var latest = this.executeSelectionSet.peek(\n          selectionSet,\n          parent,\n          context,\n          // If result is canonical, then it could only have been previously\n          // cached by the canonizing version of executeSelectionSet, so we can\n          // avoid checking both possibilities here.\n          this.canon.isKnown(result)\n        );\n        if (latest && result === latest.result) {\n          return true;\n        }\n      }\n      return false;\n    };\n    StoreReader2.prototype.execSelectionSetImpl = function(_a) {\n      var _this = this;\n      var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;\n      if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n        return {\n          result: this.canon.empty,\n          missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\")\n        };\n      }\n      var variables = context.variables, policies = context.policies, store = context.store;\n      var typename = store.getFieldValue(objectOrReference, \"__typename\");\n      var objectsToMerge = [];\n      var missing;\n      var missingMerger = new DeepMerger();\n      if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n        objectsToMerge.push({ __typename: typename });\n      }\n      function handleMissing(result2, resultName) {\n        var _a2;\n        if (result2.missing) {\n          missing = missingMerger.merge(missing, (_a2 = {}, _a2[resultName] = result2.missing, _a2));\n        }\n        return result2.result;\n      }\n      var workSet = new Set(selectionSet.selections);\n      workSet.forEach(function(selection) {\n        var _a2, _b;\n        if (!shouldInclude(selection, variables))\n          return;\n        if (isField(selection)) {\n          var fieldValue = policies.readField({\n            fieldName: selection.name.value,\n            field: selection,\n            variables: context.variables,\n            from: objectOrReference\n          }, context);\n          var resultName = resultKeyNameFromField(selection);\n          if (fieldValue === void 0) {\n            if (!addTypenameToDocument.added(selection)) {\n              missing = missingMerger.merge(missing, (_a2 = {}, _a2[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat(isReference(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2)), _a2));\n            }\n          } else if (isArray(fieldValue)) {\n            fieldValue = handleMissing(_this.executeSubSelectedArray({\n              field: selection,\n              array: fieldValue,\n              enclosingRef,\n              context\n            }), resultName);\n          } else if (!selection.selectionSet) {\n            if (context.canonizeResults) {\n              fieldValue = _this.canon.pass(fieldValue);\n            }\n          } else if (fieldValue != null) {\n            fieldValue = handleMissing(_this.executeSelectionSet({\n              selectionSet: selection.selectionSet,\n              objectOrReference: fieldValue,\n              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\n              context\n            }), resultName);\n          }\n          if (fieldValue !== void 0) {\n            objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n          }\n        } else {\n          var fragment = getFragmentFromSelection(selection, context.lookupFragment);\n          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\n            throw newInvariantError(9, selection.name.value);\n          }\n          if (fragment && policies.fragmentMatches(fragment, typename)) {\n            fragment.selectionSet.selections.forEach(workSet.add, workSet);\n          }\n        }\n      });\n      var result = mergeDeepArray(objectsToMerge);\n      var finalResult = { result, missing };\n      var frozen = context.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);\n      if (frozen.result) {\n        this.knownResults.set(frozen.result, selectionSet);\n      }\n      return frozen;\n    };\n    StoreReader2.prototype.execSubSelectedArrayImpl = function(_a) {\n      var _this = this;\n      var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;\n      var missing;\n      var missingMerger = new DeepMerger();\n      function handleMissing(childResult, i) {\n        var _a2;\n        if (childResult.missing) {\n          missing = missingMerger.merge(missing, (_a2 = {}, _a2[i] = childResult.missing, _a2));\n        }\n        return childResult.result;\n      }\n      if (field.selectionSet) {\n        array = array.filter(context.store.canRead);\n      }\n      array = array.map(function(item, i) {\n        if (item === null) {\n          return null;\n        }\n        if (isArray(item)) {\n          return handleMissing(_this.executeSubSelectedArray({\n            field,\n            array: item,\n            enclosingRef,\n            context\n          }), i);\n        }\n        if (field.selectionSet) {\n          return handleMissing(_this.executeSelectionSet({\n            selectionSet: field.selectionSet,\n            objectOrReference: item,\n            enclosingRef: isReference(item) ? item : enclosingRef,\n            context\n          }), i);\n        }\n        if (globalThis.__DEV__ !== false) {\n          assertSelectionSetForIdValue(context.store, field, item);\n        }\n        return item;\n      });\n      return {\n        result: context.canonizeResults ? this.canon.admit(array) : array,\n        missing\n      };\n    };\n    return StoreReader2;\n  }()\n);\nexport { StoreReader };\nfunction firstMissing(tree) {\n  try {\n    JSON.stringify(tree, function(_, value) {\n      if (typeof value === \"string\")\n        throw value;\n      return value;\n    });\n  } catch (result) {\n    return result;\n  }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);\n    workSet_1.forEach(function(value) {\n      if (isNonNullObject(value)) {\n        invariant(\n          !isReference(value),\n          10,\n          getTypenameFromStoreObject(store, value),\n          field.name.value\n        );\n        Object.values(value).forEach(workSet_1.add, workSet_1);\n      }\n    });\n  }\n}\n",
      "start": 1713269989325,
      "end": 1713269989583,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/cache/inmemory/readFromStore.js\"],\n  \"sourcesContent\": [\"import { __assign } from \\\"tslib\\\";\\nimport { invariant, newInvariantError } from \\\"../../utilities/globals/index.js\\\";\\nimport { Kind } from \\\"graphql\\\";\\nimport { wrap } from \\\"optimism\\\";\\nimport { isField, resultKeyNameFromField, isReference, makeReference, shouldInclude, addTypenameToDocument, getDefaultValues, getMainDefinition, getQueryDefinition, getFragmentFromSelection, maybeDeepFreeze, mergeDeepArray, DeepMerger, isNonNullObject, canUseWeakMap, compact, canonicalStringify, cacheSizes, } from \\\"../../utilities/index.js\\\";\\nimport { maybeDependOnExistenceOfEntity, supportsResultCaching, } from \\\"./entityStore.js\\\";\\nimport { isArray, extractFragmentContext, getTypenameFromStoreObject, shouldCanonizeResults, } from \\\"./helpers.js\\\";\\nimport { MissingFieldError } from \\\"../core/types/common.js\\\";\\nimport { ObjectCanon } from \\\"./object-canon.js\\\";\\nfunction execSelectionSetKeyArgs(options) {\\n    return [\\n        options.selectionSet,\\n        options.objectOrReference,\\n        options.context,\\n        // We split out this property so we can pass different values\\n        // independently without modifying options.context itself.\\n        options.context.canonizeResults,\\n    ];\\n}\\nvar StoreReader = /** @class */ (function () {\\n    function StoreReader(config) {\\n        var _this = this;\\n        this.knownResults = new (canUseWeakMap ? WeakMap : Map)();\\n        this.config = compact(config, {\\n            addTypename: config.addTypename !== false,\\n            canonizeResults: shouldCanonizeResults(config),\\n        });\\n        this.canon = config.canon || new ObjectCanon();\\n        // memoized functions in this class will be \\\"garbage-collected\\\"\\n        // by recreating the whole `StoreReader` in\\n        // `InMemoryCache.resetResultsCache`\\n        // (triggered from `InMemoryCache.gc` with `resetResultCache: true`)\\n        this.executeSelectionSet = wrap(function (options) {\\n            var _a;\\n            var canonizeResults = options.context.canonizeResults;\\n            var peekArgs = execSelectionSetKeyArgs(options);\\n            // Negate this boolean option so we can find out if we've already read\\n            // this result using the other boolean value.\\n            peekArgs[3] = !canonizeResults;\\n            var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\\n            if (other) {\\n                if (canonizeResults) {\\n                    return __assign(__assign({}, other), { \\n                        // If we previously read this result without canonizing it, we can\\n                        // reuse that result simply by canonizing it now.\\n                        result: _this.canon.admit(other.result) });\\n                }\\n                // If we previously read this result with canonization enabled, we can\\n                // return that canonized result as-is.\\n                return other;\\n            }\\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\\n            // Finally, if we didn't find any useful previous results, run the real\\n            // execSelectionSetImpl method with the given options.\\n            return _this.execSelectionSetImpl(options);\\n        }, {\\n            max: this.config.resultCacheMaxSize ||\\n                cacheSizes[\\\"inMemoryCache.executeSelectionSet\\\"] ||\\n                50000 /* defaultCacheSizes[\\\"inMemoryCache.executeSelectionSet\\\"] */,\\n            keyArgs: execSelectionSetKeyArgs,\\n            // Note that the parameters of makeCacheKey are determined by the\\n            // array returned by keyArgs.\\n            makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\\n                if (supportsResultCaching(context.store)) {\\n                    return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\\n                }\\n            },\\n        });\\n        this.executeSubSelectedArray = wrap(function (options) {\\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\\n            return _this.execSubSelectedArrayImpl(options);\\n        }, {\\n            max: this.config.resultCacheMaxSize ||\\n                cacheSizes[\\\"inMemoryCache.executeSubSelectedArray\\\"] ||\\n                10000 /* defaultCacheSizes[\\\"inMemoryCache.executeSubSelectedArray\\\"] */,\\n            makeCacheKey: function (_a) {\\n                var field = _a.field, array = _a.array, context = _a.context;\\n                if (supportsResultCaching(context.store)) {\\n                    return context.store.makeCacheKey(field, array, context.varString);\\n                }\\n            },\\n        });\\n    }\\n    StoreReader.prototype.resetCanon = function () {\\n        this.canon = new ObjectCanon();\\n    };\\n    /**\\n     * Given a store and a query, return as much of the result as possible and\\n     * identify if any data was missing from the store.\\n     */\\n    StoreReader.prototype.diffQueryAgainstStore = function (_a) {\\n        var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? \\\"ROOT_QUERY\\\" : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\\n        var policies = this.config.cache.policies;\\n        variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\\n        var rootRef = makeReference(rootId);\\n        var execResult = this.executeSelectionSet({\\n            selectionSet: getMainDefinition(query).selectionSet,\\n            objectOrReference: rootRef,\\n            enclosingRef: rootRef,\\n            context: __assign({ store: store, query: query, policies: policies, variables: variables, varString: canonicalStringify(variables), canonizeResults: canonizeResults }, extractFragmentContext(query, this.config.fragments)),\\n        });\\n        var missing;\\n        if (execResult.missing) {\\n            // For backwards compatibility we still report an array of\\n            // MissingFieldError objects, even though there will only ever be at most\\n            // one of them, now that all missing field error messages are grouped\\n            // together in the execResult.missing tree.\\n            missing = [\\n                new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables),\\n            ];\\n            if (!returnPartialData) {\\n                throw missing[0];\\n            }\\n        }\\n        return {\\n            result: execResult.result,\\n            complete: !missing,\\n            missing: missing,\\n        };\\n    };\\n    StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\\n        if (supportsResultCaching(context.store) &&\\n            this.knownResults.get(result) === selectionSet) {\\n            var latest = this.executeSelectionSet.peek(selectionSet, parent, context, \\n            // If result is canonical, then it could only have been previously\\n            // cached by the canonizing version of executeSelectionSet, so we can\\n            // avoid checking both possibilities here.\\n            this.canon.isKnown(result));\\n            if (latest && result === latest.result) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    };\\n    // Uncached version of executeSelectionSet.\\n    StoreReader.prototype.execSelectionSetImpl = function (_a) {\\n        var _this = this;\\n        var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;\\n        if (isReference(objectOrReference) &&\\n            !context.policies.rootTypenamesById[objectOrReference.__ref] &&\\n            !context.store.has(objectOrReference.__ref)) {\\n            return {\\n                result: this.canon.empty,\\n                missing: \\\"Dangling reference to missing \\\".concat(objectOrReference.__ref, \\\" object\\\"),\\n            };\\n        }\\n        var variables = context.variables, policies = context.policies, store = context.store;\\n        var typename = store.getFieldValue(objectOrReference, \\\"__typename\\\");\\n        var objectsToMerge = [];\\n        var missing;\\n        var missingMerger = new DeepMerger();\\n        if (this.config.addTypename &&\\n            typeof typename === \\\"string\\\" &&\\n            !policies.rootIdsByTypename[typename]) {\\n            // Ensure we always include a default value for the __typename\\n            // field, if we have one, and this.config.addTypename is true. Note\\n            // that this field can be overridden by other merged objects.\\n            objectsToMerge.push({ __typename: typename });\\n        }\\n        function handleMissing(result, resultName) {\\n            var _a;\\n            if (result.missing) {\\n                missing = missingMerger.merge(missing, (_a = {},\\n                    _a[resultName] = result.missing,\\n                    _a));\\n            }\\n            return result.result;\\n        }\\n        var workSet = new Set(selectionSet.selections);\\n        workSet.forEach(function (selection) {\\n            var _a, _b;\\n            // Omit fields with directives @skip(if: <truthy value>) or\\n            // @include(if: <falsy value>).\\n            if (!shouldInclude(selection, variables))\\n                return;\\n            if (isField(selection)) {\\n                var fieldValue = policies.readField({\\n                    fieldName: selection.name.value,\\n                    field: selection,\\n                    variables: context.variables,\\n                    from: objectOrReference,\\n                }, context);\\n                var resultName = resultKeyNameFromField(selection);\\n                if (fieldValue === void 0) {\\n                    if (!addTypenameToDocument.added(selection)) {\\n                        missing = missingMerger.merge(missing, (_a = {},\\n                            _a[resultName] = \\\"Can't find field '\\\".concat(selection.name.value, \\\"' on \\\").concat(isReference(objectOrReference) ?\\n                                objectOrReference.__ref + \\\" object\\\"\\n                                : \\\"object \\\" + JSON.stringify(objectOrReference, null, 2)),\\n                            _a));\\n                    }\\n                }\\n                else if (isArray(fieldValue)) {\\n                    fieldValue = handleMissing(_this.executeSubSelectedArray({\\n                        field: selection,\\n                        array: fieldValue,\\n                        enclosingRef: enclosingRef,\\n                        context: context,\\n                    }), resultName);\\n                }\\n                else if (!selection.selectionSet) {\\n                    // If the field does not have a selection set, then we handle it\\n                    // as a scalar value. To keep this.canon from canonicalizing\\n                    // this value, we use this.canon.pass to wrap fieldValue in a\\n                    // Pass object that this.canon.admit will later unwrap as-is.\\n                    if (context.canonizeResults) {\\n                        fieldValue = _this.canon.pass(fieldValue);\\n                    }\\n                }\\n                else if (fieldValue != null) {\\n                    // In this case, because we know the field has a selection set,\\n                    // it must be trying to query a GraphQLObjectType, which is why\\n                    // fieldValue must be != null.\\n                    fieldValue = handleMissing(_this.executeSelectionSet({\\n                        selectionSet: selection.selectionSet,\\n                        objectOrReference: fieldValue,\\n                        enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,\\n                        context: context,\\n                    }), resultName);\\n                }\\n                if (fieldValue !== void 0) {\\n                    objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\\n                }\\n            }\\n            else {\\n                var fragment = getFragmentFromSelection(selection, context.lookupFragment);\\n                if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {\\n                    throw newInvariantError(9, selection.name.value);\\n                }\\n                if (fragment && policies.fragmentMatches(fragment, typename)) {\\n                    fragment.selectionSet.selections.forEach(workSet.add, workSet);\\n                }\\n            }\\n        });\\n        var result = mergeDeepArray(objectsToMerge);\\n        var finalResult = { result: result, missing: missing };\\n        var frozen = context.canonizeResults ?\\n            this.canon.admit(finalResult)\\n            // Since this.canon is normally responsible for freezing results (only in\\n            // development), freeze them manually if canonization is disabled.\\n            : maybeDeepFreeze(finalResult);\\n        // Store this result with its selection set so that we can quickly\\n        // recognize it again in the StoreReader#isFresh method.\\n        if (frozen.result) {\\n            this.knownResults.set(frozen.result, selectionSet);\\n        }\\n        return frozen;\\n    };\\n    // Uncached version of executeSubSelectedArray.\\n    StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\\n        var _this = this;\\n        var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;\\n        var missing;\\n        var missingMerger = new DeepMerger();\\n        function handleMissing(childResult, i) {\\n            var _a;\\n            if (childResult.missing) {\\n                missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\\n            }\\n            return childResult.result;\\n        }\\n        if (field.selectionSet) {\\n            array = array.filter(context.store.canRead);\\n        }\\n        array = array.map(function (item, i) {\\n            // null value in array\\n            if (item === null) {\\n                return null;\\n            }\\n            // This is a nested array, recurse\\n            if (isArray(item)) {\\n                return handleMissing(_this.executeSubSelectedArray({\\n                    field: field,\\n                    array: item,\\n                    enclosingRef: enclosingRef,\\n                    context: context,\\n                }), i);\\n            }\\n            // This is an object, run the selection set on it\\n            if (field.selectionSet) {\\n                return handleMissing(_this.executeSelectionSet({\\n                    selectionSet: field.selectionSet,\\n                    objectOrReference: item,\\n                    enclosingRef: isReference(item) ? item : enclosingRef,\\n                    context: context,\\n                }), i);\\n            }\\n            if (globalThis.__DEV__ !== false) {\\n                assertSelectionSetForIdValue(context.store, field, item);\\n            }\\n            return item;\\n        });\\n        return {\\n            result: context.canonizeResults ? this.canon.admit(array) : array,\\n            missing: missing,\\n        };\\n    };\\n    return StoreReader;\\n}());\\nexport { StoreReader };\\nfunction firstMissing(tree) {\\n    try {\\n        JSON.stringify(tree, function (_, value) {\\n            if (typeof value === \\\"string\\\")\\n                throw value;\\n            return value;\\n        });\\n    }\\n    catch (result) {\\n        return result;\\n    }\\n}\\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\\n    if (!field.selectionSet) {\\n        var workSet_1 = new Set([fieldValue]);\\n        workSet_1.forEach(function (value) {\\n            if (isNonNullObject(value)) {\\n                invariant(\\n                    !isReference(value),\\n                    10,\\n                    getTypenameFromStoreObject(store, value),\\n                    field.name.value\\n                );\\n                Object.values(value).forEach(workSet_1.add, workSet_1);\\n            }\\n        });\\n    }\\n}\\n//# sourceMappingURL=readFromStore.js.map\"],\n  \"mappings\": \"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\",\n  \"names\": [\"StoreReader\", \"result\", \"_a\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1713269989583,
      "end": 1713269989583,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1713269989583,
      "end": 1713269989583,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1713269989583,
      "end": 1713269989583,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1713269989583,
      "end": 1713269989583,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1713269989583,
      "end": 1713269989583,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1713269989583,
      "end": 1713269989583,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1713269989583,
      "end": 1713269989583,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713269989583,
      "end": 1713269989584,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713269989583,
      "end": 1713269989584,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713269989584,
      "end": 1713269989584,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713269989584,
      "end": 1713269989584,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713269989584,
      "end": 1713269989584,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713269989584,
      "end": 1713269989584,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713269989584,
      "end": 1713269989584,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713269989584,
      "end": 1713269989584,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1713269989584,
      "end": 1713269989584,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1713269989584,
      "end": 1713269989584,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1713269989584,
      "end": 1713269989584,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1713269989584,
      "end": 1713269989584,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1713269989584,
      "end": 1713269989584,
      "order": "normal"
    }
  ]
}
