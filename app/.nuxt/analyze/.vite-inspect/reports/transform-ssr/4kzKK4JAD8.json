{
  "resolvedId": "/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/core/LocalState.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\nimport { argumentsObjectFromField, buildQueryFromSelectionSet, createFragmentMap, getFragmentDefinitions, getMainDefinition, hasDirectives, isField, isInlineFragment, mergeDeep, mergeDeepArray, removeClientSetsFromDocument, resultKeyNameFromField, shouldInclude, } from \"../utilities/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\nvar LocalState = /** @class */ (function () {\n    function LocalState(_a) {\n        var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;\n        this.selectionsToResolveCache = new WeakMap();\n        this.cache = cache;\n        if (client) {\n            this.client = client;\n        }\n        if (resolvers) {\n            this.addResolvers(resolvers);\n        }\n        if (fragmentMatcher) {\n            this.setFragmentMatcher(fragmentMatcher);\n        }\n    }\n    LocalState.prototype.addResolvers = function (resolvers) {\n        var _this = this;\n        this.resolvers = this.resolvers || {};\n        if (Array.isArray(resolvers)) {\n            resolvers.forEach(function (resolverGroup) {\n                _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\n            });\n        }\n        else {\n            this.resolvers = mergeDeep(this.resolvers, resolvers);\n        }\n    };\n    LocalState.prototype.setResolvers = function (resolvers) {\n        this.resolvers = {};\n        this.addResolvers(resolvers);\n    };\n    LocalState.prototype.getResolvers = function () {\n        return this.resolvers || {};\n    };\n    // Run local client resolvers against the incoming query and remote data.\n    // Locally resolved field values are merged with the incoming remote data,\n    // and returned. Note that locally resolved fields will overwrite\n    // remote data using the same field name.\n    LocalState.prototype.runResolvers = function (_a) {\n        var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_c) {\n                if (document) {\n                    return [2 /*return*/, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) { return (__assign(__assign({}, remoteResult), { data: localResult.result })); })];\n                }\n                return [2 /*return*/, remoteResult];\n            });\n        });\n    };\n    LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n        this.fragmentMatcher = fragmentMatcher;\n    };\n    LocalState.prototype.getFragmentMatcher = function () {\n        return this.fragmentMatcher;\n    };\n    // Client queries contain everything in the incoming document (if a @client\n    // directive is found).\n    LocalState.prototype.clientQuery = function (document) {\n        if (hasDirectives([\"client\"], document)) {\n            if (this.resolvers) {\n                return document;\n            }\n        }\n        return null;\n    };\n    // Server queries are stripped of all @client based selection sets.\n    LocalState.prototype.serverQuery = function (document) {\n        return removeClientSetsFromDocument(document);\n    };\n    LocalState.prototype.prepareContext = function (context) {\n        var cache = this.cache;\n        return __assign(__assign({}, context), { cache: cache, \n            // Getting an entry's cache key is useful for local state resolvers.\n            getCacheKey: function (obj) {\n                return cache.identify(obj);\n            } });\n    };\n    // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n    // @client @export fields locally, then pass the resolved values back to be\n    // used alongside the original operation variables.\n    LocalState.prototype.addExportedVariables = function (document, variables, context) {\n        if (variables === void 0) { variables = {}; }\n        if (context === void 0) { context = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (document) {\n                    return [2 /*return*/, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) { return (__assign(__assign({}, variables), data.exportedVariables)); })];\n                }\n                return [2 /*return*/, __assign({}, variables)];\n            });\n        });\n    };\n    LocalState.prototype.shouldForceResolvers = function (document) {\n        var forceResolvers = false;\n        visit(document, {\n            Directive: {\n                enter: function (node) {\n                    if (node.name.value === \"client\" && node.arguments) {\n                        forceResolvers = node.arguments.some(function (arg) {\n                            return arg.name.value === \"always\" &&\n                                arg.value.kind === \"BooleanValue\" &&\n                                arg.value.value === true;\n                        });\n                        if (forceResolvers) {\n                            return BREAK;\n                        }\n                    }\n                },\n            },\n        });\n        return forceResolvers;\n    };\n    // Query the cache and return matching data.\n    LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n        return this.cache.diff({\n            query: buildQueryFromSelectionSet(document),\n            variables: variables,\n            returnPartialData: true,\n            optimistic: false,\n        }).result;\n    };\n    LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n        if (context === void 0) { context = {}; }\n        if (variables === void 0) { variables = {}; }\n        if (fragmentMatcher === void 0) { fragmentMatcher = function () { return true; }; }\n        if (onlyRunForcedResolvers === void 0) { onlyRunForcedResolvers = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;\n            return __generator(this, function (_b) {\n                mainDefinition = getMainDefinition(document);\n                fragments = getFragmentDefinitions(document);\n                fragmentMap = createFragmentMap(fragments);\n                selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\n                definitionOperation = mainDefinition.operation;\n                defaultOperationType = definitionOperation ?\n                    definitionOperation.charAt(0).toUpperCase() +\n                        definitionOperation.slice(1)\n                    : \"Query\";\n                _a = this, cache = _a.cache, client = _a.client;\n                execContext = {\n                    fragmentMap: fragmentMap,\n                    context: __assign(__assign({}, context), { cache: cache, client: client }),\n                    variables: variables,\n                    fragmentMatcher: fragmentMatcher,\n                    defaultOperationType: defaultOperationType,\n                    exportedVariables: {},\n                    selectionsToResolve: selectionsToResolve,\n                    onlyRunForcedResolvers: onlyRunForcedResolvers,\n                };\n                isClientFieldDescendant = false;\n                return [2 /*return*/, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (result) { return ({\n                        result: result,\n                        exportedVariables: execContext.exportedVariables,\n                    }); })];\n            });\n        });\n    };\n    LocalState.prototype.resolveSelectionSet = function (selectionSet, isClientFieldDescendant, rootValue, execContext) {\n        return __awaiter(this, void 0, void 0, function () {\n            var fragmentMap, context, variables, resultsToMerge, execute;\n            var _this = this;\n            return __generator(this, function (_a) {\n                fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n                resultsToMerge = [rootValue];\n                execute = function (selection) { return __awaiter(_this, void 0, void 0, function () {\n                    var fragment, typeCondition;\n                    return __generator(this, function (_a) {\n                        if (!isClientFieldDescendant &&\n                            !execContext.selectionsToResolve.has(selection)) {\n                            // Skip selections without @client directives\n                            // (still processing if one of the ancestors or one of the child fields has @client directive)\n                            return [2 /*return*/];\n                        }\n                        if (!shouldInclude(selection, variables)) {\n                            // Skip this entirely.\n                            return [2 /*return*/];\n                        }\n                        if (isField(selection)) {\n                            return [2 /*return*/, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function (fieldResult) {\n                                    var _a;\n                                    if (typeof fieldResult !== \"undefined\") {\n                                        resultsToMerge.push((_a = {},\n                                            _a[resultKeyNameFromField(selection)] = fieldResult,\n                                            _a));\n                                    }\n                                })];\n                        }\n                        if (isInlineFragment(selection)) {\n                            fragment = selection;\n                        }\n                        else {\n                            // This is a named fragment.\n                            fragment = fragmentMap[selection.name.value];\n                            invariant(fragment, 18, selection.name.value);\n                        }\n                        if (fragment && fragment.typeCondition) {\n                            typeCondition = fragment.typeCondition.name.value;\n                            if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                                return [2 /*return*/, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (fragmentResult) {\n                                        resultsToMerge.push(fragmentResult);\n                                    })];\n                            }\n                        }\n                        return [2 /*return*/];\n                    });\n                }); };\n                return [2 /*return*/, Promise.all(selectionSet.selections.map(execute)).then(function () {\n                        return mergeDeepArray(resultsToMerge);\n                    })];\n            });\n        });\n    };\n    LocalState.prototype.resolveField = function (field, isClientFieldDescendant, rootValue, execContext) {\n        return __awaiter(this, void 0, void 0, function () {\n            var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n            var _this = this;\n            return __generator(this, function (_a) {\n                if (!rootValue) {\n                    return [2 /*return*/, null];\n                }\n                variables = execContext.variables;\n                fieldName = field.name.value;\n                aliasedFieldName = resultKeyNameFromField(field);\n                aliasUsed = fieldName !== aliasedFieldName;\n                defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n                resultPromise = Promise.resolve(defaultResult);\n                // Usually all local resolvers are run when passing through here, but\n                // if we've specifically identified that we only want to run forced\n                // resolvers (that is, resolvers for fields marked with\n                // `@client(always: true)`), then we'll skip running non-forced resolvers.\n                if (!execContext.onlyRunForcedResolvers ||\n                    this.shouldForceResolvers(field)) {\n                    resolverType = rootValue.__typename || execContext.defaultOperationType;\n                    resolverMap = this.resolvers && this.resolvers[resolverType];\n                    if (resolverMap) {\n                        resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n                        if (resolve) {\n                            resultPromise = Promise.resolve(\n                            // In case the resolve function accesses reactive variables,\n                            // set cacheSlot to the current cache instance.\n                            cacheSlot.withValue(this.cache, resolve, [\n                                rootValue,\n                                argumentsObjectFromField(field, variables),\n                                execContext.context,\n                                { field: field, fragmentMap: execContext.fragmentMap },\n                            ]));\n                        }\n                    }\n                }\n                return [2 /*return*/, resultPromise.then(function (result) {\n                        var _a, _b;\n                        if (result === void 0) { result = defaultResult; }\n                        // If an @export directive is associated with the current field, store\n                        // the `as` export variable name and current result for later use.\n                        if (field.directives) {\n                            field.directives.forEach(function (directive) {\n                                if (directive.name.value === \"export\" && directive.arguments) {\n                                    directive.arguments.forEach(function (arg) {\n                                        if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                                            execContext.exportedVariables[arg.value.value] = result;\n                                        }\n                                    });\n                                }\n                            });\n                        }\n                        // Handle all scalar types here.\n                        if (!field.selectionSet) {\n                            return result;\n                        }\n                        // From here down, the field has a selection set, which means it's trying\n                        // to query a GraphQLObjectType.\n                        if (result == null) {\n                            // Basically any field in a GraphQL response can be null, or missing\n                            return result;\n                        }\n                        var isClientField = (_b = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.some(function (d) { return d.name.value === \"client\"; })) !== null && _b !== void 0 ? _b : false;\n                        if (Array.isArray(result)) {\n                            return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\n                        }\n                        // Returned value is an object, and the query has a sub-selection. Recurse.\n                        if (field.selectionSet) {\n                            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);\n                        }\n                    })];\n            });\n        });\n    };\n    LocalState.prototype.resolveSubSelectedArray = function (field, isClientFieldDescendant, result, execContext) {\n        var _this = this;\n        return Promise.all(result.map(function (item) {\n            if (item === null) {\n                return null;\n            }\n            // This is a nested array, recurse.\n            if (Array.isArray(item)) {\n                return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\n            }\n            // This is an object, run the selection set on it.\n            if (field.selectionSet) {\n                return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\n            }\n        }));\n    };\n    // Collect selection nodes on paths from document root down to all @client directives.\n    // This function takes into account transitive fragment spreads.\n    // Complexity equals to a single `visit` over the full document.\n    LocalState.prototype.collectSelectionsToResolve = function (mainDefinition, fragmentMap) {\n        var isSingleASTNode = function (node) { return !Array.isArray(node); };\n        var selectionsToResolveCache = this.selectionsToResolveCache;\n        function collectByDefinition(definitionNode) {\n            if (!selectionsToResolveCache.has(definitionNode)) {\n                var matches_1 = new Set();\n                selectionsToResolveCache.set(definitionNode, matches_1);\n                visit(definitionNode, {\n                    Directive: function (node, _, __, ___, ancestors) {\n                        if (node.name.value === \"client\") {\n                            ancestors.forEach(function (node) {\n                                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                                    matches_1.add(node);\n                                }\n                            });\n                        }\n                    },\n                    FragmentSpread: function (spread, _, __, ___, ancestors) {\n                        var fragment = fragmentMap[spread.name.value];\n                        invariant(fragment, 19, spread.name.value);\n                        var fragmentSelections = collectByDefinition(fragment);\n                        if (fragmentSelections.size > 0) {\n                            // Fragment for this spread contains @client directive (either directly or transitively)\n                            // Collect selection nodes on paths from the root down to fields with the @client directive\n                            ancestors.forEach(function (node) {\n                                if (isSingleASTNode(node) && isSelectionNode(node)) {\n                                    matches_1.add(node);\n                                }\n                            });\n                            matches_1.add(spread);\n                            fragmentSelections.forEach(function (selection) {\n                                matches_1.add(selection);\n                            });\n                        }\n                    },\n                });\n            }\n            return selectionsToResolveCache.get(definitionNode);\n        }\n        return collectByDefinition(mainDefinition);\n    };\n    return LocalState;\n}());\nexport { LocalState };\n//# sourceMappingURL=LocalState.js.map",
      "start": 1713269989252,
      "end": 1713269989253,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "graphql",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269989253,
      "end": 1713269989253,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1713269989253,
      "end": 1713269989254,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { visit, BREAK, isSelectionNode } from \"graphql\";\nimport { argumentsObjectFromField, buildQueryFromSelectionSet, createFragmentMap, getFragmentDefinitions, getMainDefinition, hasDirectives, isField, isInlineFragment, mergeDeep, mergeDeepArray, removeClientSetsFromDocument, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\nvar LocalState = (\n  /** @class */\n  function() {\n    function LocalState2(_a) {\n      var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;\n      this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();\n      this.cache = cache;\n      if (client) {\n        this.client = client;\n      }\n      if (resolvers) {\n        this.addResolvers(resolvers);\n      }\n      if (fragmentMatcher) {\n        this.setFragmentMatcher(fragmentMatcher);\n      }\n    }\n    LocalState2.prototype.addResolvers = function(resolvers) {\n      var _this = this;\n      this.resolvers = this.resolvers || {};\n      if (Array.isArray(resolvers)) {\n        resolvers.forEach(function(resolverGroup) {\n          _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\n        });\n      } else {\n        this.resolvers = mergeDeep(this.resolvers, resolvers);\n      }\n    };\n    LocalState2.prototype.setResolvers = function(resolvers) {\n      this.resolvers = {};\n      this.addResolvers(resolvers);\n    };\n    LocalState2.prototype.getResolvers = function() {\n      return this.resolvers || {};\n    };\n    LocalState2.prototype.runResolvers = function(_a) {\n      var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;\n      return __awaiter(this, void 0, void 0, function() {\n        return __generator(this, function(_c) {\n          if (document) {\n            return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {\n              return __assign(__assign({}, remoteResult), { data: localResult.result });\n            })];\n          }\n          return [2, remoteResult];\n        });\n      });\n    };\n    LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {\n      this.fragmentMatcher = fragmentMatcher;\n    };\n    LocalState2.prototype.getFragmentMatcher = function() {\n      return this.fragmentMatcher;\n    };\n    LocalState2.prototype.clientQuery = function(document) {\n      if (hasDirectives([\"client\"], document)) {\n        if (this.resolvers) {\n          return document;\n        }\n      }\n      return null;\n    };\n    LocalState2.prototype.serverQuery = function(document) {\n      return removeClientSetsFromDocument(document);\n    };\n    LocalState2.prototype.prepareContext = function(context) {\n      var cache = this.cache;\n      return __assign(__assign({}, context), {\n        cache,\n        // Getting an entry's cache key is useful for local state resolvers.\n        getCacheKey: function(obj) {\n          return cache.identify(obj);\n        }\n      });\n    };\n    LocalState2.prototype.addExportedVariables = function(document, variables, context) {\n      if (variables === void 0) {\n        variables = {};\n      }\n      if (context === void 0) {\n        context = {};\n      }\n      return __awaiter(this, void 0, void 0, function() {\n        return __generator(this, function(_a) {\n          if (document) {\n            return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function(data) {\n              return __assign(__assign({}, variables), data.exportedVariables);\n            })];\n          }\n          return [2, __assign({}, variables)];\n        });\n      });\n    };\n    LocalState2.prototype.shouldForceResolvers = function(document) {\n      var forceResolvers = false;\n      visit(document, {\n        Directive: {\n          enter: function(node) {\n            if (node.name.value === \"client\" && node.arguments) {\n              forceResolvers = node.arguments.some(function(arg) {\n                return arg.name.value === \"always\" && arg.value.kind === \"BooleanValue\" && arg.value.value === true;\n              });\n              if (forceResolvers) {\n                return BREAK;\n              }\n            }\n          }\n        }\n      });\n      return forceResolvers;\n    };\n    LocalState2.prototype.buildRootValueFromCache = function(document, variables) {\n      return this.cache.diff({\n        query: buildQueryFromSelectionSet(document),\n        variables,\n        returnPartialData: true,\n        optimistic: false\n      }).result;\n    };\n    LocalState2.prototype.resolveDocument = function(document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n      if (context === void 0) {\n        context = {};\n      }\n      if (variables === void 0) {\n        variables = {};\n      }\n      if (fragmentMatcher === void 0) {\n        fragmentMatcher = function() {\n          return true;\n        };\n      }\n      if (onlyRunForcedResolvers === void 0) {\n        onlyRunForcedResolvers = false;\n      }\n      return __awaiter(this, void 0, void 0, function() {\n        var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;\n        return __generator(this, function(_b) {\n          mainDefinition = getMainDefinition(document);\n          fragments = getFragmentDefinitions(document);\n          fragmentMap = createFragmentMap(fragments);\n          selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\n          definitionOperation = mainDefinition.operation;\n          defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : \"Query\";\n          _a = this, cache = _a.cache, client = _a.client;\n          execContext = {\n            fragmentMap,\n            context: __assign(__assign({}, context), { cache, client }),\n            variables,\n            fragmentMatcher,\n            defaultOperationType,\n            exportedVariables: {},\n            selectionsToResolve,\n            onlyRunForcedResolvers\n          };\n          isClientFieldDescendant = false;\n          return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result) {\n            return {\n              result,\n              exportedVariables: execContext.exportedVariables\n            };\n          })];\n        });\n      });\n    };\n    LocalState2.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {\n      return __awaiter(this, void 0, void 0, function() {\n        var fragmentMap, context, variables, resultsToMerge, execute;\n        var _this = this;\n        return __generator(this, function(_a) {\n          fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n          resultsToMerge = [rootValue];\n          execute = function(selection) {\n            return __awaiter(_this, void 0, void 0, function() {\n              var fragment, typeCondition;\n              return __generator(this, function(_a2) {\n                if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {\n                  return [\n                    2\n                    /*return*/\n                  ];\n                }\n                if (!shouldInclude(selection, variables)) {\n                  return [\n                    2\n                    /*return*/\n                  ];\n                }\n                if (isField(selection)) {\n                  return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {\n                    var _a3;\n                    if (typeof fieldResult !== \"undefined\") {\n                      resultsToMerge.push((_a3 = {}, _a3[resultKeyNameFromField(selection)] = fieldResult, _a3));\n                    }\n                  })];\n                }\n                if (isInlineFragment(selection)) {\n                  fragment = selection;\n                } else {\n                  fragment = fragmentMap[selection.name.value];\n                  invariant(fragment, 18, selection.name.value);\n                }\n                if (fragment && fragment.typeCondition) {\n                  typeCondition = fragment.typeCondition.name.value;\n                  if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                    return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {\n                      resultsToMerge.push(fragmentResult);\n                    })];\n                  }\n                }\n                return [\n                  2\n                  /*return*/\n                ];\n              });\n            });\n          };\n          return [2, Promise.all(selectionSet.selections.map(execute)).then(function() {\n            return mergeDeepArray(resultsToMerge);\n          })];\n        });\n      });\n    };\n    LocalState2.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {\n      return __awaiter(this, void 0, void 0, function() {\n        var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n        var _this = this;\n        return __generator(this, function(_a) {\n          if (!rootValue) {\n            return [2, null];\n          }\n          variables = execContext.variables;\n          fieldName = field.name.value;\n          aliasedFieldName = resultKeyNameFromField(field);\n          aliasUsed = fieldName !== aliasedFieldName;\n          defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n          resultPromise = Promise.resolve(defaultResult);\n          if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {\n            resolverType = rootValue.__typename || execContext.defaultOperationType;\n            resolverMap = this.resolvers && this.resolvers[resolverType];\n            if (resolverMap) {\n              resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n              if (resolve) {\n                resultPromise = Promise.resolve(\n                  // In case the resolve function accesses reactive variables,\n                  // set cacheSlot to the current cache instance.\n                  cacheSlot.withValue(this.cache, resolve, [\n                    rootValue,\n                    argumentsObjectFromField(field, variables),\n                    execContext.context,\n                    { field, fragmentMap: execContext.fragmentMap }\n                  ])\n                );\n              }\n            }\n          }\n          return [2, resultPromise.then(function(result) {\n            var _a2, _b;\n            if (result === void 0) {\n              result = defaultResult;\n            }\n            if (field.directives) {\n              field.directives.forEach(function(directive) {\n                if (directive.name.value === \"export\" && directive.arguments) {\n                  directive.arguments.forEach(function(arg) {\n                    if (arg.name.value === \"as\" && arg.value.kind === \"StringValue\") {\n                      execContext.exportedVariables[arg.value.value] = result;\n                    }\n                  });\n                }\n              });\n            }\n            if (!field.selectionSet) {\n              return result;\n            }\n            if (result == null) {\n              return result;\n            }\n            var isClientField = (_b = (_a2 = field.directives) === null || _a2 === void 0 ? void 0 : _a2.some(function(d) {\n              return d.name.value === \"client\";\n            })) !== null && _b !== void 0 ? _b : false;\n            if (Array.isArray(result)) {\n              return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\n            }\n            if (field.selectionSet) {\n              return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);\n            }\n          })];\n        });\n      });\n    };\n    LocalState2.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result, execContext) {\n      var _this = this;\n      return Promise.all(result.map(function(item) {\n        if (item === null) {\n          return null;\n        }\n        if (Array.isArray(item)) {\n          return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\n        }\n        if (field.selectionSet) {\n          return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\n        }\n      }));\n    };\n    LocalState2.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {\n      var isSingleASTNode = function(node) {\n        return !Array.isArray(node);\n      };\n      var selectionsToResolveCache = this.selectionsToResolveCache;\n      function collectByDefinition(definitionNode) {\n        if (!selectionsToResolveCache.has(definitionNode)) {\n          var matches_1 = /* @__PURE__ */ new Set();\n          selectionsToResolveCache.set(definitionNode, matches_1);\n          visit(definitionNode, {\n            Directive: function(node, _, __, ___, ancestors) {\n              if (node.name.value === \"client\") {\n                ancestors.forEach(function(node2) {\n                  if (isSingleASTNode(node2) && isSelectionNode(node2)) {\n                    matches_1.add(node2);\n                  }\n                });\n              }\n            },\n            FragmentSpread: function(spread, _, __, ___, ancestors) {\n              var fragment = fragmentMap[spread.name.value];\n              invariant(fragment, 19, spread.name.value);\n              var fragmentSelections = collectByDefinition(fragment);\n              if (fragmentSelections.size > 0) {\n                ancestors.forEach(function(node) {\n                  if (isSingleASTNode(node) && isSelectionNode(node)) {\n                    matches_1.add(node);\n                  }\n                });\n                matches_1.add(spread);\n                fragmentSelections.forEach(function(selection) {\n                  matches_1.add(selection);\n                });\n              }\n            }\n          });\n        }\n        return selectionsToResolveCache.get(definitionNode);\n      }\n      return collectByDefinition(mainDefinition);\n    };\n    return LocalState2;\n  }()\n);\nexport { LocalState };\n",
      "start": 1713269989254,
      "end": 1713269989572,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/core/LocalState.js\"],\n  \"sourcesContent\": [\"import { __assign, __awaiter, __generator } from \\\"tslib\\\";\\nimport { invariant } from \\\"../utilities/globals/index.js\\\";\\nimport { visit, BREAK, isSelectionNode } from \\\"graphql\\\";\\nimport { argumentsObjectFromField, buildQueryFromSelectionSet, createFragmentMap, getFragmentDefinitions, getMainDefinition, hasDirectives, isField, isInlineFragment, mergeDeep, mergeDeepArray, removeClientSetsFromDocument, resultKeyNameFromField, shouldInclude, } from \\\"../utilities/index.js\\\";\\nimport { cacheSlot } from \\\"../cache/index.js\\\";\\nvar LocalState = /** @class */ (function () {\\n    function LocalState(_a) {\\n        var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;\\n        this.selectionsToResolveCache = new WeakMap();\\n        this.cache = cache;\\n        if (client) {\\n            this.client = client;\\n        }\\n        if (resolvers) {\\n            this.addResolvers(resolvers);\\n        }\\n        if (fragmentMatcher) {\\n            this.setFragmentMatcher(fragmentMatcher);\\n        }\\n    }\\n    LocalState.prototype.addResolvers = function (resolvers) {\\n        var _this = this;\\n        this.resolvers = this.resolvers || {};\\n        if (Array.isArray(resolvers)) {\\n            resolvers.forEach(function (resolverGroup) {\\n                _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\\n            });\\n        }\\n        else {\\n            this.resolvers = mergeDeep(this.resolvers, resolvers);\\n        }\\n    };\\n    LocalState.prototype.setResolvers = function (resolvers) {\\n        this.resolvers = {};\\n        this.addResolvers(resolvers);\\n    };\\n    LocalState.prototype.getResolvers = function () {\\n        return this.resolvers || {};\\n    };\\n    // Run local client resolvers against the incoming query and remote data.\\n    // Locally resolved field values are merged with the incoming remote data,\\n    // and returned. Note that locally resolved fields will overwrite\\n    // remote data using the same field name.\\n    LocalState.prototype.runResolvers = function (_a) {\\n        var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;\\n        return __awaiter(this, void 0, void 0, function () {\\n            return __generator(this, function (_c) {\\n                if (document) {\\n                    return [2 /*return*/, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) { return (__assign(__assign({}, remoteResult), { data: localResult.result })); })];\\n                }\\n                return [2 /*return*/, remoteResult];\\n            });\\n        });\\n    };\\n    LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\\n        this.fragmentMatcher = fragmentMatcher;\\n    };\\n    LocalState.prototype.getFragmentMatcher = function () {\\n        return this.fragmentMatcher;\\n    };\\n    // Client queries contain everything in the incoming document (if a @client\\n    // directive is found).\\n    LocalState.prototype.clientQuery = function (document) {\\n        if (hasDirectives([\\\"client\\\"], document)) {\\n            if (this.resolvers) {\\n                return document;\\n            }\\n        }\\n        return null;\\n    };\\n    // Server queries are stripped of all @client based selection sets.\\n    LocalState.prototype.serverQuery = function (document) {\\n        return removeClientSetsFromDocument(document);\\n    };\\n    LocalState.prototype.prepareContext = function (context) {\\n        var cache = this.cache;\\n        return __assign(__assign({}, context), { cache: cache, \\n            // Getting an entry's cache key is useful for local state resolvers.\\n            getCacheKey: function (obj) {\\n                return cache.identify(obj);\\n            } });\\n    };\\n    // To support `@client @export(as: \\\"someVar\\\")` syntax, we'll first resolve\\n    // @client @export fields locally, then pass the resolved values back to be\\n    // used alongside the original operation variables.\\n    LocalState.prototype.addExportedVariables = function (document, variables, context) {\\n        if (variables === void 0) { variables = {}; }\\n        if (context === void 0) { context = {}; }\\n        return __awaiter(this, void 0, void 0, function () {\\n            return __generator(this, function (_a) {\\n                if (document) {\\n                    return [2 /*return*/, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) { return (__assign(__assign({}, variables), data.exportedVariables)); })];\\n                }\\n                return [2 /*return*/, __assign({}, variables)];\\n            });\\n        });\\n    };\\n    LocalState.prototype.shouldForceResolvers = function (document) {\\n        var forceResolvers = false;\\n        visit(document, {\\n            Directive: {\\n                enter: function (node) {\\n                    if (node.name.value === \\\"client\\\" && node.arguments) {\\n                        forceResolvers = node.arguments.some(function (arg) {\\n                            return arg.name.value === \\\"always\\\" &&\\n                                arg.value.kind === \\\"BooleanValue\\\" &&\\n                                arg.value.value === true;\\n                        });\\n                        if (forceResolvers) {\\n                            return BREAK;\\n                        }\\n                    }\\n                },\\n            },\\n        });\\n        return forceResolvers;\\n    };\\n    // Query the cache and return matching data.\\n    LocalState.prototype.buildRootValueFromCache = function (document, variables) {\\n        return this.cache.diff({\\n            query: buildQueryFromSelectionSet(document),\\n            variables: variables,\\n            returnPartialData: true,\\n            optimistic: false,\\n        }).result;\\n    };\\n    LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\\n        if (context === void 0) { context = {}; }\\n        if (variables === void 0) { variables = {}; }\\n        if (fragmentMatcher === void 0) { fragmentMatcher = function () { return true; }; }\\n        if (onlyRunForcedResolvers === void 0) { onlyRunForcedResolvers = false; }\\n        return __awaiter(this, void 0, void 0, function () {\\n            var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache, client, execContext, isClientFieldDescendant;\\n            return __generator(this, function (_b) {\\n                mainDefinition = getMainDefinition(document);\\n                fragments = getFragmentDefinitions(document);\\n                fragmentMap = createFragmentMap(fragments);\\n                selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);\\n                definitionOperation = mainDefinition.operation;\\n                defaultOperationType = definitionOperation ?\\n                    definitionOperation.charAt(0).toUpperCase() +\\n                        definitionOperation.slice(1)\\n                    : \\\"Query\\\";\\n                _a = this, cache = _a.cache, client = _a.client;\\n                execContext = {\\n                    fragmentMap: fragmentMap,\\n                    context: __assign(__assign({}, context), { cache: cache, client: client }),\\n                    variables: variables,\\n                    fragmentMatcher: fragmentMatcher,\\n                    defaultOperationType: defaultOperationType,\\n                    exportedVariables: {},\\n                    selectionsToResolve: selectionsToResolve,\\n                    onlyRunForcedResolvers: onlyRunForcedResolvers,\\n                };\\n                isClientFieldDescendant = false;\\n                return [2 /*return*/, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (result) { return ({\\n                        result: result,\\n                        exportedVariables: execContext.exportedVariables,\\n                    }); })];\\n            });\\n        });\\n    };\\n    LocalState.prototype.resolveSelectionSet = function (selectionSet, isClientFieldDescendant, rootValue, execContext) {\\n        return __awaiter(this, void 0, void 0, function () {\\n            var fragmentMap, context, variables, resultsToMerge, execute;\\n            var _this = this;\\n            return __generator(this, function (_a) {\\n                fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\\n                resultsToMerge = [rootValue];\\n                execute = function (selection) { return __awaiter(_this, void 0, void 0, function () {\\n                    var fragment, typeCondition;\\n                    return __generator(this, function (_a) {\\n                        if (!isClientFieldDescendant &&\\n                            !execContext.selectionsToResolve.has(selection)) {\\n                            // Skip selections without @client directives\\n                            // (still processing if one of the ancestors or one of the child fields has @client directive)\\n                            return [2 /*return*/];\\n                        }\\n                        if (!shouldInclude(selection, variables)) {\\n                            // Skip this entirely.\\n                            return [2 /*return*/];\\n                        }\\n                        if (isField(selection)) {\\n                            return [2 /*return*/, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function (fieldResult) {\\n                                    var _a;\\n                                    if (typeof fieldResult !== \\\"undefined\\\") {\\n                                        resultsToMerge.push((_a = {},\\n                                            _a[resultKeyNameFromField(selection)] = fieldResult,\\n                                            _a));\\n                                    }\\n                                })];\\n                        }\\n                        if (isInlineFragment(selection)) {\\n                            fragment = selection;\\n                        }\\n                        else {\\n                            // This is a named fragment.\\n                            fragment = fragmentMap[selection.name.value];\\n                            invariant(fragment, 18, selection.name.value);\\n                        }\\n                        if (fragment && fragment.typeCondition) {\\n                            typeCondition = fragment.typeCondition.name.value;\\n                            if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\\n                                return [2 /*return*/, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function (fragmentResult) {\\n                                        resultsToMerge.push(fragmentResult);\\n                                    })];\\n                            }\\n                        }\\n                        return [2 /*return*/];\\n                    });\\n                }); };\\n                return [2 /*return*/, Promise.all(selectionSet.selections.map(execute)).then(function () {\\n                        return mergeDeepArray(resultsToMerge);\\n                    })];\\n            });\\n        });\\n    };\\n    LocalState.prototype.resolveField = function (field, isClientFieldDescendant, rootValue, execContext) {\\n        return __awaiter(this, void 0, void 0, function () {\\n            var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\\n            var _this = this;\\n            return __generator(this, function (_a) {\\n                if (!rootValue) {\\n                    return [2 /*return*/, null];\\n                }\\n                variables = execContext.variables;\\n                fieldName = field.name.value;\\n                aliasedFieldName = resultKeyNameFromField(field);\\n                aliasUsed = fieldName !== aliasedFieldName;\\n                defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\\n                resultPromise = Promise.resolve(defaultResult);\\n                // Usually all local resolvers are run when passing through here, but\\n                // if we've specifically identified that we only want to run forced\\n                // resolvers (that is, resolvers for fields marked with\\n                // `@client(always: true)`), then we'll skip running non-forced resolvers.\\n                if (!execContext.onlyRunForcedResolvers ||\\n                    this.shouldForceResolvers(field)) {\\n                    resolverType = rootValue.__typename || execContext.defaultOperationType;\\n                    resolverMap = this.resolvers && this.resolvers[resolverType];\\n                    if (resolverMap) {\\n                        resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\\n                        if (resolve) {\\n                            resultPromise = Promise.resolve(\\n                            // In case the resolve function accesses reactive variables,\\n                            // set cacheSlot to the current cache instance.\\n                            cacheSlot.withValue(this.cache, resolve, [\\n                                rootValue,\\n                                argumentsObjectFromField(field, variables),\\n                                execContext.context,\\n                                { field: field, fragmentMap: execContext.fragmentMap },\\n                            ]));\\n                        }\\n                    }\\n                }\\n                return [2 /*return*/, resultPromise.then(function (result) {\\n                        var _a, _b;\\n                        if (result === void 0) { result = defaultResult; }\\n                        // If an @export directive is associated with the current field, store\\n                        // the `as` export variable name and current result for later use.\\n                        if (field.directives) {\\n                            field.directives.forEach(function (directive) {\\n                                if (directive.name.value === \\\"export\\\" && directive.arguments) {\\n                                    directive.arguments.forEach(function (arg) {\\n                                        if (arg.name.value === \\\"as\\\" && arg.value.kind === \\\"StringValue\\\") {\\n                                            execContext.exportedVariables[arg.value.value] = result;\\n                                        }\\n                                    });\\n                                }\\n                            });\\n                        }\\n                        // Handle all scalar types here.\\n                        if (!field.selectionSet) {\\n                            return result;\\n                        }\\n                        // From here down, the field has a selection set, which means it's trying\\n                        // to query a GraphQLObjectType.\\n                        if (result == null) {\\n                            // Basically any field in a GraphQL response can be null, or missing\\n                            return result;\\n                        }\\n                        var isClientField = (_b = (_a = field.directives) === null || _a === void 0 ? void 0 : _a.some(function (d) { return d.name.value === \\\"client\\\"; })) !== null && _b !== void 0 ? _b : false;\\n                        if (Array.isArray(result)) {\\n                            return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);\\n                        }\\n                        // Returned value is an object, and the query has a sub-selection. Recurse.\\n                        if (field.selectionSet) {\\n                            return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);\\n                        }\\n                    })];\\n            });\\n        });\\n    };\\n    LocalState.prototype.resolveSubSelectedArray = function (field, isClientFieldDescendant, result, execContext) {\\n        var _this = this;\\n        return Promise.all(result.map(function (item) {\\n            if (item === null) {\\n                return null;\\n            }\\n            // This is a nested array, recurse.\\n            if (Array.isArray(item)) {\\n                return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);\\n            }\\n            // This is an object, run the selection set on it.\\n            if (field.selectionSet) {\\n                return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);\\n            }\\n        }));\\n    };\\n    // Collect selection nodes on paths from document root down to all @client directives.\\n    // This function takes into account transitive fragment spreads.\\n    // Complexity equals to a single `visit` over the full document.\\n    LocalState.prototype.collectSelectionsToResolve = function (mainDefinition, fragmentMap) {\\n        var isSingleASTNode = function (node) { return !Array.isArray(node); };\\n        var selectionsToResolveCache = this.selectionsToResolveCache;\\n        function collectByDefinition(definitionNode) {\\n            if (!selectionsToResolveCache.has(definitionNode)) {\\n                var matches_1 = new Set();\\n                selectionsToResolveCache.set(definitionNode, matches_1);\\n                visit(definitionNode, {\\n                    Directive: function (node, _, __, ___, ancestors) {\\n                        if (node.name.value === \\\"client\\\") {\\n                            ancestors.forEach(function (node) {\\n                                if (isSingleASTNode(node) && isSelectionNode(node)) {\\n                                    matches_1.add(node);\\n                                }\\n                            });\\n                        }\\n                    },\\n                    FragmentSpread: function (spread, _, __, ___, ancestors) {\\n                        var fragment = fragmentMap[spread.name.value];\\n                        invariant(fragment, 19, spread.name.value);\\n                        var fragmentSelections = collectByDefinition(fragment);\\n                        if (fragmentSelections.size > 0) {\\n                            // Fragment for this spread contains @client directive (either directly or transitively)\\n                            // Collect selection nodes on paths from the root down to fields with the @client directive\\n                            ancestors.forEach(function (node) {\\n                                if (isSingleASTNode(node) && isSelectionNode(node)) {\\n                                    matches_1.add(node);\\n                                }\\n                            });\\n                            matches_1.add(spread);\\n                            fragmentSelections.forEach(function (selection) {\\n                                matches_1.add(selection);\\n                            });\\n                        }\\n                    },\\n                });\\n            }\\n            return selectionsToResolveCache.get(definitionNode);\\n        }\\n        return collectByDefinition(mainDefinition);\\n    };\\n    return LocalState;\\n}());\\nexport { LocalState };\\n//# sourceMappingURL=LocalState.js.map\"],\n  \"mappings\": \"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\",\n  \"names\": [\"LocalState\", \"_a\", \"node\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1713269989572,
      "end": 1713269989572,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1713269989572,
      "end": 1713269989572,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1713269989572,
      "end": 1713269989572,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1713269989572,
      "end": 1713269989572,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1713269989572,
      "end": 1713269989573,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1713269989573,
      "end": 1713269989573,
      "order": "normal"
    }
  ]
}
