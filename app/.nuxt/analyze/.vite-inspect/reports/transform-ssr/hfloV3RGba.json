{
  "resolvedId": "/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/cache/inmemory/policies.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { __assign, __rest } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay, } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray, } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier, } from \"./key-extractor.js\";\nfunction argsFromFieldSpecifier(spec) {\n    return (spec.args !== void 0 ? spec.args\n        : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\n            : null);\n}\nvar nullKeyFieldsFn = function () { return void 0; };\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nvar mergeTrueFn = function (existing, incoming, _a) {\n    var mergeObjects = _a.mergeObjects;\n    return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function (_, incoming) { return incoming; };\nvar Policies = /** @class */ (function () {\n    function Policies(config) {\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.toBeAdded = Object.create(null);\n        // Map from subtype names to sets of supertype names. Note that this\n        // representation inverts the structure of possibleTypes (whose keys are\n        // supertypes and whose values are arrays of subtypes) because it tends\n        // to be much more efficient to search upwards than downwards.\n        this.supertypeMap = new Map();\n        // Any fuzzy subtypes specified by possibleTypes will be converted to\n        // RegExp objects and recorded here. Every key of this map can also be\n        // found in supertypeMap. In many cases this Map will be empty, which\n        // means no fuzzy subtype checking will happen in fragmentMatches.\n        this.fuzzySubtypes = new Map();\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, partialContext) {\n        var _a;\n        var policies = this;\n        var typename = (partialContext &&\n            (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename))) ||\n            object.__typename;\n        // It should be possible to write root Query fields with writeFragment,\n        // using { __typename: \"Query\", ... } as the data, but it does not make\n        // sense to allow the same identification behavior for the Mutation and\n        // Subscription types, since application code should never be writing\n        // directly to (or reading directly from) those root objects.\n        if (typename === this.rootTypenamesById.ROOT_QUERY) {\n            return [\"ROOT_QUERY\"];\n        }\n        // Default context.storeObject to object if not otherwise provided.\n        var storeObject = (partialContext && partialContext.storeObject) || object;\n        var context = __assign(__assign({}, partialContext), { typename: typename, storeObject: storeObject, readField: (partialContext && partialContext.readField) ||\n                function () {\n                    var options = normalizeReadFieldOptions(arguments, storeObject);\n                    return policies.readField(options, {\n                        store: policies.cache[\"data\"],\n                        variables: options.variables,\n                    });\n                } });\n        var id;\n        var policy = typename && this.getTypePolicy(typename);\n        var keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\n        while (keyFn) {\n            var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);\n            if (isArray(specifierOrId)) {\n                keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n            }\n            else {\n                id = specifierOrId;\n                break;\n            }\n        }\n        id = id ? String(id) : void 0;\n        return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n            // Though {query,mutation,subscription}Type configurations are rare,\n            // it's important to call setRootTypename as early as possible,\n            // since these configurations should apply consistently for the\n            // entire lifetime of the cache. Also, since only one __typename can\n            // qualify as one of these root types, these three properties cannot\n            // be inherited, unlike the rest of the incoming properties. That\n            // restriction is convenient, because the purpose of this.toBeAdded\n            // is to delay the processing of type/field policies until the first\n            // time they're used, allowing policies to be added in any order as\n            // long as all relevant policies (including policies for supertypes)\n            // have been added by the time a given policy is used for the first\n            // time. In other words, since inheritance doesn't matter for these\n            // properties, there's also no need to delay their processing using\n            // the this.toBeAdded queue.\n            if (queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            if (hasOwn.call(_this.toBeAdded, typename)) {\n                _this.toBeAdded[typename].push(incoming);\n            }\n            else {\n                _this.toBeAdded[typename] = [incoming];\n            }\n        });\n    };\n    Policies.prototype.updateTypePolicy = function (typename, incoming) {\n        var _this = this;\n        var existing = this.getTypePolicy(typename);\n        var keyFields = incoming.keyFields, fields = incoming.fields;\n        function setMerge(existing, merge) {\n            existing.merge =\n                typeof merge === \"function\" ? merge\n                    // Pass merge:true as a shorthand for a merge implementation\n                    // that returns options.mergeObjects(existing, incoming).\n                    : merge === true ? mergeTrueFn\n                        // Pass merge:false to make incoming always replace existing\n                        // without any warnings about data clobbering.\n                        : merge === false ? mergeFalseFn\n                            : existing.merge;\n        }\n        // Type policies can define merge functions, as an alternative to\n        // using field policies to merge child objects.\n        setMerge(existing, incoming.merge);\n        existing.keyFn =\n            // Pass false to disable normalization for this typename.\n            keyFields === false ? nullKeyFieldsFn\n                // Pass an array of strings to use those fields to compute a\n                // composite ID for objects of this typename.\n                : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\n                    // Pass a function to take full control over identification.\n                    : typeof keyFields === \"function\" ? keyFields\n                        // Leave existing.keyFn unchanged if above cases fail.\n                        : existing.keyFn;\n        if (fields) {\n            Object.keys(fields).forEach(function (fieldName) {\n                var existing = _this.getFieldPolicy(typename, fieldName, true);\n                var incoming = fields[fieldName];\n                if (typeof incoming === \"function\") {\n                    existing.read = incoming;\n                }\n                else {\n                    var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                    existing.keyFn =\n                        // Pass false to disable argument-based differentiation of\n                        // field identities.\n                        keyArgs === false ? simpleKeyArgsFn\n                            // Pass an array of strings to use named arguments to\n                            // compute a composite identity for the field.\n                            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\n                                // Pass a function to take full control over field identity.\n                                : typeof keyArgs === \"function\" ? keyArgs\n                                    // Leave existing.keyFn unchanged if above cases fail.\n                                    : existing.keyFn;\n                    if (typeof read === \"function\") {\n                        existing.read = read;\n                    }\n                    setMerge(existing, merge);\n                }\n                if (existing.read && existing.merge) {\n                    // If we have both a read and a merge function, assume\n                    // keyArgs:false, because read and merge together can take\n                    // responsibility for interpreting arguments in and out. This\n                    // default assumption can always be overridden by specifying\n                    // keyArgs explicitly in the FieldPolicy.\n                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                }\n            });\n        }\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        if (typename === void 0) { typename = which; }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            invariant(!old || old === which, 5, which);\n            // First, delete any old __typename associated with this rootId from\n            // rootIdsByTypename.\n            if (old)\n                delete this.rootIdsByTypename[old];\n            // Now make this the only __typename that maps to this rootId.\n            this.rootIdsByTypename[typename] = rootId;\n            // Finally, update the __typename associated with this rootId.\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            // Make sure all types have an entry in this.supertypeMap, even if\n            // their supertype set is empty, so we can return false immediately\n            // from policies.fragmentMatches for unknown supertypes.\n            _this.getSupertypeSet(supertype, true);\n            possibleTypes[supertype].forEach(function (subtype) {\n                _this.getSupertypeSet(subtype, true).add(supertype);\n                var match = subtype.match(TypeOrFieldNameRegExp);\n                if (!match || match[0] !== subtype) {\n                    // TODO Don't interpret just any invalid typename as a RegExp.\n                    _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n                }\n            });\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename) {\n        var _this = this;\n        if (!hasOwn.call(this.typePolicies, typename)) {\n            var policy_1 = (this.typePolicies[typename] = Object.create(null));\n            policy_1.fields = Object.create(null);\n            // When the TypePolicy for typename is first accessed, instead of\n            // starting with an empty policy object, inherit any properties or\n            // fields from the type policies of the supertypes of typename.\n            //\n            // Any properties or fields defined explicitly within the TypePolicy\n            // for typename will take precedence, and if there are multiple\n            // supertypes, the properties of policies whose types were added\n            // later via addPossibleTypes will take precedence over those of\n            // earlier supertypes. TODO Perhaps we should warn about these\n            // conflicts in development, and recommend defining the property\n            // explicitly in the subtype policy?\n            //\n            // Field policy inheritance is atomic/shallow: you can't inherit a\n            // field policy and then override just its read function, since read\n            // and merge functions often need to cooperate, so changing only one\n            // of them would be a recipe for inconsistency.\n            //\n            // Once the TypePolicy for typename has been accessed, its properties can\n            // still be updated directly using addTypePolicies, but future changes to\n            // inherited supertype policies will not be reflected in this subtype\n            // policy, because this code runs at most once per typename.\n            var supertypes_1 = this.supertypeMap.get(typename);\n            if (!supertypes_1 && this.fuzzySubtypes.size) {\n                // To make the inheritance logic work for unknown typename strings that\n                // may have fuzzy supertypes, we give this typename an empty supertype\n                // set and then populate it with any fuzzy supertypes that match.\n                supertypes_1 = this.getSupertypeSet(typename, true);\n                // This only works for typenames that are directly matched by a fuzzy\n                // supertype. What if there is an intermediate chain of supertypes?\n                // While possible, that situation can only be solved effectively by\n                // specifying the intermediate relationships via possibleTypes, manually\n                // and in a non-fuzzy way.\n                this.fuzzySubtypes.forEach(function (regExp, fuzzy) {\n                    if (regExp.test(typename)) {\n                        // The fuzzy parameter is just the original string version of regExp\n                        // (not a valid __typename string), but we can look up the\n                        // associated supertype(s) in this.supertypeMap.\n                        var fuzzySupertypes = _this.supertypeMap.get(fuzzy);\n                        if (fuzzySupertypes) {\n                            fuzzySupertypes.forEach(function (supertype) {\n                                return supertypes_1.add(supertype);\n                            });\n                        }\n                    }\n                });\n            }\n            if (supertypes_1 && supertypes_1.size) {\n                supertypes_1.forEach(function (supertype) {\n                    var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = __rest(_a, [\"fields\"]);\n                    Object.assign(policy_1, rest);\n                    Object.assign(policy_1.fields, fields);\n                });\n            }\n        }\n        var inbox = this.toBeAdded[typename];\n        if (inbox && inbox.length) {\n            // Merge the pending policies into this.typePolicies, in the order they\n            // were originally passed to addTypePolicy.\n            inbox.splice(0).forEach(function (policy) {\n                _this.updateTypePolicy(typename, policy);\n            });\n        }\n        return this.typePolicies[typename];\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        if (typename) {\n            var fieldPolicies = this.getTypePolicy(typename).fields;\n            return (fieldPolicies[fieldName] ||\n                (createIfMissing && (fieldPolicies[fieldName] = Object.create(null))));\n        }\n    };\n    Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n        var supertypeSet = this.supertypeMap.get(subtype);\n        if (!supertypeSet && createIfMissing) {\n            this.supertypeMap.set(subtype, (supertypeSet = new Set()));\n        }\n        return supertypeSet;\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        // If the fragment has a type condition but the object we're matching\n        // against does not have a __typename, the fragment cannot match.\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        // Common case: fragment type condition and __typename are the same.\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n            var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n            var workQueue_1 = [typenameSupertypeSet];\n            var maybeEnqueue_1 = function (subtype) {\n                var supertypeSet = _this.getSupertypeSet(subtype, false);\n                if (supertypeSet &&\n                    supertypeSet.size &&\n                    workQueue_1.indexOf(supertypeSet) < 0) {\n                    workQueue_1.push(supertypeSet);\n                }\n            };\n            // We need to check fuzzy subtypes only if we encountered fuzzy\n            // subtype strings in addPossibleTypes, and only while writing to\n            // the cache, since that's when selectionSetMatchesResult gives a\n            // strong signal of fragment matching. The StoreReader class calls\n            // policies.fragmentMatches without passing a result object, so\n            // needToCheckFuzzySubtypes is always false while reading.\n            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n            var checkingFuzzySubtypes = false;\n            // It's important to keep evaluating workQueue.length each time through\n            // the loop, because the queue can grow while we're iterating over it.\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var supertypeSet = workQueue_1[i];\n                if (supertypeSet.has(supertype)) {\n                    if (!typenameSupertypeSet.has(supertype)) {\n                        if (checkingFuzzySubtypes) {\n                            globalThis.__DEV__ !== false && invariant.warn(6, typename, supertype);\n                        }\n                        // Record positive results for faster future lookup.\n                        // Unfortunately, we cannot safely cache negative results,\n                        // because new possibleTypes data could always be added to the\n                        // Policies class.\n                        typenameSupertypeSet.add(supertype);\n                    }\n                    return true;\n                }\n                supertypeSet.forEach(maybeEnqueue_1);\n                if (needToCheckFuzzySubtypes &&\n                    // Start checking fuzzy subtypes only after exhausting all\n                    // non-fuzzy subtypes (after the final iteration of the loop).\n                    i === workQueue_1.length - 1 &&\n                    // We could wait to compare fragment.selectionSet to result\n                    // after we verify the supertype, but this check is often less\n                    // expensive than that search, and we will have to do the\n                    // comparison anyway whenever we find a potential match.\n                    selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n                    // We don't always need to check fuzzy subtypes (if no result\n                    // was provided, or !this.fuzzySubtypes.size), but, when we do,\n                    // we only want to check them once.\n                    needToCheckFuzzySubtypes = false;\n                    checkingFuzzySubtypes = true;\n                    // If we find any fuzzy subtypes that match typename, extend the\n                    // workQueue to search through the supertypes of those fuzzy\n                    // subtypes. Otherwise the for-loop will terminate and we'll\n                    // return false below.\n                    this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n                        var match = typename.match(regExp);\n                        if (match && match[0] === typename) {\n                            maybeEnqueue_1(fuzzyString);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.keyFn);\n    };\n    Policies.prototype.getStoreFieldName = function (fieldSpec) {\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var context = {\n                typename: typename,\n                fieldName: fieldName,\n                field: fieldSpec.field || null,\n                variables: fieldSpec.variables,\n            };\n            var args = argsFromFieldSpecifier(fieldSpec);\n            while (keyFn) {\n                var specifierOrString = keyFn(args, context);\n                if (isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    // If the custom keyFn returns a falsy value, fall back to\n                    // fieldName instead.\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName =\n                fieldSpec.field ?\n                    storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n                    : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        // Returning false from a keyArgs function is like configuring\n        // keyArgs: false, but more dynamic.\n        if (storeFieldName === false) {\n            return fieldName;\n        }\n        // Make sure custom field names start with the actual field.name.value\n        // of the field, so we can always figure out which properties of a\n        // StoreObject correspond to which original field names.\n        return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (options, context) {\n        var objectOrReference = options.from;\n        if (!objectOrReference)\n            return;\n        var nameOrField = options.field || options.fieldName;\n        if (!nameOrField)\n            return;\n        if (options.typename === void 0) {\n            var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n            if (typename)\n                options.typename = typename;\n        }\n        var storeFieldName = this.getStoreFieldName(options);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ?\n                objectOrReference.__ref\n                : objectOrReference, storeFieldName));\n            // Call read(existing, readOptions) with cacheSlot holding this.cache.\n            return cacheSlot.withValue(this.cache, read, [\n                existing,\n                readOptions,\n            ]);\n        }\n        return existing;\n    };\n    Policies.prototype.getReadFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return policy && policy.read;\n    };\n    Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n        var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n        var merge = policy && policy.merge;\n        if (!merge && childTypename) {\n            policy = this.getTypePolicy(childTypename);\n            merge = policy && policy.merge;\n        }\n        return merge;\n    };\n    Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n        var field = _a.field, typename = _a.typename, merge = _a.merge;\n        if (merge === mergeTrueFn) {\n            // Instead of going to the trouble of creating a full\n            // FieldFunctionOptions object and calling mergeTrueFn, we can\n            // simply call mergeObjects, as mergeTrueFn would.\n            return makeMergeObjectsFunction(context.store)(existing, incoming);\n        }\n        if (merge === mergeFalseFn) {\n            // Likewise for mergeFalseFn, whose implementation is even simpler.\n            return incoming;\n        }\n        // If cache.writeQuery or cache.writeFragment was called with\n        // options.overwrite set to true, we still call merge functions, but\n        // the existing data is always undefined, so the merge function will\n        // not attempt to combine the incoming data with the existing data.\n        if (context.overwrite) {\n            existing = void 0;\n        }\n        return merge(existing, incoming, makeFieldFunctionOptions(this, \n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0, {\n            typename: typename,\n            fieldName: field.name.value,\n            field: field,\n            variables: context.variables,\n        }, context, storage || Object.create(null)));\n    };\n    return Policies;\n}());\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var variables = fieldSpec.variables || context.variables;\n    var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        isReference: isReference,\n        toReference: toReference,\n        storage: storage,\n        cache: policies.cache,\n        canRead: canRead,\n        readField: function () {\n            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n        },\n        mergeObjects: makeMergeObjectsFunction(context.store),\n    };\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n    var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;\n    var options;\n    if (typeof fieldNameOrOptions === \"string\") {\n        options = {\n            fieldName: fieldNameOrOptions,\n            // Default to objectOrReference only when no second argument was\n            // passed for the from parameter, not when undefined is explicitly\n            // passed as the second argument.\n            from: argc > 1 ? from : objectOrReference,\n        };\n    }\n    else {\n        options = __assign({}, fieldNameOrOptions);\n        // Default to objectOrReference only when fieldNameOrOptions.from is\n        // actually omitted, rather than just undefined.\n        if (!hasOwn.call(options, \"from\")) {\n            options.from = objectOrReference;\n        }\n    }\n    if (globalThis.__DEV__ !== false && options.from === void 0) {\n        globalThis.__DEV__ !== false && invariant.warn(7, stringifyForDisplay(Array.from(readFieldArgs)));\n    }\n    if (void 0 === options.variables) {\n        options.variables = variables;\n    }\n    return options;\n}\nfunction makeMergeObjectsFunction(store) {\n    return function mergeObjects(existing, incoming) {\n        if (isArray(existing) || isArray(incoming)) {\n            throw newInvariantError(8);\n        }\n        // These dynamic checks are necessary because the parameters of a\n        // custom merge function can easily have the any type, so the type\n        // system cannot always enforce the StoreObject | Reference parameter\n        // types of options.mergeObjects.\n        if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n            var eType = store.getFieldValue(existing, \"__typename\");\n            var iType = store.getFieldValue(incoming, \"__typename\");\n            var typesDiffer = eType && iType && eType !== iType;\n            if (typesDiffer) {\n                return incoming;\n            }\n            if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // existing.__ref, preferring/overwriting any fields contributed by the\n                // newer incoming StoreObject.\n                store.merge(existing.__ref, incoming);\n                return existing;\n            }\n            if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n                // Update the normalized EntityStore for the entity identified by\n                // incoming.__ref, taking fields from the older existing object only if\n                // those fields are not already present in the newer StoreObject\n                // identified by incoming.__ref.\n                store.merge(existing, incoming.__ref);\n                return incoming;\n            }\n            if (storeValueIsStoreObject(existing) &&\n                storeValueIsStoreObject(incoming)) {\n                return __assign(__assign({}, existing), incoming);\n            }\n        }\n        return incoming;\n    };\n}\n//# sourceMappingURL=policies.js.map",
      "start": 1713269988945,
      "end": 1713269988953,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "graphql",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1713269988953,
      "end": 1713269988953,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { __assign, __rest } from \"tslib\";\nimport { invariant, newInvariantError } from \"../../utilities/globals/index.js\";\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier } from \"./key-extractor.js\";\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nvar nullKeyFieldsFn = function() {\n  return void 0;\n};\nvar simpleKeyArgsFn = function(_args, context) {\n  return context.fieldName;\n};\nvar mergeTrueFn = function(existing, incoming, _a) {\n  var mergeObjects = _a.mergeObjects;\n  return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function(_, incoming) {\n  return incoming;\n};\nvar Policies = (\n  /** @class */\n  function() {\n    function Policies2(config) {\n      this.config = config;\n      this.typePolicies = /* @__PURE__ */ Object.create(null);\n      this.toBeAdded = /* @__PURE__ */ Object.create(null);\n      this.supertypeMap = /* @__PURE__ */ new Map();\n      this.fuzzySubtypes = /* @__PURE__ */ new Map();\n      this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);\n      this.rootTypenamesById = /* @__PURE__ */ Object.create(null);\n      this.usingPossibleTypes = false;\n      this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n      this.cache = this.config.cache;\n      this.setRootTypename(\"Query\");\n      this.setRootTypename(\"Mutation\");\n      this.setRootTypename(\"Subscription\");\n      if (config.possibleTypes) {\n        this.addPossibleTypes(config.possibleTypes);\n      }\n      if (config.typePolicies) {\n        this.addTypePolicies(config.typePolicies);\n      }\n    }\n    Policies2.prototype.identify = function(object, partialContext) {\n      var _a;\n      var policies = this;\n      var typename = partialContext && (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;\n      if (typename === this.rootTypenamesById.ROOT_QUERY) {\n        return [\"ROOT_QUERY\"];\n      }\n      var storeObject = partialContext && partialContext.storeObject || object;\n      var context = __assign(__assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {\n        var options = normalizeReadFieldOptions(arguments, storeObject);\n        return policies.readField(options, {\n          store: policies.cache[\"data\"],\n          variables: options.variables\n        });\n      } });\n      var id;\n      var policy = typename && this.getTypePolicy(typename);\n      var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n      while (keyFn) {\n        var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);\n        if (isArray(specifierOrId)) {\n          keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n        } else {\n          id = specifierOrId;\n          break;\n        }\n      }\n      id = id ? String(id) : void 0;\n      return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies2.prototype.addTypePolicies = function(typePolicies) {\n      var _this = this;\n      Object.keys(typePolicies).forEach(function(typename) {\n        var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n        if (queryType)\n          _this.setRootTypename(\"Query\", typename);\n        if (mutationType)\n          _this.setRootTypename(\"Mutation\", typename);\n        if (subscriptionType)\n          _this.setRootTypename(\"Subscription\", typename);\n        if (hasOwn.call(_this.toBeAdded, typename)) {\n          _this.toBeAdded[typename].push(incoming);\n        } else {\n          _this.toBeAdded[typename] = [incoming];\n        }\n      });\n    };\n    Policies2.prototype.updateTypePolicy = function(typename, incoming) {\n      var _this = this;\n      var existing = this.getTypePolicy(typename);\n      var keyFields = incoming.keyFields, fields = incoming.fields;\n      function setMerge(existing2, merge) {\n        existing2.merge = typeof merge === \"function\" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing2.merge;\n      }\n      setMerge(existing, incoming.merge);\n      existing.keyFn = // Pass false to disable normalization for this typename.\n      keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === \"function\" ? keyFields : existing.keyFn;\n      if (fields) {\n        Object.keys(fields).forEach(function(fieldName) {\n          var existing2 = _this.getFieldPolicy(typename, fieldName, true);\n          var incoming2 = fields[fieldName];\n          if (typeof incoming2 === \"function\") {\n            existing2.read = incoming2;\n          } else {\n            var keyArgs = incoming2.keyArgs, read = incoming2.read, merge = incoming2.merge;\n            existing2.keyFn = // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing2.keyFn;\n            if (typeof read === \"function\") {\n              existing2.read = read;\n            }\n            setMerge(existing2, merge);\n          }\n          if (existing2.read && existing2.merge) {\n            existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;\n          }\n        });\n      }\n    };\n    Policies2.prototype.setRootTypename = function(which, typename) {\n      if (typename === void 0) {\n        typename = which;\n      }\n      var rootId = \"ROOT_\" + which.toUpperCase();\n      var old = this.rootTypenamesById[rootId];\n      if (typename !== old) {\n        invariant(!old || old === which, 5, which);\n        if (old)\n          delete this.rootIdsByTypename[old];\n        this.rootIdsByTypename[typename] = rootId;\n        this.rootTypenamesById[rootId] = typename;\n      }\n    };\n    Policies2.prototype.addPossibleTypes = function(possibleTypes) {\n      var _this = this;\n      this.usingPossibleTypes = true;\n      Object.keys(possibleTypes).forEach(function(supertype) {\n        _this.getSupertypeSet(supertype, true);\n        possibleTypes[supertype].forEach(function(subtype) {\n          _this.getSupertypeSet(subtype, true).add(supertype);\n          var match = subtype.match(TypeOrFieldNameRegExp);\n          if (!match || match[0] !== subtype) {\n            _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n          }\n        });\n      });\n    };\n    Policies2.prototype.getTypePolicy = function(typename) {\n      var _this = this;\n      if (!hasOwn.call(this.typePolicies, typename)) {\n        var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);\n        policy_1.fields = /* @__PURE__ */ Object.create(null);\n        var supertypes_1 = this.supertypeMap.get(typename);\n        if (!supertypes_1 && this.fuzzySubtypes.size) {\n          supertypes_1 = this.getSupertypeSet(typename, true);\n          this.fuzzySubtypes.forEach(function(regExp, fuzzy) {\n            if (regExp.test(typename)) {\n              var fuzzySupertypes = _this.supertypeMap.get(fuzzy);\n              if (fuzzySupertypes) {\n                fuzzySupertypes.forEach(function(supertype) {\n                  return supertypes_1.add(supertype);\n                });\n              }\n            }\n          });\n        }\n        if (supertypes_1 && supertypes_1.size) {\n          supertypes_1.forEach(function(supertype) {\n            var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = __rest(_a, [\"fields\"]);\n            Object.assign(policy_1, rest);\n            Object.assign(policy_1.fields, fields);\n          });\n        }\n      }\n      var inbox = this.toBeAdded[typename];\n      if (inbox && inbox.length) {\n        inbox.splice(0).forEach(function(policy) {\n          _this.updateTypePolicy(typename, policy);\n        });\n      }\n      return this.typePolicies[typename];\n    };\n    Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {\n      if (typename) {\n        var fieldPolicies = this.getTypePolicy(typename).fields;\n        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));\n      }\n    };\n    Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {\n      var supertypeSet = this.supertypeMap.get(subtype);\n      if (!supertypeSet && createIfMissing) {\n        this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());\n      }\n      return supertypeSet;\n    };\n    Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {\n      var _this = this;\n      if (!fragment.typeCondition)\n        return true;\n      if (!typename)\n        return false;\n      var supertype = fragment.typeCondition.name.value;\n      if (typename === supertype)\n        return true;\n      if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n        var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n        var workQueue_1 = [typenameSupertypeSet];\n        var maybeEnqueue_1 = function(subtype) {\n          var supertypeSet2 = _this.getSupertypeSet(subtype, false);\n          if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {\n            workQueue_1.push(supertypeSet2);\n          }\n        };\n        var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n        var checkingFuzzySubtypes = false;\n        for (var i = 0; i < workQueue_1.length; ++i) {\n          var supertypeSet = workQueue_1[i];\n          if (supertypeSet.has(supertype)) {\n            if (!typenameSupertypeSet.has(supertype)) {\n              if (checkingFuzzySubtypes) {\n                globalThis.__DEV__ !== false && invariant.warn(6, typename, supertype);\n              }\n              typenameSupertypeSet.add(supertype);\n            }\n            return true;\n          }\n          supertypeSet.forEach(maybeEnqueue_1);\n          if (needToCheckFuzzySubtypes && // Start checking fuzzy subtypes only after exhausting all\n          // non-fuzzy subtypes (after the final iteration of the loop).\n          i === workQueue_1.length - 1 && // We could wait to compare fragment.selectionSet to result\n          // after we verify the supertype, but this check is often less\n          // expensive than that search, and we will have to do the\n          // comparison anyway whenever we find a potential match.\n          selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n            needToCheckFuzzySubtypes = false;\n            checkingFuzzySubtypes = true;\n            this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {\n              var match = typename.match(regExp);\n              if (match && match[0] === typename) {\n                maybeEnqueue_1(fuzzyString);\n              }\n            });\n          }\n        }\n      }\n      return false;\n    };\n    Policies2.prototype.hasKeyArgs = function(typename, fieldName) {\n      var policy = this.getFieldPolicy(typename, fieldName, false);\n      return !!(policy && policy.keyFn);\n    };\n    Policies2.prototype.getStoreFieldName = function(fieldSpec) {\n      var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n      var policy = this.getFieldPolicy(typename, fieldName, false);\n      var storeFieldName;\n      var keyFn = policy && policy.keyFn;\n      if (keyFn && typename) {\n        var context = {\n          typename,\n          fieldName,\n          field: fieldSpec.field || null,\n          variables: fieldSpec.variables\n        };\n        var args = argsFromFieldSpecifier(fieldSpec);\n        while (keyFn) {\n          var specifierOrString = keyFn(args, context);\n          if (isArray(specifierOrString)) {\n            keyFn = keyArgsFnFromSpecifier(specifierOrString);\n          } else {\n            storeFieldName = specifierOrString || fieldName;\n            break;\n          }\n        }\n      }\n      if (storeFieldName === void 0) {\n        storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n      }\n      if (storeFieldName === false) {\n        return fieldName;\n      }\n      return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n    };\n    Policies2.prototype.readField = function(options, context) {\n      var objectOrReference = options.from;\n      if (!objectOrReference)\n        return;\n      var nameOrField = options.field || options.fieldName;\n      if (!nameOrField)\n        return;\n      if (options.typename === void 0) {\n        var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n        if (typename)\n          options.typename = typename;\n      }\n      var storeFieldName = this.getStoreFieldName(options);\n      var fieldName = fieldNameFromStoreName(storeFieldName);\n      var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n      var policy = this.getFieldPolicy(options.typename, fieldName, false);\n      var read = policy && policy.read;\n      if (read) {\n        var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));\n        return cacheSlot.withValue(this.cache, read, [\n          existing,\n          readOptions\n        ]);\n      }\n      return existing;\n    };\n    Policies2.prototype.getReadFunction = function(typename, fieldName) {\n      var policy = this.getFieldPolicy(typename, fieldName, false);\n      return policy && policy.read;\n    };\n    Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {\n      var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n      var merge = policy && policy.merge;\n      if (!merge && childTypename) {\n        policy = this.getTypePolicy(childTypename);\n        merge = policy && policy.merge;\n      }\n      return merge;\n    };\n    Policies2.prototype.runMergeFunction = function(existing, incoming, _a, context, storage) {\n      var field = _a.field, typename = _a.typename, merge = _a.merge;\n      if (merge === mergeTrueFn) {\n        return makeMergeObjectsFunction(context.store)(existing, incoming);\n      }\n      if (merge === mergeFalseFn) {\n        return incoming;\n      }\n      if (context.overwrite) {\n        existing = void 0;\n      }\n      return merge(existing, incoming, makeFieldFunctionOptions(\n        this,\n        // Unlike options.readField for read functions, we do not fall\n        // back to the current object if no foreignObjOrRef is provided,\n        // because it's not clear what the current object should be for\n        // merge functions: the (possibly undefined) existing object, or\n        // the incoming object? If you think your merge function needs\n        // to read sibling fields in order to produce a new value for\n        // the current field, you might want to rethink your strategy,\n        // because that's a recipe for making merge behavior sensitive\n        // to the order in which fields are written into the cache.\n        // However, readField(name, ref) is useful for merge functions\n        // that need to deduplicate child objects and references.\n        void 0,\n        {\n          typename,\n          fieldName: field.name.value,\n          field,\n          variables: context.variables\n        },\n        context,\n        storage || /* @__PURE__ */ Object.create(null)\n      ));\n    };\n    return Policies2;\n  }()\n);\nexport { Policies };\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n    readField: function() {\n      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n    },\n    mergeObjects: makeMergeObjectsFunction(context.store)\n  };\n}\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n  var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;\n  var options;\n  if (typeof fieldNameOrOptions === \"string\") {\n    options = {\n      fieldName: fieldNameOrOptions,\n      // Default to objectOrReference only when no second argument was\n      // passed for the from parameter, not when undefined is explicitly\n      // passed as the second argument.\n      from: argc > 1 ? from : objectOrReference\n    };\n  } else {\n    options = __assign({}, fieldNameOrOptions);\n    if (!hasOwn.call(options, \"from\")) {\n      options.from = objectOrReference;\n    }\n  }\n  if (globalThis.__DEV__ !== false && options.from === void 0) {\n    globalThis.__DEV__ !== false && invariant.warn(7, stringifyForDisplay(Array.from(readFieldArgs)));\n  }\n  if (void 0 === options.variables) {\n    options.variables = variables;\n  }\n  return options;\n}\nfunction makeMergeObjectsFunction(store) {\n  return function mergeObjects(existing, incoming) {\n    if (isArray(existing) || isArray(incoming)) {\n      throw newInvariantError(8);\n    }\n    if (isNonNullObject(existing) && isNonNullObject(incoming)) {\n      var eType = store.getFieldValue(existing, \"__typename\");\n      var iType = store.getFieldValue(incoming, \"__typename\");\n      var typesDiffer = eType && iType && eType !== iType;\n      if (typesDiffer) {\n        return incoming;\n      }\n      if (isReference(existing) && storeValueIsStoreObject(incoming)) {\n        store.merge(existing.__ref, incoming);\n        return existing;\n      }\n      if (storeValueIsStoreObject(existing) && isReference(incoming)) {\n        store.merge(existing, incoming.__ref);\n        return incoming;\n      }\n      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {\n        return __assign(__assign({}, existing), incoming);\n      }\n    }\n    return incoming;\n  };\n}\n",
      "start": 1713269988953,
      "end": 1713269989308,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/cache/inmemory/policies.js\"],\n  \"sourcesContent\": [\"import { __assign, __rest } from \\\"tslib\\\";\\nimport { invariant, newInvariantError } from \\\"../../utilities/globals/index.js\\\";\\nimport { storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, isNonNullObject, stringifyForDisplay, } from \\\"../../utilities/index.js\\\";\\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp, defaultDataIdFromObject, isArray, } from \\\"./helpers.js\\\";\\nimport { cacheSlot } from \\\"./reactiveVars.js\\\";\\nimport { keyArgsFnFromSpecifier, keyFieldsFnFromSpecifier, } from \\\"./key-extractor.js\\\";\\nfunction argsFromFieldSpecifier(spec) {\\n    return (spec.args !== void 0 ? spec.args\\n        : spec.field ? argumentsObjectFromField(spec.field, spec.variables)\\n            : null);\\n}\\nvar nullKeyFieldsFn = function () { return void 0; };\\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\\n// These merge functions can be selected by specifying merge:true or\\n// merge:false in a field policy.\\nvar mergeTrueFn = function (existing, incoming, _a) {\\n    var mergeObjects = _a.mergeObjects;\\n    return mergeObjects(existing, incoming);\\n};\\nvar mergeFalseFn = function (_, incoming) { return incoming; };\\nvar Policies = /** @class */ (function () {\\n    function Policies(config) {\\n        this.config = config;\\n        this.typePolicies = Object.create(null);\\n        this.toBeAdded = Object.create(null);\\n        // Map from subtype names to sets of supertype names. Note that this\\n        // representation inverts the structure of possibleTypes (whose keys are\\n        // supertypes and whose values are arrays of subtypes) because it tends\\n        // to be much more efficient to search upwards than downwards.\\n        this.supertypeMap = new Map();\\n        // Any fuzzy subtypes specified by possibleTypes will be converted to\\n        // RegExp objects and recorded here. Every key of this map can also be\\n        // found in supertypeMap. In many cases this Map will be empty, which\\n        // means no fuzzy subtype checking will happen in fragmentMatches.\\n        this.fuzzySubtypes = new Map();\\n        this.rootIdsByTypename = Object.create(null);\\n        this.rootTypenamesById = Object.create(null);\\n        this.usingPossibleTypes = false;\\n        this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);\\n        this.cache = this.config.cache;\\n        this.setRootTypename(\\\"Query\\\");\\n        this.setRootTypename(\\\"Mutation\\\");\\n        this.setRootTypename(\\\"Subscription\\\");\\n        if (config.possibleTypes) {\\n            this.addPossibleTypes(config.possibleTypes);\\n        }\\n        if (config.typePolicies) {\\n            this.addTypePolicies(config.typePolicies);\\n        }\\n    }\\n    Policies.prototype.identify = function (object, partialContext) {\\n        var _a;\\n        var policies = this;\\n        var typename = (partialContext &&\\n            (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename))) ||\\n            object.__typename;\\n        // It should be possible to write root Query fields with writeFragment,\\n        // using { __typename: \\\"Query\\\", ... } as the data, but it does not make\\n        // sense to allow the same identification behavior for the Mutation and\\n        // Subscription types, since application code should never be writing\\n        // directly to (or reading directly from) those root objects.\\n        if (typename === this.rootTypenamesById.ROOT_QUERY) {\\n            return [\\\"ROOT_QUERY\\\"];\\n        }\\n        // Default context.storeObject to object if not otherwise provided.\\n        var storeObject = (partialContext && partialContext.storeObject) || object;\\n        var context = __assign(__assign({}, partialContext), { typename: typename, storeObject: storeObject, readField: (partialContext && partialContext.readField) ||\\n                function () {\\n                    var options = normalizeReadFieldOptions(arguments, storeObject);\\n                    return policies.readField(options, {\\n                        store: policies.cache[\\\"data\\\"],\\n                        variables: options.variables,\\n                    });\\n                } });\\n        var id;\\n        var policy = typename && this.getTypePolicy(typename);\\n        var keyFn = (policy && policy.keyFn) || this.config.dataIdFromObject;\\n        while (keyFn) {\\n            var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);\\n            if (isArray(specifierOrId)) {\\n                keyFn = keyFieldsFnFromSpecifier(specifierOrId);\\n            }\\n            else {\\n                id = specifierOrId;\\n                break;\\n            }\\n        }\\n        id = id ? String(id) : void 0;\\n        return context.keyObject ? [id, context.keyObject] : [id];\\n    };\\n    Policies.prototype.addTypePolicies = function (typePolicies) {\\n        var _this = this;\\n        Object.keys(typePolicies).forEach(function (typename) {\\n            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = __rest(_a, [\\\"queryType\\\", \\\"mutationType\\\", \\\"subscriptionType\\\"]);\\n            // Though {query,mutation,subscription}Type configurations are rare,\\n            // it's important to call setRootTypename as early as possible,\\n            // since these configurations should apply consistently for the\\n            // entire lifetime of the cache. Also, since only one __typename can\\n            // qualify as one of these root types, these three properties cannot\\n            // be inherited, unlike the rest of the incoming properties. That\\n            // restriction is convenient, because the purpose of this.toBeAdded\\n            // is to delay the processing of type/field policies until the first\\n            // time they're used, allowing policies to be added in any order as\\n            // long as all relevant policies (including policies for supertypes)\\n            // have been added by the time a given policy is used for the first\\n            // time. In other words, since inheritance doesn't matter for these\\n            // properties, there's also no need to delay their processing using\\n            // the this.toBeAdded queue.\\n            if (queryType)\\n                _this.setRootTypename(\\\"Query\\\", typename);\\n            if (mutationType)\\n                _this.setRootTypename(\\\"Mutation\\\", typename);\\n            if (subscriptionType)\\n                _this.setRootTypename(\\\"Subscription\\\", typename);\\n            if (hasOwn.call(_this.toBeAdded, typename)) {\\n                _this.toBeAdded[typename].push(incoming);\\n            }\\n            else {\\n                _this.toBeAdded[typename] = [incoming];\\n            }\\n        });\\n    };\\n    Policies.prototype.updateTypePolicy = function (typename, incoming) {\\n        var _this = this;\\n        var existing = this.getTypePolicy(typename);\\n        var keyFields = incoming.keyFields, fields = incoming.fields;\\n        function setMerge(existing, merge) {\\n            existing.merge =\\n                typeof merge === \\\"function\\\" ? merge\\n                    // Pass merge:true as a shorthand for a merge implementation\\n                    // that returns options.mergeObjects(existing, incoming).\\n                    : merge === true ? mergeTrueFn\\n                        // Pass merge:false to make incoming always replace existing\\n                        // without any warnings about data clobbering.\\n                        : merge === false ? mergeFalseFn\\n                            : existing.merge;\\n        }\\n        // Type policies can define merge functions, as an alternative to\\n        // using field policies to merge child objects.\\n        setMerge(existing, incoming.merge);\\n        existing.keyFn =\\n            // Pass false to disable normalization for this typename.\\n            keyFields === false ? nullKeyFieldsFn\\n                // Pass an array of strings to use those fields to compute a\\n                // composite ID for objects of this typename.\\n                : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields)\\n                    // Pass a function to take full control over identification.\\n                    : typeof keyFields === \\\"function\\\" ? keyFields\\n                        // Leave existing.keyFn unchanged if above cases fail.\\n                        : existing.keyFn;\\n        if (fields) {\\n            Object.keys(fields).forEach(function (fieldName) {\\n                var existing = _this.getFieldPolicy(typename, fieldName, true);\\n                var incoming = fields[fieldName];\\n                if (typeof incoming === \\\"function\\\") {\\n                    existing.read = incoming;\\n                }\\n                else {\\n                    var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\\n                    existing.keyFn =\\n                        // Pass false to disable argument-based differentiation of\\n                        // field identities.\\n                        keyArgs === false ? simpleKeyArgsFn\\n                            // Pass an array of strings to use named arguments to\\n                            // compute a composite identity for the field.\\n                            : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs)\\n                                // Pass a function to take full control over field identity.\\n                                : typeof keyArgs === \\\"function\\\" ? keyArgs\\n                                    // Leave existing.keyFn unchanged if above cases fail.\\n                                    : existing.keyFn;\\n                    if (typeof read === \\\"function\\\") {\\n                        existing.read = read;\\n                    }\\n                    setMerge(existing, merge);\\n                }\\n                if (existing.read && existing.merge) {\\n                    // If we have both a read and a merge function, assume\\n                    // keyArgs:false, because read and merge together can take\\n                    // responsibility for interpreting arguments in and out. This\\n                    // default assumption can always be overridden by specifying\\n                    // keyArgs explicitly in the FieldPolicy.\\n                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;\\n                }\\n            });\\n        }\\n    };\\n    Policies.prototype.setRootTypename = function (which, typename) {\\n        if (typename === void 0) { typename = which; }\\n        var rootId = \\\"ROOT_\\\" + which.toUpperCase();\\n        var old = this.rootTypenamesById[rootId];\\n        if (typename !== old) {\\n            invariant(!old || old === which, 5, which);\\n            // First, delete any old __typename associated with this rootId from\\n            // rootIdsByTypename.\\n            if (old)\\n                delete this.rootIdsByTypename[old];\\n            // Now make this the only __typename that maps to this rootId.\\n            this.rootIdsByTypename[typename] = rootId;\\n            // Finally, update the __typename associated with this rootId.\\n            this.rootTypenamesById[rootId] = typename;\\n        }\\n    };\\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\\n        var _this = this;\\n        this.usingPossibleTypes = true;\\n        Object.keys(possibleTypes).forEach(function (supertype) {\\n            // Make sure all types have an entry in this.supertypeMap, even if\\n            // their supertype set is empty, so we can return false immediately\\n            // from policies.fragmentMatches for unknown supertypes.\\n            _this.getSupertypeSet(supertype, true);\\n            possibleTypes[supertype].forEach(function (subtype) {\\n                _this.getSupertypeSet(subtype, true).add(supertype);\\n                var match = subtype.match(TypeOrFieldNameRegExp);\\n                if (!match || match[0] !== subtype) {\\n                    // TODO Don't interpret just any invalid typename as a RegExp.\\n                    _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\\n                }\\n            });\\n        });\\n    };\\n    Policies.prototype.getTypePolicy = function (typename) {\\n        var _this = this;\\n        if (!hasOwn.call(this.typePolicies, typename)) {\\n            var policy_1 = (this.typePolicies[typename] = Object.create(null));\\n            policy_1.fields = Object.create(null);\\n            // When the TypePolicy for typename is first accessed, instead of\\n            // starting with an empty policy object, inherit any properties or\\n            // fields from the type policies of the supertypes of typename.\\n            //\\n            // Any properties or fields defined explicitly within the TypePolicy\\n            // for typename will take precedence, and if there are multiple\\n            // supertypes, the properties of policies whose types were added\\n            // later via addPossibleTypes will take precedence over those of\\n            // earlier supertypes. TODO Perhaps we should warn about these\\n            // conflicts in development, and recommend defining the property\\n            // explicitly in the subtype policy?\\n            //\\n            // Field policy inheritance is atomic/shallow: you can't inherit a\\n            // field policy and then override just its read function, since read\\n            // and merge functions often need to cooperate, so changing only one\\n            // of them would be a recipe for inconsistency.\\n            //\\n            // Once the TypePolicy for typename has been accessed, its properties can\\n            // still be updated directly using addTypePolicies, but future changes to\\n            // inherited supertype policies will not be reflected in this subtype\\n            // policy, because this code runs at most once per typename.\\n            var supertypes_1 = this.supertypeMap.get(typename);\\n            if (!supertypes_1 && this.fuzzySubtypes.size) {\\n                // To make the inheritance logic work for unknown typename strings that\\n                // may have fuzzy supertypes, we give this typename an empty supertype\\n                // set and then populate it with any fuzzy supertypes that match.\\n                supertypes_1 = this.getSupertypeSet(typename, true);\\n                // This only works for typenames that are directly matched by a fuzzy\\n                // supertype. What if there is an intermediate chain of supertypes?\\n                // While possible, that situation can only be solved effectively by\\n                // specifying the intermediate relationships via possibleTypes, manually\\n                // and in a non-fuzzy way.\\n                this.fuzzySubtypes.forEach(function (regExp, fuzzy) {\\n                    if (regExp.test(typename)) {\\n                        // The fuzzy parameter is just the original string version of regExp\\n                        // (not a valid __typename string), but we can look up the\\n                        // associated supertype(s) in this.supertypeMap.\\n                        var fuzzySupertypes = _this.supertypeMap.get(fuzzy);\\n                        if (fuzzySupertypes) {\\n                            fuzzySupertypes.forEach(function (supertype) {\\n                                return supertypes_1.add(supertype);\\n                            });\\n                        }\\n                    }\\n                });\\n            }\\n            if (supertypes_1 && supertypes_1.size) {\\n                supertypes_1.forEach(function (supertype) {\\n                    var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = __rest(_a, [\\\"fields\\\"]);\\n                    Object.assign(policy_1, rest);\\n                    Object.assign(policy_1.fields, fields);\\n                });\\n            }\\n        }\\n        var inbox = this.toBeAdded[typename];\\n        if (inbox && inbox.length) {\\n            // Merge the pending policies into this.typePolicies, in the order they\\n            // were originally passed to addTypePolicy.\\n            inbox.splice(0).forEach(function (policy) {\\n                _this.updateTypePolicy(typename, policy);\\n            });\\n        }\\n        return this.typePolicies[typename];\\n    };\\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\\n        if (typename) {\\n            var fieldPolicies = this.getTypePolicy(typename).fields;\\n            return (fieldPolicies[fieldName] ||\\n                (createIfMissing && (fieldPolicies[fieldName] = Object.create(null))));\\n        }\\n    };\\n    Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\\n        var supertypeSet = this.supertypeMap.get(subtype);\\n        if (!supertypeSet && createIfMissing) {\\n            this.supertypeMap.set(subtype, (supertypeSet = new Set()));\\n        }\\n        return supertypeSet;\\n    };\\n    Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\\n        var _this = this;\\n        if (!fragment.typeCondition)\\n            return true;\\n        // If the fragment has a type condition but the object we're matching\\n        // against does not have a __typename, the fragment cannot match.\\n        if (!typename)\\n            return false;\\n        var supertype = fragment.typeCondition.name.value;\\n        // Common case: fragment type condition and __typename are the same.\\n        if (typename === supertype)\\n            return true;\\n        if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\\n            var typenameSupertypeSet = this.getSupertypeSet(typename, true);\\n            var workQueue_1 = [typenameSupertypeSet];\\n            var maybeEnqueue_1 = function (subtype) {\\n                var supertypeSet = _this.getSupertypeSet(subtype, false);\\n                if (supertypeSet &&\\n                    supertypeSet.size &&\\n                    workQueue_1.indexOf(supertypeSet) < 0) {\\n                    workQueue_1.push(supertypeSet);\\n                }\\n            };\\n            // We need to check fuzzy subtypes only if we encountered fuzzy\\n            // subtype strings in addPossibleTypes, and only while writing to\\n            // the cache, since that's when selectionSetMatchesResult gives a\\n            // strong signal of fragment matching. The StoreReader class calls\\n            // policies.fragmentMatches without passing a result object, so\\n            // needToCheckFuzzySubtypes is always false while reading.\\n            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\\n            var checkingFuzzySubtypes = false;\\n            // It's important to keep evaluating workQueue.length each time through\\n            // the loop, because the queue can grow while we're iterating over it.\\n            for (var i = 0; i < workQueue_1.length; ++i) {\\n                var supertypeSet = workQueue_1[i];\\n                if (supertypeSet.has(supertype)) {\\n                    if (!typenameSupertypeSet.has(supertype)) {\\n                        if (checkingFuzzySubtypes) {\\n                            globalThis.__DEV__ !== false && invariant.warn(6, typename, supertype);\\n                        }\\n                        // Record positive results for faster future lookup.\\n                        // Unfortunately, we cannot safely cache negative results,\\n                        // because new possibleTypes data could always be added to the\\n                        // Policies class.\\n                        typenameSupertypeSet.add(supertype);\\n                    }\\n                    return true;\\n                }\\n                supertypeSet.forEach(maybeEnqueue_1);\\n                if (needToCheckFuzzySubtypes &&\\n                    // Start checking fuzzy subtypes only after exhausting all\\n                    // non-fuzzy subtypes (after the final iteration of the loop).\\n                    i === workQueue_1.length - 1 &&\\n                    // We could wait to compare fragment.selectionSet to result\\n                    // after we verify the supertype, but this check is often less\\n                    // expensive than that search, and we will have to do the\\n                    // comparison anyway whenever we find a potential match.\\n                    selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\\n                    // We don't always need to check fuzzy subtypes (if no result\\n                    // was provided, or !this.fuzzySubtypes.size), but, when we do,\\n                    // we only want to check them once.\\n                    needToCheckFuzzySubtypes = false;\\n                    checkingFuzzySubtypes = true;\\n                    // If we find any fuzzy subtypes that match typename, extend the\\n                    // workQueue to search through the supertypes of those fuzzy\\n                    // subtypes. Otherwise the for-loop will terminate and we'll\\n                    // return false below.\\n                    this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\\n                        var match = typename.match(regExp);\\n                        if (match && match[0] === typename) {\\n                            maybeEnqueue_1(fuzzyString);\\n                        }\\n                    });\\n                }\\n            }\\n        }\\n        return false;\\n    };\\n    Policies.prototype.hasKeyArgs = function (typename, fieldName) {\\n        var policy = this.getFieldPolicy(typename, fieldName, false);\\n        return !!(policy && policy.keyFn);\\n    };\\n    Policies.prototype.getStoreFieldName = function (fieldSpec) {\\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\\n        var policy = this.getFieldPolicy(typename, fieldName, false);\\n        var storeFieldName;\\n        var keyFn = policy && policy.keyFn;\\n        if (keyFn && typename) {\\n            var context = {\\n                typename: typename,\\n                fieldName: fieldName,\\n                field: fieldSpec.field || null,\\n                variables: fieldSpec.variables,\\n            };\\n            var args = argsFromFieldSpecifier(fieldSpec);\\n            while (keyFn) {\\n                var specifierOrString = keyFn(args, context);\\n                if (isArray(specifierOrString)) {\\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\\n                }\\n                else {\\n                    // If the custom keyFn returns a falsy value, fall back to\\n                    // fieldName instead.\\n                    storeFieldName = specifierOrString || fieldName;\\n                    break;\\n                }\\n            }\\n        }\\n        if (storeFieldName === void 0) {\\n            storeFieldName =\\n                fieldSpec.field ?\\n                    storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\\n                    : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\\n        }\\n        // Returning false from a keyArgs function is like configuring\\n        // keyArgs: false, but more dynamic.\\n        if (storeFieldName === false) {\\n            return fieldName;\\n        }\\n        // Make sure custom field names start with the actual field.name.value\\n        // of the field, so we can always figure out which properties of a\\n        // StoreObject correspond to which original field names.\\n        return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName\\n            : fieldName + \\\":\\\" + storeFieldName;\\n    };\\n    Policies.prototype.readField = function (options, context) {\\n        var objectOrReference = options.from;\\n        if (!objectOrReference)\\n            return;\\n        var nameOrField = options.field || options.fieldName;\\n        if (!nameOrField)\\n            return;\\n        if (options.typename === void 0) {\\n            var typename = context.store.getFieldValue(objectOrReference, \\\"__typename\\\");\\n            if (typename)\\n                options.typename = typename;\\n        }\\n        var storeFieldName = this.getStoreFieldName(options);\\n        var fieldName = fieldNameFromStoreName(storeFieldName);\\n        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\\n        var read = policy && policy.read;\\n        if (read) {\\n            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ?\\n                objectOrReference.__ref\\n                : objectOrReference, storeFieldName));\\n            // Call read(existing, readOptions) with cacheSlot holding this.cache.\\n            return cacheSlot.withValue(this.cache, read, [\\n                existing,\\n                readOptions,\\n            ]);\\n        }\\n        return existing;\\n    };\\n    Policies.prototype.getReadFunction = function (typename, fieldName) {\\n        var policy = this.getFieldPolicy(typename, fieldName, false);\\n        return policy && policy.read;\\n    };\\n    Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\\n        var policy = this.getFieldPolicy(parentTypename, fieldName, false);\\n        var merge = policy && policy.merge;\\n        if (!merge && childTypename) {\\n            policy = this.getTypePolicy(childTypename);\\n            merge = policy && policy.merge;\\n        }\\n        return merge;\\n    };\\n    Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\\n        var field = _a.field, typename = _a.typename, merge = _a.merge;\\n        if (merge === mergeTrueFn) {\\n            // Instead of going to the trouble of creating a full\\n            // FieldFunctionOptions object and calling mergeTrueFn, we can\\n            // simply call mergeObjects, as mergeTrueFn would.\\n            return makeMergeObjectsFunction(context.store)(existing, incoming);\\n        }\\n        if (merge === mergeFalseFn) {\\n            // Likewise for mergeFalseFn, whose implementation is even simpler.\\n            return incoming;\\n        }\\n        // If cache.writeQuery or cache.writeFragment was called with\\n        // options.overwrite set to true, we still call merge functions, but\\n        // the existing data is always undefined, so the merge function will\\n        // not attempt to combine the incoming data with the existing data.\\n        if (context.overwrite) {\\n            existing = void 0;\\n        }\\n        return merge(existing, incoming, makeFieldFunctionOptions(this, \\n        // Unlike options.readField for read functions, we do not fall\\n        // back to the current object if no foreignObjOrRef is provided,\\n        // because it's not clear what the current object should be for\\n        // merge functions: the (possibly undefined) existing object, or\\n        // the incoming object? If you think your merge function needs\\n        // to read sibling fields in order to produce a new value for\\n        // the current field, you might want to rethink your strategy,\\n        // because that's a recipe for making merge behavior sensitive\\n        // to the order in which fields are written into the cache.\\n        // However, readField(name, ref) is useful for merge functions\\n        // that need to deduplicate child objects and references.\\n        void 0, {\\n            typename: typename,\\n            fieldName: field.name.value,\\n            field: field,\\n            variables: context.variables,\\n        }, context, storage || Object.create(null)));\\n    };\\n    return Policies;\\n}());\\nexport { Policies };\\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\\n    var fieldName = fieldNameFromStoreName(storeFieldName);\\n    var variables = fieldSpec.variables || context.variables;\\n    var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;\\n    return {\\n        args: argsFromFieldSpecifier(fieldSpec),\\n        field: fieldSpec.field || null,\\n        fieldName: fieldName,\\n        storeFieldName: storeFieldName,\\n        variables: variables,\\n        isReference: isReference,\\n        toReference: toReference,\\n        storage: storage,\\n        cache: policies.cache,\\n        canRead: canRead,\\n        readField: function () {\\n            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\\n        },\\n        mergeObjects: makeMergeObjectsFunction(context.store),\\n    };\\n}\\nexport function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\\n    var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;\\n    var options;\\n    if (typeof fieldNameOrOptions === \\\"string\\\") {\\n        options = {\\n            fieldName: fieldNameOrOptions,\\n            // Default to objectOrReference only when no second argument was\\n            // passed for the from parameter, not when undefined is explicitly\\n            // passed as the second argument.\\n            from: argc > 1 ? from : objectOrReference,\\n        };\\n    }\\n    else {\\n        options = __assign({}, fieldNameOrOptions);\\n        // Default to objectOrReference only when fieldNameOrOptions.from is\\n        // actually omitted, rather than just undefined.\\n        if (!hasOwn.call(options, \\\"from\\\")) {\\n            options.from = objectOrReference;\\n        }\\n    }\\n    if (globalThis.__DEV__ !== false && options.from === void 0) {\\n        globalThis.__DEV__ !== false && invariant.warn(7, stringifyForDisplay(Array.from(readFieldArgs)));\\n    }\\n    if (void 0 === options.variables) {\\n        options.variables = variables;\\n    }\\n    return options;\\n}\\nfunction makeMergeObjectsFunction(store) {\\n    return function mergeObjects(existing, incoming) {\\n        if (isArray(existing) || isArray(incoming)) {\\n            throw newInvariantError(8);\\n        }\\n        // These dynamic checks are necessary because the parameters of a\\n        // custom merge function can easily have the any type, so the type\\n        // system cannot always enforce the StoreObject | Reference parameter\\n        // types of options.mergeObjects.\\n        if (isNonNullObject(existing) && isNonNullObject(incoming)) {\\n            var eType = store.getFieldValue(existing, \\\"__typename\\\");\\n            var iType = store.getFieldValue(incoming, \\\"__typename\\\");\\n            var typesDiffer = eType && iType && eType !== iType;\\n            if (typesDiffer) {\\n                return incoming;\\n            }\\n            if (isReference(existing) && storeValueIsStoreObject(incoming)) {\\n                // Update the normalized EntityStore for the entity identified by\\n                // existing.__ref, preferring/overwriting any fields contributed by the\\n                // newer incoming StoreObject.\\n                store.merge(existing.__ref, incoming);\\n                return existing;\\n            }\\n            if (storeValueIsStoreObject(existing) && isReference(incoming)) {\\n                // Update the normalized EntityStore for the entity identified by\\n                // incoming.__ref, taking fields from the older existing object only if\\n                // those fields are not already present in the newer StoreObject\\n                // identified by incoming.__ref.\\n                store.merge(existing, incoming.__ref);\\n                return incoming;\\n            }\\n            if (storeValueIsStoreObject(existing) &&\\n                storeValueIsStoreObject(incoming)) {\\n                return __assign(__assign({}, existing), incoming);\\n            }\\n        }\\n        return incoming;\\n    };\\n}\\n//# sourceMappingURL=policies.js.map\"],\n  \"mappings\": \"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\",\n  \"names\": [\"Policies\", \"existing\", \"incoming\", \"supertypeSet\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1713269989308,
      "end": 1713269989308,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1713269989308,
      "end": 1713269989308,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1713269989308,
      "end": 1713269989308,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1713269989308,
      "end": 1713269989308,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1713269989308,
      "end": 1713269989309,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1713269989309,
      "end": 1713269989309,
      "order": "normal"
    }
  ]
}
