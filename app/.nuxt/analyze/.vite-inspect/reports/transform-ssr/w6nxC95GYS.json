{
  "resolvedId": "/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/cache/inmemory/entityStore.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { __assign, __extends, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { dep } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { isReference, makeReference, DeepMerger, maybeDeepFreeze, canUseWeakMap, isNonNullObject, } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName } from \"./helpers.js\";\nvar DELETE = Object.create(null);\nvar delModifier = function () { return DELETE; };\nvar INVALIDATE = Object.create(null);\nvar EntityStore = /** @class */ (function () {\n    function EntityStore(policies, group) {\n        var _this = this;\n        this.policies = policies;\n        this.group = group;\n        this.data = Object.create(null);\n        // Maps root entity IDs to the number of times they have been retained, minus\n        // the number of times they have been released. Retained entities keep other\n        // entities they reference (even indirectly) from being garbage collected.\n        this.rootIds = Object.create(null);\n        // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n        this.refs = Object.create(null);\n        // Bound function that can be passed around to provide easy access to fields\n        // of Reference objects as well as ordinary objects.\n        this.getFieldValue = function (objectOrReference, storeFieldName) {\n            return maybeDeepFreeze(isReference(objectOrReference) ?\n                _this.get(objectOrReference.__ref, storeFieldName)\n                : objectOrReference && objectOrReference[storeFieldName]);\n        };\n        // Returns true for non-normalized StoreObjects and non-dangling\n        // References, indicating that readField(name, objOrRef) has a chance of\n        // working. Useful for filtering out dangling references from lists.\n        this.canRead = function (objOrRef) {\n            return isReference(objOrRef) ?\n                _this.has(objOrRef.__ref)\n                : typeof objOrRef === \"object\";\n        };\n        // Bound function that converts an id or an object with a __typename and\n        // primary key fields to a Reference object. If called with a Reference object,\n        // that same Reference object is returned. Pass true for mergeIntoStore to persist\n        // an object into the store.\n        this.toReference = function (objOrIdOrRef, mergeIntoStore) {\n            if (typeof objOrIdOrRef === \"string\") {\n                return makeReference(objOrIdOrRef);\n            }\n            if (isReference(objOrIdOrRef)) {\n                return objOrIdOrRef;\n            }\n            var id = _this.policies.identify(objOrIdOrRef)[0];\n            if (id) {\n                var ref = makeReference(id);\n                if (mergeIntoStore) {\n                    _this.merge(id, objOrIdOrRef);\n                }\n                return ref;\n            }\n        };\n    }\n    // Although the EntityStore class is abstract, it contains concrete\n    // implementations of the various NormalizedCache interface methods that\n    // are inherited by the Root and Layer subclasses.\n    EntityStore.prototype.toObject = function () {\n        return __assign({}, this.data);\n    };\n    EntityStore.prototype.has = function (dataId) {\n        return this.lookup(dataId, true) !== void 0;\n    };\n    EntityStore.prototype.get = function (dataId, fieldName) {\n        this.group.depend(dataId, fieldName);\n        if (hasOwn.call(this.data, dataId)) {\n            var storeObject = this.data[dataId];\n            if (storeObject && hasOwn.call(storeObject, fieldName)) {\n                return storeObject[fieldName];\n            }\n        }\n        if (fieldName === \"__typename\" &&\n            hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n            return this.policies.rootTypenamesById[dataId];\n        }\n        if (this instanceof Layer) {\n            return this.parent.get(dataId, fieldName);\n        }\n    };\n    EntityStore.prototype.lookup = function (dataId, dependOnExistence) {\n        // The has method (above) calls lookup with dependOnExistence = true, so\n        // that it can later be invalidated when we add or remove a StoreObject for\n        // this dataId. Any consumer who cares about the contents of the StoreObject\n        // should not rely on this dependency, since the contents could change\n        // without the object being added or removed.\n        if (dependOnExistence)\n            this.group.depend(dataId, \"__exists\");\n        if (hasOwn.call(this.data, dataId)) {\n            return this.data[dataId];\n        }\n        if (this instanceof Layer) {\n            return this.parent.lookup(dataId, dependOnExistence);\n        }\n        if (this.policies.rootTypenamesById[dataId]) {\n            return Object.create(null);\n        }\n    };\n    EntityStore.prototype.merge = function (older, newer) {\n        var _this = this;\n        var dataId;\n        // Convert unexpected references to ID strings.\n        if (isReference(older))\n            older = older.__ref;\n        if (isReference(newer))\n            newer = newer.__ref;\n        var existing = typeof older === \"string\" ? this.lookup((dataId = older)) : older;\n        var incoming = typeof newer === \"string\" ? this.lookup((dataId = newer)) : newer;\n        // If newer was a string ID, but that ID was not defined in this store,\n        // then there are no fields to be merged, so we're done.\n        if (!incoming)\n            return;\n        invariant(typeof dataId === \"string\", 1);\n        var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);\n        // Even if merged === existing, existing may have come from a lower\n        // layer, so we always need to set this.data[dataId] on this level.\n        this.data[dataId] = merged;\n        if (merged !== existing) {\n            delete this.refs[dataId];\n            if (this.group.caching) {\n                var fieldsToDirty_1 = Object.create(null);\n                // If we added a new StoreObject where there was previously none, dirty\n                // anything that depended on the existence of this dataId, such as the\n                // EntityStore#has method.\n                if (!existing)\n                    fieldsToDirty_1.__exists = 1;\n                // Now invalidate dependents who called getFieldValue for any fields\n                // that are changing as a result of this merge.\n                Object.keys(incoming).forEach(function (storeFieldName) {\n                    if (!existing ||\n                        existing[storeFieldName] !== merged[storeFieldName]) {\n                        // Always dirty the full storeFieldName, which may include\n                        // serialized arguments following the fieldName prefix.\n                        fieldsToDirty_1[storeFieldName] = 1;\n                        // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n                        // different from storeFieldName and this field does not have\n                        // keyArgs configured, because that means the cache can't make\n                        // any assumptions about how field values with the same field\n                        // name but different arguments might be interrelated, so it\n                        // must err on the side of invalidating all field values that\n                        // share the same short fieldName, regardless of arguments.\n                        var fieldName = fieldNameFromStoreName(storeFieldName);\n                        if (fieldName !== storeFieldName &&\n                            !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n                            fieldsToDirty_1[fieldName] = 1;\n                        }\n                        // If merged[storeFieldName] has become undefined, and this is the\n                        // Root layer, actually delete the property from the merged object,\n                        // which is guaranteed to have been created fresh in this method.\n                        if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {\n                            delete merged[storeFieldName];\n                        }\n                    }\n                });\n                if (fieldsToDirty_1.__typename &&\n                    !(existing && existing.__typename) &&\n                    // Since we return default root __typename strings\n                    // automatically from store.get, we don't need to dirty the\n                    // ROOT_QUERY.__typename field if merged.__typename is equal\n                    // to the default string (usually \"Query\").\n                    this.policies.rootTypenamesById[dataId] === merged.__typename) {\n                    delete fieldsToDirty_1.__typename;\n                }\n                Object.keys(fieldsToDirty_1).forEach(function (fieldName) {\n                    return _this.group.dirty(dataId, fieldName);\n                });\n            }\n        }\n    };\n    EntityStore.prototype.modify = function (dataId, fields) {\n        var _this = this;\n        var storeObject = this.lookup(dataId);\n        if (storeObject) {\n            var changedFields_1 = Object.create(null);\n            var needToMerge_1 = false;\n            var allDeleted_1 = true;\n            var sharedDetails_1 = {\n                DELETE: DELETE,\n                INVALIDATE: INVALIDATE,\n                isReference: isReference,\n                toReference: this.toReference,\n                canRead: this.canRead,\n                readField: function (fieldNameOrOptions, from) {\n                    return _this.policies.readField(typeof fieldNameOrOptions === \"string\" ?\n                        {\n                            fieldName: fieldNameOrOptions,\n                            from: from || makeReference(dataId),\n                        }\n                        : fieldNameOrOptions, { store: _this });\n                },\n            };\n            Object.keys(storeObject).forEach(function (storeFieldName) {\n                var fieldName = fieldNameFromStoreName(storeFieldName);\n                var fieldValue = storeObject[storeFieldName];\n                if (fieldValue === void 0)\n                    return;\n                var modify = typeof fields === \"function\" ? fields : (fields[storeFieldName] || fields[fieldName]);\n                if (modify) {\n                    var newValue = modify === delModifier ? DELETE : (modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), { fieldName: fieldName, storeFieldName: storeFieldName, storage: _this.getStorage(dataId, storeFieldName) })));\n                    if (newValue === INVALIDATE) {\n                        _this.group.dirty(dataId, storeFieldName);\n                    }\n                    else {\n                        if (newValue === DELETE)\n                            newValue = void 0;\n                        if (newValue !== fieldValue) {\n                            changedFields_1[storeFieldName] = newValue;\n                            needToMerge_1 = true;\n                            fieldValue = newValue;\n                            if (globalThis.__DEV__ !== false) {\n                                var checkReference = function (ref) {\n                                    if (_this.lookup(ref.__ref) === undefined) {\n                                        globalThis.__DEV__ !== false && invariant.warn(2, ref);\n                                        return true;\n                                    }\n                                };\n                                if (isReference(newValue)) {\n                                    checkReference(newValue);\n                                }\n                                else if (Array.isArray(newValue)) {\n                                    // Warn about writing \"mixed\" arrays of Reference and non-Reference objects\n                                    var seenReference = false;\n                                    var someNonReference = void 0;\n                                    for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {\n                                        var value = newValue_1[_i];\n                                        if (isReference(value)) {\n                                            seenReference = true;\n                                            if (checkReference(value))\n                                                break;\n                                        }\n                                        else {\n                                            // Do not warn on primitive values, since those could never be represented\n                                            // by a reference. This is a valid (albeit uncommon) use case.\n                                            if (typeof value === \"object\" && !!value) {\n                                                var id = _this.policies.identify(value)[0];\n                                                // check if object could even be referenced, otherwise we are not interested in it for this warning\n                                                if (id) {\n                                                    someNonReference = value;\n                                                }\n                                            }\n                                        }\n                                        if (seenReference && someNonReference !== undefined) {\n                                            globalThis.__DEV__ !== false && invariant.warn(3, someNonReference);\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (fieldValue !== void 0) {\n                    allDeleted_1 = false;\n                }\n            });\n            if (needToMerge_1) {\n                this.merge(dataId, changedFields_1);\n                if (allDeleted_1) {\n                    if (this instanceof Layer) {\n                        this.data[dataId] = void 0;\n                    }\n                    else {\n                        delete this.data[dataId];\n                    }\n                    this.group.dirty(dataId, \"__exists\");\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    // If called with only one argument, removes the entire entity\n    // identified by dataId. If called with a fieldName as well, removes all\n    // fields of that entity whose names match fieldName according to the\n    // fieldNameFromStoreName helper function. If called with a fieldName\n    // and variables, removes all fields of that entity whose names match fieldName\n    // and whose arguments when cached exactly match the variables passed.\n    EntityStore.prototype.delete = function (dataId, fieldName, args) {\n        var _a;\n        var storeObject = this.lookup(dataId);\n        if (storeObject) {\n            var typename = this.getFieldValue(storeObject, \"__typename\");\n            var storeFieldName = fieldName && args ?\n                this.policies.getStoreFieldName({ typename: typename, fieldName: fieldName, args: args })\n                : fieldName;\n            return this.modify(dataId, storeFieldName ? (_a = {},\n                _a[storeFieldName] = delModifier,\n                _a) : delModifier);\n        }\n        return false;\n    };\n    EntityStore.prototype.evict = function (options, limit) {\n        var evicted = false;\n        if (options.id) {\n            if (hasOwn.call(this.data, options.id)) {\n                evicted = this.delete(options.id, options.fieldName, options.args);\n            }\n            if (this instanceof Layer && this !== limit) {\n                evicted = this.parent.evict(options, limit) || evicted;\n            }\n            // Always invalidate the field to trigger rereading of watched\n            // queries, even if no cache data was modified by the eviction,\n            // because queries may depend on computed fields with custom read\n            // functions, whose values are not stored in the EntityStore.\n            if (options.fieldName || evicted) {\n                this.group.dirty(options.id, options.fieldName || \"__exists\");\n            }\n        }\n        return evicted;\n    };\n    EntityStore.prototype.clear = function () {\n        this.replace(null);\n    };\n    EntityStore.prototype.extract = function () {\n        var _this = this;\n        var obj = this.toObject();\n        var extraRootIds = [];\n        this.getRootIdSet().forEach(function (id) {\n            if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {\n                extraRootIds.push(id);\n            }\n        });\n        if (extraRootIds.length) {\n            obj.__META = { extraRootIds: extraRootIds.sort() };\n        }\n        return obj;\n    };\n    EntityStore.prototype.replace = function (newData) {\n        var _this = this;\n        Object.keys(this.data).forEach(function (dataId) {\n            if (!(newData && hasOwn.call(newData, dataId))) {\n                _this.delete(dataId);\n            }\n        });\n        if (newData) {\n            var __META = newData.__META, rest_1 = __rest(newData, [\"__META\"]);\n            Object.keys(rest_1).forEach(function (dataId) {\n                _this.merge(dataId, rest_1[dataId]);\n            });\n            if (__META) {\n                __META.extraRootIds.forEach(this.retain, this);\n            }\n        }\n    };\n    EntityStore.prototype.retain = function (rootId) {\n        return (this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1);\n    };\n    EntityStore.prototype.release = function (rootId) {\n        if (this.rootIds[rootId] > 0) {\n            var count = --this.rootIds[rootId];\n            if (!count)\n                delete this.rootIds[rootId];\n            return count;\n        }\n        return 0;\n    };\n    // Return a Set<string> of all the ID strings that have been retained by\n    // this layer/root *and* any layers/roots beneath it.\n    EntityStore.prototype.getRootIdSet = function (ids) {\n        if (ids === void 0) { ids = new Set(); }\n        Object.keys(this.rootIds).forEach(ids.add, ids);\n        if (this instanceof Layer) {\n            this.parent.getRootIdSet(ids);\n        }\n        else {\n            // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n            // always considered roots for garbage collection, regardless of\n            // their retainment counts in this.rootIds.\n            Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n        }\n        return ids;\n    };\n    // The goal of garbage collection is to remove IDs from the Root layer of the\n    // store that are no longer reachable starting from any IDs that have been\n    // explicitly retained (see retain and release, above). Returns an array of\n    // dataId strings that were removed from the store.\n    EntityStore.prototype.gc = function () {\n        var _this = this;\n        var ids = this.getRootIdSet();\n        var snapshot = this.toObject();\n        ids.forEach(function (id) {\n            if (hasOwn.call(snapshot, id)) {\n                // Because we are iterating over an ECMAScript Set, the IDs we add here\n                // will be visited in later iterations of the forEach loop only if they\n                // were not previously contained by the Set.\n                Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);\n                // By removing IDs from the snapshot object here, we protect them from\n                // getting removed from the root store layer below.\n                delete snapshot[id];\n            }\n        });\n        var idsToRemove = Object.keys(snapshot);\n        if (idsToRemove.length) {\n            var root_1 = this;\n            while (root_1 instanceof Layer)\n                root_1 = root_1.parent;\n            idsToRemove.forEach(function (id) { return root_1.delete(id); });\n        }\n        return idsToRemove;\n    };\n    EntityStore.prototype.findChildRefIds = function (dataId) {\n        if (!hasOwn.call(this.refs, dataId)) {\n            var found_1 = (this.refs[dataId] = Object.create(null));\n            var root = this.data[dataId];\n            if (!root)\n                return found_1;\n            var workSet_1 = new Set([root]);\n            // Within the store, only arrays and objects can contain child entity\n            // references, so we can prune the traversal using this predicate:\n            workSet_1.forEach(function (obj) {\n                if (isReference(obj)) {\n                    found_1[obj.__ref] = true;\n                    // In rare cases, a { __ref } Reference object may have other fields.\n                    // This often indicates a mismerging of References with StoreObjects,\n                    // but garbage collection should not be fooled by a stray __ref\n                    // property in a StoreObject (ignoring all the other fields just\n                    // because the StoreObject looks like a Reference). To avoid this\n                    // premature termination of findChildRefIds recursion, we fall through\n                    // to the code below, which will handle any other properties of obj.\n                }\n                if (isNonNullObject(obj)) {\n                    Object.keys(obj).forEach(function (key) {\n                        var child = obj[key];\n                        // No need to add primitive values to the workSet, since they cannot\n                        // contain reference objects.\n                        if (isNonNullObject(child)) {\n                            workSet_1.add(child);\n                        }\n                    });\n                }\n            });\n        }\n        return this.refs[dataId];\n    };\n    EntityStore.prototype.makeCacheKey = function () {\n        return this.group.keyMaker.lookupArray(arguments);\n    };\n    return EntityStore;\n}());\nexport { EntityStore };\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nvar CacheGroup = /** @class */ (function () {\n    function CacheGroup(caching, parent) {\n        if (parent === void 0) { parent = null; }\n        this.caching = caching;\n        this.parent = parent;\n        this.d = null;\n        this.resetCaching();\n    }\n    CacheGroup.prototype.resetCaching = function () {\n        this.d = this.caching ? dep() : null;\n        this.keyMaker = new Trie(canUseWeakMap);\n    };\n    CacheGroup.prototype.depend = function (dataId, storeFieldName) {\n        if (this.d) {\n            this.d(makeDepKey(dataId, storeFieldName));\n            var fieldName = fieldNameFromStoreName(storeFieldName);\n            if (fieldName !== storeFieldName) {\n                // Fields with arguments that contribute extra identifying\n                // information to the fieldName (thus forming the storeFieldName)\n                // depend not only on the full storeFieldName but also on the\n                // short fieldName, so the field can be invalidated using either\n                // level of specificity.\n                this.d(makeDepKey(dataId, fieldName));\n            }\n            if (this.parent) {\n                this.parent.depend(dataId, storeFieldName);\n            }\n        }\n    };\n    CacheGroup.prototype.dirty = function (dataId, storeFieldName) {\n        if (this.d) {\n            this.d.dirty(makeDepKey(dataId, storeFieldName), \n            // When storeFieldName === \"__exists\", that means the entity identified\n            // by dataId has either disappeared from the cache or was newly added,\n            // so the result caching system would do well to \"forget everything it\n            // knows\" about that object. To achieve that kind of invalidation, we\n            // not only dirty the associated result cache entry, but also remove it\n            // completely from the dependency graph. For the optimism implementation\n            // details, see https://github.com/benjamn/optimism/pull/195.\n            storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\");\n        }\n    };\n    return CacheGroup;\n}());\nfunction makeDepKey(dataId, storeFieldName) {\n    // Since field names cannot have '#' characters in them, this method\n    // of joining the field name and the ID should be unambiguous, and much\n    // cheaper than JSON.stringify([dataId, fieldName]).\n    return storeFieldName + \"#\" + dataId;\n}\nexport function maybeDependOnExistenceOfEntity(store, entityId) {\n    if (supportsResultCaching(store)) {\n        // We use this pseudo-field __exists elsewhere in the EntityStore code to\n        // represent changes in the existence of the entity object identified by\n        // entityId. This dependency gets reliably dirtied whenever an object with\n        // this ID is deleted (or newly created) within this group, so any result\n        // cache entries (for example, StoreReader#executeSelectionSet results) that\n        // depend on __exists for this entityId will get dirtied as well, leading to\n        // the eventual recomputation (instead of reuse) of those result objects the\n        // next time someone reads them from the cache.\n        store.group.depend(entityId, \"__exists\");\n    }\n}\n(function (EntityStore) {\n    // Refer to this class as EntityStore.Root outside this namespace.\n    var Root = /** @class */ (function (_super) {\n        __extends(Root, _super);\n        function Root(_a) {\n            var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;\n            var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;\n            _this.stump = new Stump(_this);\n            _this.storageTrie = new Trie(canUseWeakMap);\n            if (seed)\n                _this.replace(seed);\n            return _this;\n        }\n        Root.prototype.addLayer = function (layerId, replay) {\n            // Adding an optimistic Layer on top of the Root actually adds the Layer\n            // on top of the Stump, so the Stump always comes between the Root and\n            // any Layer objects that we've added.\n            return this.stump.addLayer(layerId, replay);\n        };\n        Root.prototype.removeLayer = function () {\n            // Never remove the root layer.\n            return this;\n        };\n        Root.prototype.getStorage = function () {\n            return this.storageTrie.lookupArray(arguments);\n        };\n        return Root;\n    }(EntityStore));\n    EntityStore.Root = Root;\n})(EntityStore || (EntityStore = {}));\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nvar Layer = /** @class */ (function (_super) {\n    __extends(Layer, _super);\n    function Layer(id, parent, replay, group) {\n        var _this = _super.call(this, parent.policies, group) || this;\n        _this.id = id;\n        _this.parent = parent;\n        _this.replay = replay;\n        _this.group = group;\n        replay(_this);\n        return _this;\n    }\n    Layer.prototype.addLayer = function (layerId, replay) {\n        return new Layer(layerId, this, replay, this.group);\n    };\n    Layer.prototype.removeLayer = function (layerId) {\n        var _this = this;\n        // Remove all instances of the given id, not just the first one.\n        var parent = this.parent.removeLayer(layerId);\n        if (layerId === this.id) {\n            if (this.group.caching) {\n                // Dirty every ID we're removing. Technically we might be able to avoid\n                // dirtying fields that have values in higher layers, but we don't have\n                // easy access to higher layers here, and we're about to recreate those\n                // layers anyway (see parent.addLayer below).\n                Object.keys(this.data).forEach(function (dataId) {\n                    var ownStoreObject = _this.data[dataId];\n                    var parentStoreObject = parent[\"lookup\"](dataId);\n                    if (!parentStoreObject) {\n                        // The StoreObject identified by dataId was defined in this layer\n                        // but will be undefined in the parent layer, so we can delete the\n                        // whole entity using this.delete(dataId). Since we're about to\n                        // throw this layer away, the only goal of this deletion is to dirty\n                        // the removed fields.\n                        _this.delete(dataId);\n                    }\n                    else if (!ownStoreObject) {\n                        // This layer had an entry for dataId but it was undefined, which\n                        // means the entity was deleted in this layer, and it's about to\n                        // become undeleted when we remove this layer, so we need to dirty\n                        // all fields that are about to be reexposed.\n                        _this.group.dirty(dataId, \"__exists\");\n                        Object.keys(parentStoreObject).forEach(function (storeFieldName) {\n                            _this.group.dirty(dataId, storeFieldName);\n                        });\n                    }\n                    else if (ownStoreObject !== parentStoreObject) {\n                        // If ownStoreObject is not exactly the same as parentStoreObject,\n                        // dirty any fields whose values will change as a result of this\n                        // removal.\n                        Object.keys(ownStoreObject).forEach(function (storeFieldName) {\n                            if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {\n                                _this.group.dirty(dataId, storeFieldName);\n                            }\n                        });\n                    }\n                });\n            }\n            return parent;\n        }\n        // No changes are necessary if the parent chain remains identical.\n        if (parent === this.parent)\n            return this;\n        // Recreate this layer on top of the new parent.\n        return parent.addLayer(this.id, this.replay);\n    };\n    Layer.prototype.toObject = function () {\n        return __assign(__assign({}, this.parent.toObject()), this.data);\n    };\n    Layer.prototype.findChildRefIds = function (dataId) {\n        var fromParent = this.parent.findChildRefIds(dataId);\n        return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;\n    };\n    Layer.prototype.getStorage = function () {\n        var p = this.parent;\n        while (p.parent)\n            p = p.parent;\n        return p.getStorage.apply(p, \n        // @ts-expect-error\n        arguments);\n    };\n    return Layer;\n}(EntityStore));\n// Represents a Layer permanently installed just above the Root, which allows\n// reading optimistically (and registering optimistic dependencies) even when\n// no optimistic layers are currently active. The stump.group CacheGroup object\n// is shared by any/all Layer objects added on top of the Stump.\nvar Stump = /** @class */ (function (_super) {\n    __extends(Stump, _super);\n    function Stump(root) {\n        return _super.call(this, \"EntityStore.Stump\", root, function () { }, new CacheGroup(root.group.caching, root.group)) || this;\n    }\n    Stump.prototype.removeLayer = function () {\n        // Never remove the Stump layer.\n        return this;\n    };\n    Stump.prototype.merge = function (older, newer) {\n        // We never want to write any data into the Stump, so we forward any merge\n        // calls to the Root instead. Another option here would be to throw an\n        // exception, but the toReference(object, true) function can sometimes\n        // trigger Stump writes (which used to be Root writes, before the Stump\n        // concept was introduced).\n        return this.parent.merge(older, newer);\n    };\n    return Stump;\n}(Layer));\nfunction storeObjectReconciler(existingObject, incomingObject, property) {\n    var existingValue = existingObject[property];\n    var incomingValue = incomingObject[property];\n    // Wherever there is a key collision, prefer the incoming value, unless\n    // it is deeply equal to the existing value. It's worth checking deep\n    // equality here (even though blindly returning incoming would be\n    // logically correct) because preserving the referential identity of\n    // existing data can prevent needless rereading and rerendering.\n    return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\nexport function supportsResultCaching(store) {\n    // When result caching is disabled, store.depend will be null.\n    return !!(store instanceof EntityStore && store.group.caching);\n}\n//# sourceMappingURL=entityStore.js.map",
      "start": 1712968597722,
      "end": 1712968597729,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "pre"
    },
    {
      "name": "content-slot",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "graphql",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1712968597729,
      "end": 1712968597729,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1712968597729,
      "end": 1712968597730,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { __assign, __extends, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { dep } from \"optimism\";\nimport { equal } from \"@wry/equality\";\nimport { Trie } from \"@wry/trie\";\nimport { isReference, makeReference, DeepMerger, maybeDeepFreeze, canUseWeakMap, isNonNullObject } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName } from \"./helpers.js\";\nvar DELETE = /* @__PURE__ */ Object.create(null);\nvar delModifier = function() {\n  return DELETE;\n};\nvar INVALIDATE = /* @__PURE__ */ Object.create(null);\nvar EntityStore = (\n  /** @class */\n  function() {\n    function EntityStore2(policies, group) {\n      var _this = this;\n      this.policies = policies;\n      this.group = group;\n      this.data = /* @__PURE__ */ Object.create(null);\n      this.rootIds = /* @__PURE__ */ Object.create(null);\n      this.refs = /* @__PURE__ */ Object.create(null);\n      this.getFieldValue = function(objectOrReference, storeFieldName) {\n        return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);\n      };\n      this.canRead = function(objOrRef) {\n        return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === \"object\";\n      };\n      this.toReference = function(objOrIdOrRef, mergeIntoStore) {\n        if (typeof objOrIdOrRef === \"string\") {\n          return makeReference(objOrIdOrRef);\n        }\n        if (isReference(objOrIdOrRef)) {\n          return objOrIdOrRef;\n        }\n        var id = _this.policies.identify(objOrIdOrRef)[0];\n        if (id) {\n          var ref = makeReference(id);\n          if (mergeIntoStore) {\n            _this.merge(id, objOrIdOrRef);\n          }\n          return ref;\n        }\n      };\n    }\n    EntityStore2.prototype.toObject = function() {\n      return __assign({}, this.data);\n    };\n    EntityStore2.prototype.has = function(dataId) {\n      return this.lookup(dataId, true) !== void 0;\n    };\n    EntityStore2.prototype.get = function(dataId, fieldName) {\n      this.group.depend(dataId, fieldName);\n      if (hasOwn.call(this.data, dataId)) {\n        var storeObject = this.data[dataId];\n        if (storeObject && hasOwn.call(storeObject, fieldName)) {\n          return storeObject[fieldName];\n        }\n      }\n      if (fieldName === \"__typename\" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n        return this.policies.rootTypenamesById[dataId];\n      }\n      if (this instanceof Layer) {\n        return this.parent.get(dataId, fieldName);\n      }\n    };\n    EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {\n      if (dependOnExistence)\n        this.group.depend(dataId, \"__exists\");\n      if (hasOwn.call(this.data, dataId)) {\n        return this.data[dataId];\n      }\n      if (this instanceof Layer) {\n        return this.parent.lookup(dataId, dependOnExistence);\n      }\n      if (this.policies.rootTypenamesById[dataId]) {\n        return /* @__PURE__ */ Object.create(null);\n      }\n    };\n    EntityStore2.prototype.merge = function(older, newer) {\n      var _this = this;\n      var dataId;\n      if (isReference(older))\n        older = older.__ref;\n      if (isReference(newer))\n        newer = newer.__ref;\n      var existing = typeof older === \"string\" ? this.lookup(dataId = older) : older;\n      var incoming = typeof newer === \"string\" ? this.lookup(dataId = newer) : newer;\n      if (!incoming)\n        return;\n      invariant(typeof dataId === \"string\", 1);\n      var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);\n      this.data[dataId] = merged;\n      if (merged !== existing) {\n        delete this.refs[dataId];\n        if (this.group.caching) {\n          var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);\n          if (!existing)\n            fieldsToDirty_1.__exists = 1;\n          Object.keys(incoming).forEach(function(storeFieldName) {\n            if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {\n              fieldsToDirty_1[storeFieldName] = 1;\n              var fieldName = fieldNameFromStoreName(storeFieldName);\n              if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n                fieldsToDirty_1[fieldName] = 1;\n              }\n              if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {\n                delete merged[storeFieldName];\n              }\n            }\n          });\n          if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && // Since we return default root __typename strings\n          // automatically from store.get, we don't need to dirty the\n          // ROOT_QUERY.__typename field if merged.__typename is equal\n          // to the default string (usually \"Query\").\n          this.policies.rootTypenamesById[dataId] === merged.__typename) {\n            delete fieldsToDirty_1.__typename;\n          }\n          Object.keys(fieldsToDirty_1).forEach(function(fieldName) {\n            return _this.group.dirty(dataId, fieldName);\n          });\n        }\n      }\n    };\n    EntityStore2.prototype.modify = function(dataId, fields) {\n      var _this = this;\n      var storeObject = this.lookup(dataId);\n      if (storeObject) {\n        var changedFields_1 = /* @__PURE__ */ Object.create(null);\n        var needToMerge_1 = false;\n        var allDeleted_1 = true;\n        var sharedDetails_1 = {\n          DELETE,\n          INVALIDATE,\n          isReference,\n          toReference: this.toReference,\n          canRead: this.canRead,\n          readField: function(fieldNameOrOptions, from) {\n            return _this.policies.readField(typeof fieldNameOrOptions === \"string\" ? {\n              fieldName: fieldNameOrOptions,\n              from: from || makeReference(dataId)\n            } : fieldNameOrOptions, { store: _this });\n          }\n        };\n        Object.keys(storeObject).forEach(function(storeFieldName) {\n          var fieldName = fieldNameFromStoreName(storeFieldName);\n          var fieldValue = storeObject[storeFieldName];\n          if (fieldValue === void 0)\n            return;\n          var modify = typeof fields === \"function\" ? fields : fields[storeFieldName] || fields[fieldName];\n          if (modify) {\n            var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));\n            if (newValue === INVALIDATE) {\n              _this.group.dirty(dataId, storeFieldName);\n            } else {\n              if (newValue === DELETE)\n                newValue = void 0;\n              if (newValue !== fieldValue) {\n                changedFields_1[storeFieldName] = newValue;\n                needToMerge_1 = true;\n                fieldValue = newValue;\n                if (globalThis.__DEV__ !== false) {\n                  var checkReference = function(ref) {\n                    if (_this.lookup(ref.__ref) === void 0) {\n                      globalThis.__DEV__ !== false && invariant.warn(2, ref);\n                      return true;\n                    }\n                  };\n                  if (isReference(newValue)) {\n                    checkReference(newValue);\n                  } else if (Array.isArray(newValue)) {\n                    var seenReference = false;\n                    var someNonReference = void 0;\n                    for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {\n                      var value = newValue_1[_i];\n                      if (isReference(value)) {\n                        seenReference = true;\n                        if (checkReference(value))\n                          break;\n                      } else {\n                        if (typeof value === \"object\" && !!value) {\n                          var id = _this.policies.identify(value)[0];\n                          if (id) {\n                            someNonReference = value;\n                          }\n                        }\n                      }\n                      if (seenReference && someNonReference !== void 0) {\n                        globalThis.__DEV__ !== false && invariant.warn(3, someNonReference);\n                        break;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if (fieldValue !== void 0) {\n            allDeleted_1 = false;\n          }\n        });\n        if (needToMerge_1) {\n          this.merge(dataId, changedFields_1);\n          if (allDeleted_1) {\n            if (this instanceof Layer) {\n              this.data[dataId] = void 0;\n            } else {\n              delete this.data[dataId];\n            }\n            this.group.dirty(dataId, \"__exists\");\n          }\n          return true;\n        }\n      }\n      return false;\n    };\n    EntityStore2.prototype.delete = function(dataId, fieldName, args) {\n      var _a;\n      var storeObject = this.lookup(dataId);\n      if (storeObject) {\n        var typename = this.getFieldValue(storeObject, \"__typename\");\n        var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;\n        return this.modify(dataId, storeFieldName ? (_a = {}, _a[storeFieldName] = delModifier, _a) : delModifier);\n      }\n      return false;\n    };\n    EntityStore2.prototype.evict = function(options, limit) {\n      var evicted = false;\n      if (options.id) {\n        if (hasOwn.call(this.data, options.id)) {\n          evicted = this.delete(options.id, options.fieldName, options.args);\n        }\n        if (this instanceof Layer && this !== limit) {\n          evicted = this.parent.evict(options, limit) || evicted;\n        }\n        if (options.fieldName || evicted) {\n          this.group.dirty(options.id, options.fieldName || \"__exists\");\n        }\n      }\n      return evicted;\n    };\n    EntityStore2.prototype.clear = function() {\n      this.replace(null);\n    };\n    EntityStore2.prototype.extract = function() {\n      var _this = this;\n      var obj = this.toObject();\n      var extraRootIds = [];\n      this.getRootIdSet().forEach(function(id) {\n        if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {\n          extraRootIds.push(id);\n        }\n      });\n      if (extraRootIds.length) {\n        obj.__META = { extraRootIds: extraRootIds.sort() };\n      }\n      return obj;\n    };\n    EntityStore2.prototype.replace = function(newData) {\n      var _this = this;\n      Object.keys(this.data).forEach(function(dataId) {\n        if (!(newData && hasOwn.call(newData, dataId))) {\n          _this.delete(dataId);\n        }\n      });\n      if (newData) {\n        var __META = newData.__META, rest_1 = __rest(newData, [\"__META\"]);\n        Object.keys(rest_1).forEach(function(dataId) {\n          _this.merge(dataId, rest_1[dataId]);\n        });\n        if (__META) {\n          __META.extraRootIds.forEach(this.retain, this);\n        }\n      }\n    };\n    EntityStore2.prototype.retain = function(rootId) {\n      return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;\n    };\n    EntityStore2.prototype.release = function(rootId) {\n      if (this.rootIds[rootId] > 0) {\n        var count = --this.rootIds[rootId];\n        if (!count)\n          delete this.rootIds[rootId];\n        return count;\n      }\n      return 0;\n    };\n    EntityStore2.prototype.getRootIdSet = function(ids) {\n      if (ids === void 0) {\n        ids = /* @__PURE__ */ new Set();\n      }\n      Object.keys(this.rootIds).forEach(ids.add, ids);\n      if (this instanceof Layer) {\n        this.parent.getRootIdSet(ids);\n      } else {\n        Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n      }\n      return ids;\n    };\n    EntityStore2.prototype.gc = function() {\n      var _this = this;\n      var ids = this.getRootIdSet();\n      var snapshot = this.toObject();\n      ids.forEach(function(id) {\n        if (hasOwn.call(snapshot, id)) {\n          Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);\n          delete snapshot[id];\n        }\n      });\n      var idsToRemove = Object.keys(snapshot);\n      if (idsToRemove.length) {\n        var root_1 = this;\n        while (root_1 instanceof Layer)\n          root_1 = root_1.parent;\n        idsToRemove.forEach(function(id) {\n          return root_1.delete(id);\n        });\n      }\n      return idsToRemove;\n    };\n    EntityStore2.prototype.findChildRefIds = function(dataId) {\n      if (!hasOwn.call(this.refs, dataId)) {\n        var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);\n        var root = this.data[dataId];\n        if (!root)\n          return found_1;\n        var workSet_1 = /* @__PURE__ */ new Set([root]);\n        workSet_1.forEach(function(obj) {\n          if (isReference(obj)) {\n            found_1[obj.__ref] = true;\n          }\n          if (isNonNullObject(obj)) {\n            Object.keys(obj).forEach(function(key) {\n              var child = obj[key];\n              if (isNonNullObject(child)) {\n                workSet_1.add(child);\n              }\n            });\n          }\n        });\n      }\n      return this.refs[dataId];\n    };\n    EntityStore2.prototype.makeCacheKey = function() {\n      return this.group.keyMaker.lookupArray(arguments);\n    };\n    return EntityStore2;\n  }()\n);\nexport { EntityStore };\nvar CacheGroup = (\n  /** @class */\n  function() {\n    function CacheGroup2(caching, parent) {\n      if (parent === void 0) {\n        parent = null;\n      }\n      this.caching = caching;\n      this.parent = parent;\n      this.d = null;\n      this.resetCaching();\n    }\n    CacheGroup2.prototype.resetCaching = function() {\n      this.d = this.caching ? dep() : null;\n      this.keyMaker = new Trie(canUseWeakMap);\n    };\n    CacheGroup2.prototype.depend = function(dataId, storeFieldName) {\n      if (this.d) {\n        this.d(makeDepKey(dataId, storeFieldName));\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        if (fieldName !== storeFieldName) {\n          this.d(makeDepKey(dataId, fieldName));\n        }\n        if (this.parent) {\n          this.parent.depend(dataId, storeFieldName);\n        }\n      }\n    };\n    CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {\n      if (this.d) {\n        this.d.dirty(\n          makeDepKey(dataId, storeFieldName),\n          // When storeFieldName === \"__exists\", that means the entity identified\n          // by dataId has either disappeared from the cache or was newly added,\n          // so the result caching system would do well to \"forget everything it\n          // knows\" about that object. To achieve that kind of invalidation, we\n          // not only dirty the associated result cache entry, but also remove it\n          // completely from the dependency graph. For the optimism implementation\n          // details, see https://github.com/benjamn/optimism/pull/195.\n          storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\"\n        );\n      }\n    };\n    return CacheGroup2;\n  }()\n);\nfunction makeDepKey(dataId, storeFieldName) {\n  return storeFieldName + \"#\" + dataId;\n}\nexport function maybeDependOnExistenceOfEntity(store, entityId) {\n  if (supportsResultCaching(store)) {\n    store.group.depend(entityId, \"__exists\");\n  }\n}\n(function(EntityStore2) {\n  var Root = (\n    /** @class */\n    function(_super) {\n      __extends(Root2, _super);\n      function Root2(_a) {\n        var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;\n        var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;\n        _this.stump = new Stump(_this);\n        _this.storageTrie = new Trie(canUseWeakMap);\n        if (seed)\n          _this.replace(seed);\n        return _this;\n      }\n      Root2.prototype.addLayer = function(layerId, replay) {\n        return this.stump.addLayer(layerId, replay);\n      };\n      Root2.prototype.removeLayer = function() {\n        return this;\n      };\n      Root2.prototype.getStorage = function() {\n        return this.storageTrie.lookupArray(arguments);\n      };\n      return Root2;\n    }(EntityStore2)\n  );\n  EntityStore2.Root = Root;\n})(EntityStore || (EntityStore = {}));\nvar Layer = (\n  /** @class */\n  function(_super) {\n    __extends(Layer2, _super);\n    function Layer2(id, parent, replay, group) {\n      var _this = _super.call(this, parent.policies, group) || this;\n      _this.id = id;\n      _this.parent = parent;\n      _this.replay = replay;\n      _this.group = group;\n      replay(_this);\n      return _this;\n    }\n    Layer2.prototype.addLayer = function(layerId, replay) {\n      return new Layer2(layerId, this, replay, this.group);\n    };\n    Layer2.prototype.removeLayer = function(layerId) {\n      var _this = this;\n      var parent = this.parent.removeLayer(layerId);\n      if (layerId === this.id) {\n        if (this.group.caching) {\n          Object.keys(this.data).forEach(function(dataId) {\n            var ownStoreObject = _this.data[dataId];\n            var parentStoreObject = parent[\"lookup\"](dataId);\n            if (!parentStoreObject) {\n              _this.delete(dataId);\n            } else if (!ownStoreObject) {\n              _this.group.dirty(dataId, \"__exists\");\n              Object.keys(parentStoreObject).forEach(function(storeFieldName) {\n                _this.group.dirty(dataId, storeFieldName);\n              });\n            } else if (ownStoreObject !== parentStoreObject) {\n              Object.keys(ownStoreObject).forEach(function(storeFieldName) {\n                if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {\n                  _this.group.dirty(dataId, storeFieldName);\n                }\n              });\n            }\n          });\n        }\n        return parent;\n      }\n      if (parent === this.parent)\n        return this;\n      return parent.addLayer(this.id, this.replay);\n    };\n    Layer2.prototype.toObject = function() {\n      return __assign(__assign({}, this.parent.toObject()), this.data);\n    };\n    Layer2.prototype.findChildRefIds = function(dataId) {\n      var fromParent = this.parent.findChildRefIds(dataId);\n      return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;\n    };\n    Layer2.prototype.getStorage = function() {\n      var p = this.parent;\n      while (p.parent)\n        p = p.parent;\n      return p.getStorage.apply(\n        p,\n        // @ts-expect-error\n        arguments\n      );\n    };\n    return Layer2;\n  }(EntityStore)\n);\nvar Stump = (\n  /** @class */\n  function(_super) {\n    __extends(Stump2, _super);\n    function Stump2(root) {\n      return _super.call(this, \"EntityStore.Stump\", root, function() {\n      }, new CacheGroup(root.group.caching, root.group)) || this;\n    }\n    Stump2.prototype.removeLayer = function() {\n      return this;\n    };\n    Stump2.prototype.merge = function(older, newer) {\n      return this.parent.merge(older, newer);\n    };\n    return Stump2;\n  }(Layer)\n);\nfunction storeObjectReconciler(existingObject, incomingObject, property) {\n  var existingValue = existingObject[property];\n  var incomingValue = incomingObject[property];\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\nexport function supportsResultCaching(store) {\n  return !!(store instanceof EntityStore && store.group.caching);\n}\n",
      "start": 1712968597730,
      "end": 1712968598067,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"/Users/shubhamsingh/namma/importedProds/node_modules/@apollo/client/cache/inmemory/entityStore.js\"],\n  \"sourcesContent\": [\"import { __assign, __extends, __rest } from \\\"tslib\\\";\\nimport { invariant } from \\\"../../utilities/globals/index.js\\\";\\nimport { dep } from \\\"optimism\\\";\\nimport { equal } from \\\"@wry/equality\\\";\\nimport { Trie } from \\\"@wry/trie\\\";\\nimport { isReference, makeReference, DeepMerger, maybeDeepFreeze, canUseWeakMap, isNonNullObject, } from \\\"../../utilities/index.js\\\";\\nimport { hasOwn, fieldNameFromStoreName } from \\\"./helpers.js\\\";\\nvar DELETE = Object.create(null);\\nvar delModifier = function () { return DELETE; };\\nvar INVALIDATE = Object.create(null);\\nvar EntityStore = /** @class */ (function () {\\n    function EntityStore(policies, group) {\\n        var _this = this;\\n        this.policies = policies;\\n        this.group = group;\\n        this.data = Object.create(null);\\n        // Maps root entity IDs to the number of times they have been retained, minus\\n        // the number of times they have been released. Retained entities keep other\\n        // entities they reference (even indirectly) from being garbage collected.\\n        this.rootIds = Object.create(null);\\n        // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\\n        this.refs = Object.create(null);\\n        // Bound function that can be passed around to provide easy access to fields\\n        // of Reference objects as well as ordinary objects.\\n        this.getFieldValue = function (objectOrReference, storeFieldName) {\\n            return maybeDeepFreeze(isReference(objectOrReference) ?\\n                _this.get(objectOrReference.__ref, storeFieldName)\\n                : objectOrReference && objectOrReference[storeFieldName]);\\n        };\\n        // Returns true for non-normalized StoreObjects and non-dangling\\n        // References, indicating that readField(name, objOrRef) has a chance of\\n        // working. Useful for filtering out dangling references from lists.\\n        this.canRead = function (objOrRef) {\\n            return isReference(objOrRef) ?\\n                _this.has(objOrRef.__ref)\\n                : typeof objOrRef === \\\"object\\\";\\n        };\\n        // Bound function that converts an id or an object with a __typename and\\n        // primary key fields to a Reference object. If called with a Reference object,\\n        // that same Reference object is returned. Pass true for mergeIntoStore to persist\\n        // an object into the store.\\n        this.toReference = function (objOrIdOrRef, mergeIntoStore) {\\n            if (typeof objOrIdOrRef === \\\"string\\\") {\\n                return makeReference(objOrIdOrRef);\\n            }\\n            if (isReference(objOrIdOrRef)) {\\n                return objOrIdOrRef;\\n            }\\n            var id = _this.policies.identify(objOrIdOrRef)[0];\\n            if (id) {\\n                var ref = makeReference(id);\\n                if (mergeIntoStore) {\\n                    _this.merge(id, objOrIdOrRef);\\n                }\\n                return ref;\\n            }\\n        };\\n    }\\n    // Although the EntityStore class is abstract, it contains concrete\\n    // implementations of the various NormalizedCache interface methods that\\n    // are inherited by the Root and Layer subclasses.\\n    EntityStore.prototype.toObject = function () {\\n        return __assign({}, this.data);\\n    };\\n    EntityStore.prototype.has = function (dataId) {\\n        return this.lookup(dataId, true) !== void 0;\\n    };\\n    EntityStore.prototype.get = function (dataId, fieldName) {\\n        this.group.depend(dataId, fieldName);\\n        if (hasOwn.call(this.data, dataId)) {\\n            var storeObject = this.data[dataId];\\n            if (storeObject && hasOwn.call(storeObject, fieldName)) {\\n                return storeObject[fieldName];\\n            }\\n        }\\n        if (fieldName === \\\"__typename\\\" &&\\n            hasOwn.call(this.policies.rootTypenamesById, dataId)) {\\n            return this.policies.rootTypenamesById[dataId];\\n        }\\n        if (this instanceof Layer) {\\n            return this.parent.get(dataId, fieldName);\\n        }\\n    };\\n    EntityStore.prototype.lookup = function (dataId, dependOnExistence) {\\n        // The has method (above) calls lookup with dependOnExistence = true, so\\n        // that it can later be invalidated when we add or remove a StoreObject for\\n        // this dataId. Any consumer who cares about the contents of the StoreObject\\n        // should not rely on this dependency, since the contents could change\\n        // without the object being added or removed.\\n        if (dependOnExistence)\\n            this.group.depend(dataId, \\\"__exists\\\");\\n        if (hasOwn.call(this.data, dataId)) {\\n            return this.data[dataId];\\n        }\\n        if (this instanceof Layer) {\\n            return this.parent.lookup(dataId, dependOnExistence);\\n        }\\n        if (this.policies.rootTypenamesById[dataId]) {\\n            return Object.create(null);\\n        }\\n    };\\n    EntityStore.prototype.merge = function (older, newer) {\\n        var _this = this;\\n        var dataId;\\n        // Convert unexpected references to ID strings.\\n        if (isReference(older))\\n            older = older.__ref;\\n        if (isReference(newer))\\n            newer = newer.__ref;\\n        var existing = typeof older === \\\"string\\\" ? this.lookup((dataId = older)) : older;\\n        var incoming = typeof newer === \\\"string\\\" ? this.lookup((dataId = newer)) : newer;\\n        // If newer was a string ID, but that ID was not defined in this store,\\n        // then there are no fields to be merged, so we're done.\\n        if (!incoming)\\n            return;\\n        invariant(typeof dataId === \\\"string\\\", 1);\\n        var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);\\n        // Even if merged === existing, existing may have come from a lower\\n        // layer, so we always need to set this.data[dataId] on this level.\\n        this.data[dataId] = merged;\\n        if (merged !== existing) {\\n            delete this.refs[dataId];\\n            if (this.group.caching) {\\n                var fieldsToDirty_1 = Object.create(null);\\n                // If we added a new StoreObject where there was previously none, dirty\\n                // anything that depended on the existence of this dataId, such as the\\n                // EntityStore#has method.\\n                if (!existing)\\n                    fieldsToDirty_1.__exists = 1;\\n                // Now invalidate dependents who called getFieldValue for any fields\\n                // that are changing as a result of this merge.\\n                Object.keys(incoming).forEach(function (storeFieldName) {\\n                    if (!existing ||\\n                        existing[storeFieldName] !== merged[storeFieldName]) {\\n                        // Always dirty the full storeFieldName, which may include\\n                        // serialized arguments following the fieldName prefix.\\n                        fieldsToDirty_1[storeFieldName] = 1;\\n                        // Also dirty fieldNameFromStoreName(storeFieldName) if it's\\n                        // different from storeFieldName and this field does not have\\n                        // keyArgs configured, because that means the cache can't make\\n                        // any assumptions about how field values with the same field\\n                        // name but different arguments might be interrelated, so it\\n                        // must err on the side of invalidating all field values that\\n                        // share the same short fieldName, regardless of arguments.\\n                        var fieldName = fieldNameFromStoreName(storeFieldName);\\n                        if (fieldName !== storeFieldName &&\\n                            !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {\\n                            fieldsToDirty_1[fieldName] = 1;\\n                        }\\n                        // If merged[storeFieldName] has become undefined, and this is the\\n                        // Root layer, actually delete the property from the merged object,\\n                        // which is guaranteed to have been created fresh in this method.\\n                        if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {\\n                            delete merged[storeFieldName];\\n                        }\\n                    }\\n                });\\n                if (fieldsToDirty_1.__typename &&\\n                    !(existing && existing.__typename) &&\\n                    // Since we return default root __typename strings\\n                    // automatically from store.get, we don't need to dirty the\\n                    // ROOT_QUERY.__typename field if merged.__typename is equal\\n                    // to the default string (usually \\\"Query\\\").\\n                    this.policies.rootTypenamesById[dataId] === merged.__typename) {\\n                    delete fieldsToDirty_1.__typename;\\n                }\\n                Object.keys(fieldsToDirty_1).forEach(function (fieldName) {\\n                    return _this.group.dirty(dataId, fieldName);\\n                });\\n            }\\n        }\\n    };\\n    EntityStore.prototype.modify = function (dataId, fields) {\\n        var _this = this;\\n        var storeObject = this.lookup(dataId);\\n        if (storeObject) {\\n            var changedFields_1 = Object.create(null);\\n            var needToMerge_1 = false;\\n            var allDeleted_1 = true;\\n            var sharedDetails_1 = {\\n                DELETE: DELETE,\\n                INVALIDATE: INVALIDATE,\\n                isReference: isReference,\\n                toReference: this.toReference,\\n                canRead: this.canRead,\\n                readField: function (fieldNameOrOptions, from) {\\n                    return _this.policies.readField(typeof fieldNameOrOptions === \\\"string\\\" ?\\n                        {\\n                            fieldName: fieldNameOrOptions,\\n                            from: from || makeReference(dataId),\\n                        }\\n                        : fieldNameOrOptions, { store: _this });\\n                },\\n            };\\n            Object.keys(storeObject).forEach(function (storeFieldName) {\\n                var fieldName = fieldNameFromStoreName(storeFieldName);\\n                var fieldValue = storeObject[storeFieldName];\\n                if (fieldValue === void 0)\\n                    return;\\n                var modify = typeof fields === \\\"function\\\" ? fields : (fields[storeFieldName] || fields[fieldName]);\\n                if (modify) {\\n                    var newValue = modify === delModifier ? DELETE : (modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), { fieldName: fieldName, storeFieldName: storeFieldName, storage: _this.getStorage(dataId, storeFieldName) })));\\n                    if (newValue === INVALIDATE) {\\n                        _this.group.dirty(dataId, storeFieldName);\\n                    }\\n                    else {\\n                        if (newValue === DELETE)\\n                            newValue = void 0;\\n                        if (newValue !== fieldValue) {\\n                            changedFields_1[storeFieldName] = newValue;\\n                            needToMerge_1 = true;\\n                            fieldValue = newValue;\\n                            if (globalThis.__DEV__ !== false) {\\n                                var checkReference = function (ref) {\\n                                    if (_this.lookup(ref.__ref) === undefined) {\\n                                        globalThis.__DEV__ !== false && invariant.warn(2, ref);\\n                                        return true;\\n                                    }\\n                                };\\n                                if (isReference(newValue)) {\\n                                    checkReference(newValue);\\n                                }\\n                                else if (Array.isArray(newValue)) {\\n                                    // Warn about writing \\\"mixed\\\" arrays of Reference and non-Reference objects\\n                                    var seenReference = false;\\n                                    var someNonReference = void 0;\\n                                    for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {\\n                                        var value = newValue_1[_i];\\n                                        if (isReference(value)) {\\n                                            seenReference = true;\\n                                            if (checkReference(value))\\n                                                break;\\n                                        }\\n                                        else {\\n                                            // Do not warn on primitive values, since those could never be represented\\n                                            // by a reference. This is a valid (albeit uncommon) use case.\\n                                            if (typeof value === \\\"object\\\" && !!value) {\\n                                                var id = _this.policies.identify(value)[0];\\n                                                // check if object could even be referenced, otherwise we are not interested in it for this warning\\n                                                if (id) {\\n                                                    someNonReference = value;\\n                                                }\\n                                            }\\n                                        }\\n                                        if (seenReference && someNonReference !== undefined) {\\n                                            globalThis.__DEV__ !== false && invariant.warn(3, someNonReference);\\n                                            break;\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n                if (fieldValue !== void 0) {\\n                    allDeleted_1 = false;\\n                }\\n            });\\n            if (needToMerge_1) {\\n                this.merge(dataId, changedFields_1);\\n                if (allDeleted_1) {\\n                    if (this instanceof Layer) {\\n                        this.data[dataId] = void 0;\\n                    }\\n                    else {\\n                        delete this.data[dataId];\\n                    }\\n                    this.group.dirty(dataId, \\\"__exists\\\");\\n                }\\n                return true;\\n            }\\n        }\\n        return false;\\n    };\\n    // If called with only one argument, removes the entire entity\\n    // identified by dataId. If called with a fieldName as well, removes all\\n    // fields of that entity whose names match fieldName according to the\\n    // fieldNameFromStoreName helper function. If called with a fieldName\\n    // and variables, removes all fields of that entity whose names match fieldName\\n    // and whose arguments when cached exactly match the variables passed.\\n    EntityStore.prototype.delete = function (dataId, fieldName, args) {\\n        var _a;\\n        var storeObject = this.lookup(dataId);\\n        if (storeObject) {\\n            var typename = this.getFieldValue(storeObject, \\\"__typename\\\");\\n            var storeFieldName = fieldName && args ?\\n                this.policies.getStoreFieldName({ typename: typename, fieldName: fieldName, args: args })\\n                : fieldName;\\n            return this.modify(dataId, storeFieldName ? (_a = {},\\n                _a[storeFieldName] = delModifier,\\n                _a) : delModifier);\\n        }\\n        return false;\\n    };\\n    EntityStore.prototype.evict = function (options, limit) {\\n        var evicted = false;\\n        if (options.id) {\\n            if (hasOwn.call(this.data, options.id)) {\\n                evicted = this.delete(options.id, options.fieldName, options.args);\\n            }\\n            if (this instanceof Layer && this !== limit) {\\n                evicted = this.parent.evict(options, limit) || evicted;\\n            }\\n            // Always invalidate the field to trigger rereading of watched\\n            // queries, even if no cache data was modified by the eviction,\\n            // because queries may depend on computed fields with custom read\\n            // functions, whose values are not stored in the EntityStore.\\n            if (options.fieldName || evicted) {\\n                this.group.dirty(options.id, options.fieldName || \\\"__exists\\\");\\n            }\\n        }\\n        return evicted;\\n    };\\n    EntityStore.prototype.clear = function () {\\n        this.replace(null);\\n    };\\n    EntityStore.prototype.extract = function () {\\n        var _this = this;\\n        var obj = this.toObject();\\n        var extraRootIds = [];\\n        this.getRootIdSet().forEach(function (id) {\\n            if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {\\n                extraRootIds.push(id);\\n            }\\n        });\\n        if (extraRootIds.length) {\\n            obj.__META = { extraRootIds: extraRootIds.sort() };\\n        }\\n        return obj;\\n    };\\n    EntityStore.prototype.replace = function (newData) {\\n        var _this = this;\\n        Object.keys(this.data).forEach(function (dataId) {\\n            if (!(newData && hasOwn.call(newData, dataId))) {\\n                _this.delete(dataId);\\n            }\\n        });\\n        if (newData) {\\n            var __META = newData.__META, rest_1 = __rest(newData, [\\\"__META\\\"]);\\n            Object.keys(rest_1).forEach(function (dataId) {\\n                _this.merge(dataId, rest_1[dataId]);\\n            });\\n            if (__META) {\\n                __META.extraRootIds.forEach(this.retain, this);\\n            }\\n        }\\n    };\\n    EntityStore.prototype.retain = function (rootId) {\\n        return (this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1);\\n    };\\n    EntityStore.prototype.release = function (rootId) {\\n        if (this.rootIds[rootId] > 0) {\\n            var count = --this.rootIds[rootId];\\n            if (!count)\\n                delete this.rootIds[rootId];\\n            return count;\\n        }\\n        return 0;\\n    };\\n    // Return a Set<string> of all the ID strings that have been retained by\\n    // this layer/root *and* any layers/roots beneath it.\\n    EntityStore.prototype.getRootIdSet = function (ids) {\\n        if (ids === void 0) { ids = new Set(); }\\n        Object.keys(this.rootIds).forEach(ids.add, ids);\\n        if (this instanceof Layer) {\\n            this.parent.getRootIdSet(ids);\\n        }\\n        else {\\n            // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\\n            // always considered roots for garbage collection, regardless of\\n            // their retainment counts in this.rootIds.\\n            Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\\n        }\\n        return ids;\\n    };\\n    // The goal of garbage collection is to remove IDs from the Root layer of the\\n    // store that are no longer reachable starting from any IDs that have been\\n    // explicitly retained (see retain and release, above). Returns an array of\\n    // dataId strings that were removed from the store.\\n    EntityStore.prototype.gc = function () {\\n        var _this = this;\\n        var ids = this.getRootIdSet();\\n        var snapshot = this.toObject();\\n        ids.forEach(function (id) {\\n            if (hasOwn.call(snapshot, id)) {\\n                // Because we are iterating over an ECMAScript Set, the IDs we add here\\n                // will be visited in later iterations of the forEach loop only if they\\n                // were not previously contained by the Set.\\n                Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);\\n                // By removing IDs from the snapshot object here, we protect them from\\n                // getting removed from the root store layer below.\\n                delete snapshot[id];\\n            }\\n        });\\n        var idsToRemove = Object.keys(snapshot);\\n        if (idsToRemove.length) {\\n            var root_1 = this;\\n            while (root_1 instanceof Layer)\\n                root_1 = root_1.parent;\\n            idsToRemove.forEach(function (id) { return root_1.delete(id); });\\n        }\\n        return idsToRemove;\\n    };\\n    EntityStore.prototype.findChildRefIds = function (dataId) {\\n        if (!hasOwn.call(this.refs, dataId)) {\\n            var found_1 = (this.refs[dataId] = Object.create(null));\\n            var root = this.data[dataId];\\n            if (!root)\\n                return found_1;\\n            var workSet_1 = new Set([root]);\\n            // Within the store, only arrays and objects can contain child entity\\n            // references, so we can prune the traversal using this predicate:\\n            workSet_1.forEach(function (obj) {\\n                if (isReference(obj)) {\\n                    found_1[obj.__ref] = true;\\n                    // In rare cases, a { __ref } Reference object may have other fields.\\n                    // This often indicates a mismerging of References with StoreObjects,\\n                    // but garbage collection should not be fooled by a stray __ref\\n                    // property in a StoreObject (ignoring all the other fields just\\n                    // because the StoreObject looks like a Reference). To avoid this\\n                    // premature termination of findChildRefIds recursion, we fall through\\n                    // to the code below, which will handle any other properties of obj.\\n                }\\n                if (isNonNullObject(obj)) {\\n                    Object.keys(obj).forEach(function (key) {\\n                        var child = obj[key];\\n                        // No need to add primitive values to the workSet, since they cannot\\n                        // contain reference objects.\\n                        if (isNonNullObject(child)) {\\n                            workSet_1.add(child);\\n                        }\\n                    });\\n                }\\n            });\\n        }\\n        return this.refs[dataId];\\n    };\\n    EntityStore.prototype.makeCacheKey = function () {\\n        return this.group.keyMaker.lookupArray(arguments);\\n    };\\n    return EntityStore;\\n}());\\nexport { EntityStore };\\n// A single CacheGroup represents a set of one or more EntityStore objects,\\n// typically the Root store in a CacheGroup by itself, and all active Layer\\n// stores in a group together. A single EntityStore object belongs to only\\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\\n// dependencies, so store.group is helpful for generating unique keys for\\n// cached results that need to be invalidated when/if those dependencies\\n// change. If we used the EntityStore objects themselves as cache keys (that\\n// is, store rather than store.group), the cache would become unnecessarily\\n// fragmented by all the different Layer objects. Instead, the CacheGroup\\n// approach allows all optimistic Layer objects in the same linked list to\\n// belong to one CacheGroup, with the non-optimistic Root object belonging\\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\\n// separately for optimistic and non-optimistic entity data.\\nvar CacheGroup = /** @class */ (function () {\\n    function CacheGroup(caching, parent) {\\n        if (parent === void 0) { parent = null; }\\n        this.caching = caching;\\n        this.parent = parent;\\n        this.d = null;\\n        this.resetCaching();\\n    }\\n    CacheGroup.prototype.resetCaching = function () {\\n        this.d = this.caching ? dep() : null;\\n        this.keyMaker = new Trie(canUseWeakMap);\\n    };\\n    CacheGroup.prototype.depend = function (dataId, storeFieldName) {\\n        if (this.d) {\\n            this.d(makeDepKey(dataId, storeFieldName));\\n            var fieldName = fieldNameFromStoreName(storeFieldName);\\n            if (fieldName !== storeFieldName) {\\n                // Fields with arguments that contribute extra identifying\\n                // information to the fieldName (thus forming the storeFieldName)\\n                // depend not only on the full storeFieldName but also on the\\n                // short fieldName, so the field can be invalidated using either\\n                // level of specificity.\\n                this.d(makeDepKey(dataId, fieldName));\\n            }\\n            if (this.parent) {\\n                this.parent.depend(dataId, storeFieldName);\\n            }\\n        }\\n    };\\n    CacheGroup.prototype.dirty = function (dataId, storeFieldName) {\\n        if (this.d) {\\n            this.d.dirty(makeDepKey(dataId, storeFieldName), \\n            // When storeFieldName === \\\"__exists\\\", that means the entity identified\\n            // by dataId has either disappeared from the cache or was newly added,\\n            // so the result caching system would do well to \\\"forget everything it\\n            // knows\\\" about that object. To achieve that kind of invalidation, we\\n            // not only dirty the associated result cache entry, but also remove it\\n            // completely from the dependency graph. For the optimism implementation\\n            // details, see https://github.com/benjamn/optimism/pull/195.\\n            storeFieldName === \\\"__exists\\\" ? \\\"forget\\\" : \\\"setDirty\\\");\\n        }\\n    };\\n    return CacheGroup;\\n}());\\nfunction makeDepKey(dataId, storeFieldName) {\\n    // Since field names cannot have '#' characters in them, this method\\n    // of joining the field name and the ID should be unambiguous, and much\\n    // cheaper than JSON.stringify([dataId, fieldName]).\\n    return storeFieldName + \\\"#\\\" + dataId;\\n}\\nexport function maybeDependOnExistenceOfEntity(store, entityId) {\\n    if (supportsResultCaching(store)) {\\n        // We use this pseudo-field __exists elsewhere in the EntityStore code to\\n        // represent changes in the existence of the entity object identified by\\n        // entityId. This dependency gets reliably dirtied whenever an object with\\n        // this ID is deleted (or newly created) within this group, so any result\\n        // cache entries (for example, StoreReader#executeSelectionSet results) that\\n        // depend on __exists for this entityId will get dirtied as well, leading to\\n        // the eventual recomputation (instead of reuse) of those result objects the\\n        // next time someone reads them from the cache.\\n        store.group.depend(entityId, \\\"__exists\\\");\\n    }\\n}\\n(function (EntityStore) {\\n    // Refer to this class as EntityStore.Root outside this namespace.\\n    var Root = /** @class */ (function (_super) {\\n        __extends(Root, _super);\\n        function Root(_a) {\\n            var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;\\n            var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;\\n            _this.stump = new Stump(_this);\\n            _this.storageTrie = new Trie(canUseWeakMap);\\n            if (seed)\\n                _this.replace(seed);\\n            return _this;\\n        }\\n        Root.prototype.addLayer = function (layerId, replay) {\\n            // Adding an optimistic Layer on top of the Root actually adds the Layer\\n            // on top of the Stump, so the Stump always comes between the Root and\\n            // any Layer objects that we've added.\\n            return this.stump.addLayer(layerId, replay);\\n        };\\n        Root.prototype.removeLayer = function () {\\n            // Never remove the root layer.\\n            return this;\\n        };\\n        Root.prototype.getStorage = function () {\\n            return this.storageTrie.lookupArray(arguments);\\n        };\\n        return Root;\\n    }(EntityStore));\\n    EntityStore.Root = Root;\\n})(EntityStore || (EntityStore = {}));\\n// Not exported, since all Layer instances are created by the addLayer method\\n// of the EntityStore.Root class.\\nvar Layer = /** @class */ (function (_super) {\\n    __extends(Layer, _super);\\n    function Layer(id, parent, replay, group) {\\n        var _this = _super.call(this, parent.policies, group) || this;\\n        _this.id = id;\\n        _this.parent = parent;\\n        _this.replay = replay;\\n        _this.group = group;\\n        replay(_this);\\n        return _this;\\n    }\\n    Layer.prototype.addLayer = function (layerId, replay) {\\n        return new Layer(layerId, this, replay, this.group);\\n    };\\n    Layer.prototype.removeLayer = function (layerId) {\\n        var _this = this;\\n        // Remove all instances of the given id, not just the first one.\\n        var parent = this.parent.removeLayer(layerId);\\n        if (layerId === this.id) {\\n            if (this.group.caching) {\\n                // Dirty every ID we're removing. Technically we might be able to avoid\\n                // dirtying fields that have values in higher layers, but we don't have\\n                // easy access to higher layers here, and we're about to recreate those\\n                // layers anyway (see parent.addLayer below).\\n                Object.keys(this.data).forEach(function (dataId) {\\n                    var ownStoreObject = _this.data[dataId];\\n                    var parentStoreObject = parent[\\\"lookup\\\"](dataId);\\n                    if (!parentStoreObject) {\\n                        // The StoreObject identified by dataId was defined in this layer\\n                        // but will be undefined in the parent layer, so we can delete the\\n                        // whole entity using this.delete(dataId). Since we're about to\\n                        // throw this layer away, the only goal of this deletion is to dirty\\n                        // the removed fields.\\n                        _this.delete(dataId);\\n                    }\\n                    else if (!ownStoreObject) {\\n                        // This layer had an entry for dataId but it was undefined, which\\n                        // means the entity was deleted in this layer, and it's about to\\n                        // become undeleted when we remove this layer, so we need to dirty\\n                        // all fields that are about to be reexposed.\\n                        _this.group.dirty(dataId, \\\"__exists\\\");\\n                        Object.keys(parentStoreObject).forEach(function (storeFieldName) {\\n                            _this.group.dirty(dataId, storeFieldName);\\n                        });\\n                    }\\n                    else if (ownStoreObject !== parentStoreObject) {\\n                        // If ownStoreObject is not exactly the same as parentStoreObject,\\n                        // dirty any fields whose values will change as a result of this\\n                        // removal.\\n                        Object.keys(ownStoreObject).forEach(function (storeFieldName) {\\n                            if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {\\n                                _this.group.dirty(dataId, storeFieldName);\\n                            }\\n                        });\\n                    }\\n                });\\n            }\\n            return parent;\\n        }\\n        // No changes are necessary if the parent chain remains identical.\\n        if (parent === this.parent)\\n            return this;\\n        // Recreate this layer on top of the new parent.\\n        return parent.addLayer(this.id, this.replay);\\n    };\\n    Layer.prototype.toObject = function () {\\n        return __assign(__assign({}, this.parent.toObject()), this.data);\\n    };\\n    Layer.prototype.findChildRefIds = function (dataId) {\\n        var fromParent = this.parent.findChildRefIds(dataId);\\n        return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;\\n    };\\n    Layer.prototype.getStorage = function () {\\n        var p = this.parent;\\n        while (p.parent)\\n            p = p.parent;\\n        return p.getStorage.apply(p, \\n        // @ts-expect-error\\n        arguments);\\n    };\\n    return Layer;\\n}(EntityStore));\\n// Represents a Layer permanently installed just above the Root, which allows\\n// reading optimistically (and registering optimistic dependencies) even when\\n// no optimistic layers are currently active. The stump.group CacheGroup object\\n// is shared by any/all Layer objects added on top of the Stump.\\nvar Stump = /** @class */ (function (_super) {\\n    __extends(Stump, _super);\\n    function Stump(root) {\\n        return _super.call(this, \\\"EntityStore.Stump\\\", root, function () { }, new CacheGroup(root.group.caching, root.group)) || this;\\n    }\\n    Stump.prototype.removeLayer = function () {\\n        // Never remove the Stump layer.\\n        return this;\\n    };\\n    Stump.prototype.merge = function (older, newer) {\\n        // We never want to write any data into the Stump, so we forward any merge\\n        // calls to the Root instead. Another option here would be to throw an\\n        // exception, but the toReference(object, true) function can sometimes\\n        // trigger Stump writes (which used to be Root writes, before the Stump\\n        // concept was introduced).\\n        return this.parent.merge(older, newer);\\n    };\\n    return Stump;\\n}(Layer));\\nfunction storeObjectReconciler(existingObject, incomingObject, property) {\\n    var existingValue = existingObject[property];\\n    var incomingValue = incomingObject[property];\\n    // Wherever there is a key collision, prefer the incoming value, unless\\n    // it is deeply equal to the existing value. It's worth checking deep\\n    // equality here (even though blindly returning incoming would be\\n    // logically correct) because preserving the referential identity of\\n    // existing data can prevent needless rereading and rerendering.\\n    return equal(existingValue, incomingValue) ? existingValue : incomingValue;\\n}\\nexport function supportsResultCaching(store) {\\n    // When result caching is disabled, store.depend will be null.\\n    return !!(store instanceof EntityStore && store.group.caching);\\n}\\n//# sourceMappingURL=entityStore.js.map\"],\n  \"mappings\": \"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\",\n  \"names\": [\"EntityStore\", \"CacheGroup\", \"Root\", \"Layer\", \"Stump\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1712968598067,
      "end": 1712968598067,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1712968598067,
      "end": 1712968598067,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1712968598067,
      "end": 1712968598067,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1712968598067,
      "end": 1712968598067,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1712968598067,
      "end": 1712968598068,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1712968598068,
      "end": 1712968598068,
      "order": "normal"
    }
  ]
}
